<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Akka.Streams</name>
    </assembly>
    <members>
        <member name="T:Akka.Streams.ActorMaterializer">
            <summary>
            A ActorMaterializer takes the list of transformations comprising a
            <see cref="!:IFlow&lt;T,TMat&gt;"/> and materializes them in the form of
            <see cref="!:IProcessor&lt;T1,T2&gt;"/> instances. How transformation
            steps are split up into asynchronous regions is implementation
            dependent.
            </summary>
        </member>
        <member name="M:Akka.Streams.ActorMaterializer.Create(Akka.Actor.IActorRefFactory,Akka.Streams.ActorMaterializerSettings,System.String)">
            <summary>
            <para>
            Creates a ActorMaterializer which will execute every step of a transformation
            pipeline within its own <see cref="T:Akka.Actor.ActorBase"/>. The required <see cref="T:Akka.Actor.IActorRefFactory"/>
            (which can be either an <see cref="T:Akka.Actor.ActorSystem"/> or an <see cref="T:Akka.Actor.IActorContext"/>)
            will be used to create one actor that in turn creates actors for the transformation steps.
            </para>
            <para>
            The materializer's <see cref="T:Akka.Streams.ActorMaterializerSettings"/> will be obtained from the
            configuration of the <paramref name="context"/>'s underlying <see cref="T:Akka.Actor.ActorSystem"/>.
            </para>
            <para>
            The <paramref name="namePrefix"/> is used as the first part of the names of the actors running
            the processing steps. The default <paramref name="namePrefix"/> is `"flow"`. The actor names are built up of
            `namePrefix-flowNumber-flowStepNumber-stepName`.
            </para>
            </summary>
        </member>
        <member name="P:Akka.Streams.ActorMaterializer.IsShutdown">
            <summary>
            Indicates if the materializer has been shut down.
            </summary>
        </member>
        <member name="M:Akka.Streams.ActorMaterializer.Shutdown">
            <summary>
            Shuts down this materializer and all the stages that have been materialized through this materializer. After
            having shut down, this materializer cannot be used again. Any attempt to materialize stages after having
            shut down will result in an <see cref="!:IllegalStateException"/> being thrown at materialization time.
            </summary>
        </member>
        <member name="T:Akka.Streams.AbruptTerminationException">
            <summary>
            This exception signals that an actor implementing a Reactive Streams Subscriber, Publisher or Processor
            has been terminated without being notified by an onError, onComplete or cancel signal. This usually happens
            when an ActorSystem is shut down while stream processing actors are still running.
            </summary>
        </member>
        <member name="T:Akka.Streams.MaterializationException">
            <summary>
            This exception or subtypes thereof should be used to signal materialization failures.
            </summary>
        </member>
        <member name="T:Akka.Streams.ActorMaterializerSettings">
            <summary>
            This class describes the configurable properties of the <see cref="T:Akka.Streams.ActorMaterializer"/>. 
            Please refer to the `withX` methods for descriptions of the individual settings.
            </summary>
        </member>
        <member name="T:Akka.Streams.StreamSubscriptionTimeoutSettings">
            <summary>
            Leaked publishers and subscribers are cleaned up when they are not used within a given deadline, configured by <see cref="T:Akka.Streams.StreamSubscriptionTimeoutSettings"/>.
            </summary>
        </member>
        <member name="T:Akka.Streams.StreamSubscriptionTimeoutTerminationMode">
            <summary>
            This mode describes what shall happen when the subscription timeout expires 
            for substream Publishers created by operations like `PrefixAndTail`.
            </summary>
        </member>
        <member name="F:Akka.Streams.StreamSubscriptionTimeoutTerminationMode.NoopTermination">
            <summary>
            Do not do anything when timeout expires.
            </summary>
        </member>
        <member name="F:Akka.Streams.StreamSubscriptionTimeoutTerminationMode.WarnTermination">
            <summary>
            Log a warning when the timeout expires.
            </summary>
        </member>
        <member name="F:Akka.Streams.StreamSubscriptionTimeoutTerminationMode.CancelTermination">
            <summary>
            When the timeout expires attach a Subscriber that will immediately cancel its subscription.
            </summary>
        </member>
        <member name="M:Akka.Streams.ActorMaterializerExtensions.Materializer(Akka.Actor.IActorRefFactory,Akka.Streams.ActorMaterializerSettings,System.String)">
            <summary>
            <para>
            Creates a ActorMaterializer which will execute every step of a transformation
            pipeline within its own <see cref="T:Akka.Actor.ActorBase"/>. The required <see cref="T:Akka.Actor.IActorRefFactory"/>
            (which can be either an <see cref="T:Akka.Actor.ActorSystem"/> or an <see cref="T:Akka.Actor.IActorContext"/>)
            will be used to create one actor that in turn creates actors for the transformation steps.
            </para>
            <para>
            The materializer's <see cref="T:Akka.Streams.ActorMaterializerSettings"/> will be obtained from the
            configuration of the <paramref name="context"/>'s underlying <see cref="T:Akka.Actor.ActorSystem"/>.
            </para>
            <para>
            The <paramref name="namePrefix"/> is used as the first part of the names of the actors running
            the processing steps. The default <paramref name="namePrefix"/> is `"flow"`. The actor names are built up of
            `namePrefix-flowNumber-flowStepNumber-stepName`.
            </para>
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.Request">
            <summary>
            This message is delivered to the <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/> actor when the stream
            subscriber requests more elements.
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.Cancel">
            <summary>
            This message is delivered to the <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/> actor when the stream
            subscriber cancels the subscription.
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.SubscriptionTimeoutExceeded">
            <summary>
            This message is delivered to the <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/> actor in order to signal
            the exceeding of an subscription timeout. Once the actor receives this message, this
            publisher will already be in cancelled state, thus the actor should clean-up and stop itself.
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.ActorPublisher`1">
            <summary>
            <para>
            Extend this actor to make it a stream publisher that keeps track of the subscription life cycle and
            requested elements.
            </para>
            <para>
            Create a <see cref="T:System.Reactive.Streams.IPublisher`1"/> backed by this actor with <see cref="M:Akka.Streams.Actors.ActorPublisher.Create``1(Akka.Actor.IActorRef)"/>.
            </para>
            <para>
            It can be attached to a <see cref="T:System.Reactive.Streams.ISubscriber`1"/> or be used as an input source for a
            <see cref="T:Akka.Streams.Dsl.IFlow`2"/>. You can only attach one subscriber to this publisher.
            </para>
            <para>
            The life cycle state of the subscription is tracked with the following boolean members:
            <see cref="P:Akka.Streams.Actors.ActorPublisher`1.IsActive"/>, <see cref="P:Akka.Streams.Actors.ActorPublisher`1.IsCompleted"/>, <see cref="P:Akka.Streams.Actors.ActorPublisher`1.IsErrorEmitted"/>,
            and <see cref="P:Akka.Streams.Actors.ActorPublisher`1.IsCanceled"/>.
            </para>
            <para>
            You send elements to the stream by calling <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>. You are allowed to send as many
            elements as have been requested by the stream subscriber. This amount can be inquired with
            <see cref="P:Akka.Streams.Actors.ActorPublisher`1.TotalDemand"/>. It is only allowed to use <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/> when <see cref="P:Akka.Streams.Actors.ActorPublisher`1.IsActive"/>
            <see cref="P:Akka.Streams.Actors.ActorPublisher`1.TotalDemand"/> &gt; 0, otherwise <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/> will throw
            <see cref="T:Akka.Pattern.IllegalStateException"/>.
            </para>
            <para>
            When the stream subscriber requests more elements the <see cref="T:Akka.Streams.Actors.Request"/> message
            is delivered to this actor, and you can act on that event. The <see cref="P:Akka.Streams.Actors.ActorPublisher`1.TotalDemand"/>
            is updated automatically.
            </para>
            <para>
            When the stream subscriber cancels the subscription the <see cref="T:Akka.Streams.Actors.Cancel"/> message
            is delivered to this actor. After that subsequent calls to <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/> will be ignored.
            </para>
            <para>
            You can complete the stream by calling <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/>. After that you are not allowed to
            call <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>, <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/> and <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/>.
            </para>
            <para>
            You can terminate the stream with failure by calling <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/>. After that you are not allowed to
            call <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>, <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/> and <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/>.
            </para>
            <para>
            If you suspect that this <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/> may never get subscribed to,
            you can override the <see cref="P:Akka.Streams.Actors.ActorPublisher`1.SubscriptionTimeout"/> method to provide a timeout after which
            this Publisher should be considered canceled. The actor will be notified when
            the timeout triggers via an <see cref="T:Akka.Streams.Actors.SubscriptionTimeoutExceeded"/> message and MUST then
            perform cleanup and stop itself.
            </para>
            <para>
            If the actor is stopped the stream will be completed, unless it was not already terminated with
            failure, completed or canceled.
            </para>
            </summary>
        </member>
        <member name="P:Akka.Streams.Actors.ActorPublisher`1.SubscriptionTimeout">
             <summary>
             Subscription timeout after which this actor will become Canceled and reject any incoming "late" subscriber.
            
             The actor will receive an [[SubscriptionTimeoutExceeded]] message upon which it
             MUST react by performing all necessary cleanup and stopping itself.
            
             Use this feature in order to avoid leaking actors when you suspect that this Publisher may never get subscribed to by some Subscriber.
             </summary>
             <summary>
             <para>
             Subscription timeout after which this actor will become Canceled and reject any incoming "late" subscriber.
             </para>
             <para>
             The actor will receive an <see cref="T:Akka.Streams.Actors.SubscriptionTimeoutExceeded"/> message upon which it
             MUST react by performing all necessary cleanup and stopping itself.
             </para>
             <para>
             Use this feature in order to avoid leaking actors when you suspect that this Publisher
             may never get subscribed to by some Subscriber.
             </para>
             </summary>
        </member>
        <member name="P:Akka.Streams.Actors.ActorPublisher`1.IsActive">
            <summary>
            The state when the publisher is active, i.e. before the subscriber is attached
            and when an subscriber is attached. It is allowed to
            call <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/> and <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/> in this state. It is
            allowed to call <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/> in this state when <see cref="P:Akka.Streams.Actors.ActorPublisher`1.TotalDemand"/>
            is greater than zero.
            </summary>
        </member>
        <member name="P:Akka.Streams.Actors.ActorPublisher`1.TotalDemand">
            <summary>
            Total number of requested elements from the stream subscriber.
            This actor automatically keeps tracks of this amount based on
            incoming request messages and outgoing <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>.
            </summary>
        </member>
        <member name="P:Akka.Streams.Actors.ActorPublisher`1.IsCompleted">
            <summary>
            The terminal state after calling <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/>. It is not allowed to
            <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>, <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/>, and <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/> in this state.
            </summary>
        </member>
        <member name="P:Akka.Streams.Actors.ActorPublisher`1.IsErrorEmitted">
            <summary>
            The terminal state after calling <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/>. It is not allowed to
            call <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>, <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/>, and <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/> in this state.
            </summary>
        </member>
        <member name="P:Akka.Streams.Actors.ActorPublisher`1.IsCanceled">
            <summary>
            The state after the stream subscriber has canceled the subscription.
            It is allowed to call <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>, <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/>, and <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/> in
            this state, but the calls will not perform anything.
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)">
            <summary>
            Send an element to the stream subscriber. You are allowed to send as many elements
            as have been requested by the stream subscriber. This amount can be inquired with
            <see cref="P:Akka.Streams.Actors.ActorPublisher`1.TotalDemand"/>. It is only allowed to use <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/> when
            <see cref="P:Akka.Streams.Actors.ActorPublisher`1.IsActive"/> and <see cref="P:Akka.Streams.Actors.ActorPublisher`1.TotalDemand"/> &gt; 0,
            otherwise <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/> will throw <see cref="T:Akka.Pattern.IllegalStateException"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete">
            <summary>
            Complete the stream. After that you are not allowed to
            call <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>, <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/> and <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisher`1.OnCompleteThenStop">
            <summary>
            <para>
            Complete the stream. After that you are not allowed to
            call <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>, <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/> and <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/>.
            </para>
            <para>
            After signalling completion the Actor will then stop itself as it has completed the protocol.
            When <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/> is called before any <see cref="T:System.Reactive.Streams.ISubscriber`1"/> has had the chance to subscribe
            to this <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/> the completion signal (and therefore stopping of the Actor as well)
            will be delayed until such <see cref="T:System.Reactive.Streams.ISubscriber`1"/> arrives.
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)">
            <summary>
            Terminate the stream with failure. After that you are not allowed to
            call <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>, <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/> and <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorPublisher`1.OnErrorThenStop(System.Exception)">
            <summary>
            <para>
            Terminate the stream with failure. After that you are not allowed to
            call <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnNext(`0)"/>, <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/> and <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnComplete"/>.
            </para>
            <para>
            After signalling the Error the Actor will then stop itself as it has completed the protocol.
            When <see cref="M:Akka.Streams.Actors.ActorPublisher`1.OnError(System.Exception)"/> is called before any <see cref="T:System.Reactive.Streams.ISubscriber`1"/> has had the chance to subscribe
            to this <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/> the error signal (and therefore stopping of the Actor as well)
            will be delayed until such <see cref="T:System.Reactive.Streams.ISubscriber`1"/> arrives.
            </para>
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.ActorSubscriber">
            <summary>
            <para>
            Extend this actor to make it a
            stream subscriber with full control of stream back pressure. It will receive
            <see cref="T:Akka.Streams.Actors.OnNext"/>, <see cref="T:Akka.Streams.Actors.OnComplete"/> and <see cref="T:Akka.Streams.Actors.OnError"/>
            messages from the stream. It can also receive other, non-stream messages, in
            the same way as any actor.
            </para>
            <para>
            Attach the actor as a <see cref="T:System.Reactive.Streams.ISubscriber`1"/> to the stream with
            <see cref="M:Akka.Streams.Actors.ActorSubscriber.Create``1(Akka.Actor.IActorRef)"/>
            </para>
            <para>
            Subclass must define the <see cref="P:Akka.Streams.Actors.ActorSubscriber.RequestStrategy"/> to control stream back pressure.
            After each incoming message the <see cref="T:Akka.Streams.Actors.ActorSubscriber"/> will automatically invoke
            the <see cref="M:Akka.Streams.Actors.IRequestStrategy.RequestDemand(System.Int32)"/> and propagate the returned demand to the stream.
            The provided <see cref="T:Akka.Streams.Actors.WatermarkRequestStrategy"/> is a good strategy if the actor
            performs work itself.
            The provided <see cref="T:Akka.Streams.Actors.MaxInFlightRequestStrategy"/> is useful if messages are
            queued internally or delegated to other actors.
            You can also implement a custom <see cref="T:Akka.Streams.Actors.IRequestStrategy"/> or call <see cref="M:Akka.Streams.Actors.ActorSubscriber.Request(System.Int64)"/> manually
            together with <see cref="T:Akka.Streams.Actors.ZeroRequestStrategy"/> or some other strategy. In that case
            you must also call <see cref="M:Akka.Streams.Actors.ActorSubscriber.Request(System.Int64)"/> when the actor is started or when it is ready, otherwise
            it will not receive any elements.
            </para>
            </summary>
        </member>
        <member name="P:Akka.Streams.Actors.ActorSubscriber.RemainingRequested">
            <summary>
            The number of stream elements that have already been requested from upstream
            but not yet received.
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriber.Request(System.Int64)">
            <summary>
            Request a number of elements from upstream.
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriber.Cancel">
            <summary>
            <para>
            Cancel upstream subscription.
            No more elements will be delivered after cancel.
            </para>
            <para>
            The <see cref="T:Akka.Streams.Actors.ActorSubscriber"/> will be stopped immediatly after signalling cancelation.
            In case the upstream subscription has not yet arrived the Actor will stay alive
            until a subscription arrives, cancel it and then stop itself.
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Actors.ActorSubscriber.Create``1(Akka.Actor.IActorRef)">
            <summary>
            Attach a <see cref="T:Akka.Streams.Actors.ActorSubscriber"/> actor as a <see cref="T:System.Reactive.Streams.ISubscriber`1"/>
            to a <see cref="T:System.Reactive.Streams.IPublisher"/> or <see cref="T:Akka.Streams.Dsl.IFlow`2"/>
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.IRequestStrategy">
            <summary>
             An <see cref="T:Akka.Streams.Actors.ActorSubscriber"/> defines a <see cref="T:Akka.Streams.Actors.IRequestStrategy"/>
             to control the stream back pressure.
             </summary>
        </member>
        <member name="M:Akka.Streams.Actors.IRequestStrategy.RequestDemand(System.Int32)">
            <summary>
            Invoked by the <see cref="T:Akka.Streams.Actors.ActorSubscriber"/> after each incoming message to
            determine how many more elements to request from the stream.
            </summary>
            <param name="remainingRequested">current remaining number of elements
            that have been requested from upstream but not received yet</param>
            <returns>demand of more elements from the stream, returning 0 means that no
            more elements will be requested for now</returns>
        </member>
        <member name="T:Akka.Streams.Actors.OneByOneRequestStrategy">
            <summary>
            Requests one more element when `remainingRequested` is 0, i.e.
            * max one element in flight.
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.ZeroRequestStrategy">
            <summary>
            When request is only controlled with manual calls to <see cref="M:Akka.Streams.Actors.ActorSubscriber.Request(System.Int64)"/>.
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.WatermarkRequestStrategy">
            <summary>
            Requests up to the `highWatermark` when the `remainingRequested` is
            below the `lowWatermark`. This a good strategy when the actor performs work itself.
            </summary>
        </member>
        <member name="T:Akka.Streams.Actors.MaxInFlightRequestStrategy">
            <summary>
            Requests up to the `max` and also takes the number of messages
            that have been queued internally or delegated to other actors into account.
            Concrete subclass must implement <see cref="P:Akka.Streams.Actors.MaxInFlightRequestStrategy.InFlight"/>.
            It will request elements in minimum batches of the defined <see cref="P:Akka.Streams.Actors.MaxInFlightRequestStrategy.BatchSize"/>.
            </summary>
        </member>
        <member name="P:Akka.Streams.Actors.MaxInFlightRequestStrategy.InFlight">
            <summary>
            Concrete subclass must implement this method to define how many
            messages that are currently in progress or queued.
            </summary>
        </member>
        <member name="P:Akka.Streams.Actors.MaxInFlightRequestStrategy.BatchSize">
            <summary>
            Elements will be requested in minimum batches of this size.
            Default is 5. Subclass may override to define the batch size.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Create``2(System.Func{Akka.Streams.Dsl.GraphDsl.Builder{``1},``0})">
            <summary>
            Creates a new <see cref="T:Akka.Streams.IGraph`2"/> by passing a <see cref="T:Akka.Streams.Dsl.GraphDsl.Builder`1"/> to the given create function.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Create``3(Akka.Streams.IGraph{``2,``1},System.Func{Akka.Streams.Dsl.GraphDsl.Builder{``1},``2,``0})">
            <summary>
            Creates a new <see cref="T:Akka.Streams.IGraph`2"/> by importing the given graph <paramref name="g1"/> 
            and passing its <see cref="T:Akka.Streams.Shape"/> along with the <see cref="T:Akka.Streams.Dsl.GraphDsl.Builder`1"/> to the given create function.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Create``6(Akka.Streams.IGraph{``4,``2},Akka.Streams.IGraph{``5,``3},System.Func{``2,``3,``1},System.Func{Akka.Streams.Dsl.GraphDsl.Builder{``1},``4,``5,``0})">
            <summary>
            Creates a new <see cref="T:Akka.Streams.IGraph`2"/> by importing the given graphs and passing their <see cref="T:Akka.Streams.Shape"/>s 
            along with the <see cref="T:Akka.Streams.Dsl.GraphDsl.Builder`1"/> to the given create function.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Create``8(Akka.Streams.IGraph{``5,``2},Akka.Streams.IGraph{``6,``3},Akka.Streams.IGraph{``7,``4},System.Func{``2,``3,``4,``1},System.Func{Akka.Streams.Dsl.GraphDsl.Builder{``1},``5,``6,``7,``0})">
            <summary>
            Creates a new <see cref="T:Akka.Streams.IGraph`2"/> by importing the given graphs and passing their <see cref="T:Akka.Streams.Shape"/>s 
            along with the <see cref="T:Akka.Streams.Dsl.GraphDsl.Builder`1"/> to the given create function.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Create``10(Akka.Streams.IGraph{``6,``2},Akka.Streams.IGraph{``7,``3},Akka.Streams.IGraph{``8,``4},Akka.Streams.IGraph{``9,``5},System.Func{``2,``3,``4,``5,``1},System.Func{Akka.Streams.Dsl.GraphDsl.Builder{``1},``6,``7,``8,``9,``0})">
            <summary>
            Creates a new <see cref="T:Akka.Streams.IGraph`2"/> by importing the given graphs and passing their <see cref="T:Akka.Streams.Shape"/>s 
            along with the <see cref="T:Akka.Streams.Dsl.GraphDsl.Builder`1"/> to the given create function.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Create``12(Akka.Streams.IGraph{``7,``2},Akka.Streams.IGraph{``8,``3},Akka.Streams.IGraph{``9,``4},Akka.Streams.IGraph{``10,``5},Akka.Streams.IGraph{``11,``6},System.Func{``2,``3,``4,``5,``6,``1},System.Func{Akka.Streams.Dsl.GraphDsl.Builder{``1},``7,``8,``9,``10,``11,``0})">
            <summary>
            Creates a new <see cref="T:Akka.Streams.IGraph`2"/> by importing the given graphs and passing their <see cref="T:Akka.Streams.Shape"/>s 
            along with the <see cref="T:Akka.Streams.Dsl.GraphDsl.Builder`1"/> to the given create function.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.Add``3(Akka.Streams.IGraph{``0,``1},System.Func{``1,``2})">
            <summary>
            INTERNAL API. 
            This is only used by the materialization-importing apply methods of Source,
            Flow, Sink and Graph.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.Add``4(Akka.Streams.IGraph{``0},System.Func{``1,``2,``3})">
            <summary>
            INTERNAL API. 
            This is only used by the materialization-importing apply methods of Source,
            Flow, Sink and Graph.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.GraphDsl.Builder`1.Add``2(Akka.Streams.IGraph{``0,``1})">
            <summary>
            Import a graph into this module, performing a deep copy, discarding its
            materialized value and returning the copied Ports that are now to be connected.
            </summary>
        </member>
        <member name="P:Akka.Streams.Dsl.GraphDsl.Builder`1.MaterializedValue">
            <summary>
            Returns an <see cref="T:Akka.Streams.Outlet`1"/> that gives access to the materialized value of this graph. Once the graph is materialized
            this outlet will emit exactly one element which is the materialized value. It is possible to expose this
            outlet as an externally accessible outlet of a <see cref="T:Akka.Streams.Dsl.Source`2"/>, <see cref="T:Akka.Streams.Dsl.Sink`2"/>, 
            <see cref="T:Akka.Streams.Dsl.Flow`3"/> or <see cref="T:Akka.Streams.Dsl.BidiFlow`5"/>.
            
            It is possible to call this method multiple times to get multiple <see cref="T:Akka.Streams.Outlet`1"/> instances if necessary. All of
            the outlets will emit the materialized value.
            
            Be careful to not to feed the result of this outlet to a stage that produces the materialized value itself (for
            example to a <see cref="M:Akka.Streams.Dsl.Sink.Fold``2(``1,System.Func{``1,``0,``1})"/> that contributes to the materialized value) since that might lead to an unresolvable
            dependency cycle.
            </summary> 
        </member>
        <member name="T:Akka.Streams.Dsl.UnzipWith">
            <summary>
            Transforms each element of input stream into multiple streams using a splitter function.
            <para>
            '''Emits when''' all of the outputs stops backpressuring and there is an input element available
            </para>
            '''Backpressures when''' any of the outputs backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' any downstream cancels
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.ZipWith">
            <summary>
            Combine the elements of multiple streams into a stream of combined elements using a combiner function.
            <para>
            '''Emits when''' all of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' any upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith.Apply``3(System.Func{``0,``1,``2})">
            <summary>
            Create a new <see cref="T:Akka.Streams.Dsl.ZipWith`3"/> specialized for 1 inputs.
            </summary>
            <param name="zipper">zipping-function from the input values to the output value</param>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith.Apply``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Create a new <see cref="T:Akka.Streams.Dsl.ZipWith`4"/> specialized for 1 inputs.
            </summary>
            <param name="zipper">zipping-function from the input values to the output value</param>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith.Apply``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Create a new <see cref="T:Akka.Streams.Dsl.ZipWith`5"/> specialized for 1 inputs.
            </summary>
            <param name="zipper">zipping-function from the input values to the output value</param>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith.Apply``6(System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Create a new <see cref="T:Akka.Streams.Dsl.ZipWith`6"/> specialized for 1 inputs.
            </summary>
            <param name="zipper">zipping-function from the input values to the output value</param>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith.Apply``7(System.Func{``0,``1,``2,``3,``4,``5,``6})">
            <summary>
            Create a new <see cref="T:Akka.Streams.Dsl.ZipWith`7"/> specialized for 1 inputs.
            </summary>
            <param name="zipper">zipping-function from the input values to the output value</param>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith.Apply``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7})">
            <summary>
            Create a new <see cref="T:Akka.Streams.Dsl.ZipWith`8"/> specialized for 1 inputs.
            </summary>
            <param name="zipper">zipping-function from the input values to the output value</param>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith.Apply``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8})">
            <summary>
            Create a new <see cref="T:Akka.Streams.Dsl.ZipWith`9"/> specialized for 1 inputs.
            </summary>
            <param name="zipper">zipping-function from the input values to the output value</param>
        </member>
        <member name="M:Akka.Streams.Dsl.ZipWith.Apply``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})">
            <summary>
            Create a new <see cref="T:Akka.Streams.Dsl.ZipWith`10"/> specialized for 1 inputs.
            </summary>
            <param name="zipper">zipping-function from the input values to the output value</param>
        </member>
        <member name="M:Akka.Streams.Dsl.BidiFlow.FromGraph``5(Akka.Streams.IGraph{Akka.Streams.BidiShape{``0,``1,``2,``3},``4})">
            <summary>
            A graph with the shape of a flow logically is a flow, this method makes
            it so also in type.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Akka.Streams.Dsl.BidiFlow.FromFlowsMat``7(Akka.Streams.IGraph{Akka.Streams.FlowShape{``0,``1},``4},Akka.Streams.IGraph{Akka.Streams.FlowShape{``2,``3},``5},System.Func{``4,``5,``6})" -->
        <!-- Badly formed XML comment ignored for member "M:Akka.Streams.Dsl.BidiFlow.FromFlows``6(Akka.Streams.IGraph{Akka.Streams.FlowShape{``0,``1},``4},Akka.Streams.IGraph{Akka.Streams.FlowShape{``2,``3},``5})" -->
        <member name="M:Akka.Streams.Dsl.BidiFlow.FromFunction``4(System.Func{``0,``1},System.Func{``2,``3})">
            <summary>
            Create a <see cref="T:Akka.Streams.Dsl.BidiFlow`5"/> where the top and bottom flows are just one simple mapping
            stage each, expressed by the two functions.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.BidiFlow.BidirectionalIdleTimeout``2(System.TimeSpan)">
             <summary>
             If the time between two processed elements ///in any direction/// exceed the provided timeout, the stream is failed
             with a <see cref="T:System.TimeoutException"/>.
            
             There is a difference between this stage and having two idleTimeout Flows assembled into a BidiStage.
             If the timeout is configured to be 1 seconds, then this stage will not fail even though there are elements flowing
             every second in one direction, but no elements are flowing in the other direction. I.e. this stage considers
             the ///joint/// frequencies of the elements in both directions.
             </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.BidiFlow`5.Reversed">
            <summary>
             Turn this BidiFlow around by 180 degrees, logically flipping it upside down in a protocol stack.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Akka.Streams.Dsl.BidiFlow`5.Atop``3(Akka.Streams.Dsl.BidiFlow{`1,``0,``1,`2,``2})" -->
        <!-- Badly formed XML comment ignored for member "M:Akka.Streams.Dsl.BidiFlow`5.AtopMat``4(Akka.Streams.Dsl.BidiFlow{`1,``0,``1,`2,``2},System.Func{`4,``2,``3})" -->
        <!-- Badly formed XML comment ignored for member "M:Akka.Streams.Dsl.BidiFlow`5.Join``1(Akka.Streams.Dsl.Flow{`1,`2,``0})" -->
        <!-- Badly formed XML comment ignored for member "M:Akka.Streams.Dsl.BidiFlow`5.JoinMat``2(Akka.Streams.Dsl.Flow{`1,`2,``0},System.Func{`4,``0,``1})" -->
        <member name="M:Akka.Streams.Dsl.FileIO.FromFile(System.IO.FileInfo,System.Int32)">
             <summary>
             Creates a Source from a Files contents.
             Emitted elements are <paramref name="chunkSize"/> sized <see cref="T:Akka.IO.ByteString"/> elements,
             except the final element, which will be up to <paramref name="chunkSize"/> in size.
            
             You can configure the default dispatcher for this Source by changing the "akka.stream.blocking-io-dispatcher" or
             set it for a given Source by using <see cref="T:Akka.Streams.ActorAttributes"/>.
            
             It materializes a <see cref="T:System.Threading.Tasks.Task`1"/> of <see cref="T:Akka.Streams.IO.IOResult"/> containing the number of bytes read from the source file upon completion,
             and a possible exception if IO operation was not completed successfully.
             </summary>
             <param name="f">the File to read from</param>
             <param name="chunkSize">the size of each read operation, defaults to 8192</param>
        </member>
        <member name="M:Akka.Streams.Dsl.FileIO.ToFile(System.IO.FileInfo,System.Nullable{System.IO.FileMode})">
             <summary>
             Creates a Sink which writes incoming <see cref="T:Akka.IO.ByteString"/> elements to the given file and either overwrites
             or appends to it.
            
             Materializes a <see cref="T:System.Threading.Tasks.Task`1"/> of <see cref="T:Akka.Streams.IO.IOResult"/> that will be completed with the size of the file(in bytes) at the streams completion,
             and a possible exception if IO operation was not completed successfully.
            
             This source is backed by an Actor which will use the dedicated "akka.stream.blocking-io-dispatcher",
             unless configured otherwise by using <see cref="T:Akka.Streams.ActorAttributes"/>.
             </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Recover``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{System.Exception,Akka.Streams.Util.Option{``1}})">
            <summary>
            Recover allows to send last element on failure and gracefully complete the stream
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            <para>
            '''Emits when''' element is available from the upstream or upstream is failed and pf returns an element
            </para>
            <para>
            '''Backpressures when''' downstream backpressures
            </para>
            <para>
            '''Completes when''' upstream completes or upstream failed with exception pf can handle
            </para>
            '''Cancels when''' downstream cancels 
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.RecoverWith``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{System.Exception,Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2}})">
            <summary>
            RecoverWith allows to switch to alternative Source on flow failure. It will stay in effect after
            a failure has been recovered so that each time there is a failure it is fed into the <paramref name="partialFunc"/> and a new
            Source may be materialized.
            <para>
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            </para>
            <para>
            '''Emits when''' element is available from the upstream or upstream is failed and element is available from alternative Source
            </para>
            <para>
            '''Backpressures when''' downstream backpressures
            </para>
            <para>
            '''Completes when''' upstream completes or upstream failed with exception pf can handle
            </para>
            '''Cancels when''' downstream cancels 
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Map``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,``2})">
            <summary>
            Transform this stream by applying the given function to each of the elements
            as they pass through this processing step.
            <para>
            '''Emits when''' the mapping function returns an element
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            <para>
            '''Cancels when''' downstream cancels
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.MapConcat``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,System.Collections.Generic.IEnumerable{``2}})">
            <summary>
            Transform each input element into a sequence of output elements that is
            then flattened into the output stream.
            
            The returned sequence MUST NOT contain `null` values,
            as they are illegal as stream elements - according to the Reactive Streams specification.
            <para>
            '''Emits when''' the mapping function returns an element or there are still remaining elements
            from the previously calculated collection
            </para>
            <para>
            '''Backpressures when''' downstream backpressures or there are still remaining elements from the
            previously calculated collection
            </para>
            <para>
            '''Completes when''' upstream completes and all remaining elements has been emitted
            </para>
            <para>
            '''Cancels when''' downstream cancels
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.StatefulMapConcat``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{System.Func{``1,System.Collections.Generic.IEnumerable{``2}}})">
            <summary>
            Transform each input element into an `Iterable` of output elements that is
            then flattened into the output stream. The transformation is meant to be stateful,
            which is enabled by creating the transformation function anew for every materialization â€”
            the returned function will typically close over mutable objects to store state between
            invocations. For the stateless variant see <see cref="M:Akka.Streams.Dsl.FlowOperations.MapConcat``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,System.Collections.Generic.IEnumerable{``2}})"/>.
            
            The returned `Iterable` MUST NOT contain `null` values,
            as they are illegal as stream elements - according to the Reactive Streams specification.
            
            <para>
            '''Emits when''' the mapping function returns an element or there are still remaining elements
            from the previously calculated collection
            </para>
            <para>
            '''Backpressures when''' downstream backpressures or there are still remaining elements from the
            previously calculated collection
            </para>
            <para>
            '''Completes when''' upstream completes and all remaining elements has been emitted
            </para>
            <para>
            '''Cancels when''' downstream cancels
            </para>
            See also <see cref="M:Akka.Streams.Dsl.FlowOperations.MapConcat``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,System.Collections.Generic.IEnumerable{``2}})"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.MapAsync``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Int32,System.Func{``1,System.Threading.Tasks.Task{``2}})">
            <summary>
            Transform this stream by applying the given function to each of the elements
            as they pass through this processing step. The function returns a `Future` and the
            value of that future will be emitted downstream. The number of Futures
            that shall run in parallel is given as the first argument to ``mapAsync``.
            These Futures may complete in any order, but the elements that
            are emitted downstream are in the same order as received from upstream.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/>
            the stream will be completed with failure.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> the element is dropped and the stream continues.
            <para>
            '''Emits when''' the Task returned by the provided function finishes for the next element in sequence
            </para>
            <para>
            '''Backpressures when''' the number of futures reaches the configured parallelism and the downstream
            backpressures or the first future is not completed
            </para>
            <para>
            '''Completes when''' upstream completes and all futures has been completed and all elements has been emitted
            </para>
            <para>
            '''Cancels when''' downstream cancels
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.MapAsyncUnordered``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Int32,System.Func{``1,System.Threading.Tasks.Task{``2}})">
            <summary>
            Transform this stream by applying the given function to each of the elements
            as they pass through this processing step. The function returns a <see cref="T:System.Threading.Tasks.Task"/> and the
            value of that future will be emitted downstreams. As many futures as requested elements by
            downstream may run in parallel and each processed element will be emitted dowstream
            as soon as it is ready, i.e. it is possible that the elements are not emitted downstream
            in the same order as received from upstream.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="T:Akka.Dispatch.SysMsg.Stop"/>
            the stream will be completed with failure.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the<see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="!:Directive.Resume"/> or
            <see cref="T:Akka.Dispatch.SysMsg.Restart"/> the element is dropped and the stream continues.
            <para>
            '''Emits when''' any of the Futures returned by the provided function complete
            </para>
            <para>
            '''Backpressures when''' the number of futures reaches the configured parallelism and the downstream backpressures
            </para>
            <para>
            '''Completes when''' upstream completes and all futures has been completed and all elements has been emitted
            </para>
            <para>
            '''Cancels when''' downstream cancels
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Filter``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Predicate{``1})">
            <summary>
            Only pass on those elements that satisfy the given predicate.
            <para>
            '''Emits when''' the given predicate returns true for the element
            </para>
            <para>
            '''Backpressures when''' the given predicate returns true for the element and downstream backpressures
            </para>
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.FilterNot``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Predicate{``1})">
            <summary>
            Only pass on those elements that NOT satisfy the given predicate.
            <para>
            '''Emits when''' the given predicate returns true for the element
            </para>
            <para>
            '''Backpressures when''' the given predicate returns true for the element and downstream backpressures
            </para>
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.TakeWhile``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Predicate{``1})">
            <summary>
            Terminate processing (and cancel the upstream publisher) after predicate
            returns false for the first time. Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if predicate is false for
            the first stream element.
            <para>
            '''Emits when''' the predicate is true
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' predicate returned false or upstream completes
            </para>
            '''Cancels when''' predicate returned false or downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.DropWhile``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Predicate{``1})">
            <summary>
            Discard elements at the beginning of the stream while predicate is true.
            All elements will be taken after predicate returns false first time.
            <para>
            '''Emits when''' predicate returned false and for all following stream elements
            </para>
            '''Backpressures when''' predicate returned false and downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Collect``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,``2})">
            <summary>
            Transform this stream by applying the given partial function to each of the elements
            on which the function is defined (read: returns not null) as they pass through this processing step.
            Non-matching elements are filtered out.
            <para>
            '''Emits when''' the provided partial function is defined for the element
            </para>
            '''Backpressures when''' the partial function is defined for the element and downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Grouped``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int32)">
            <summary>
            Chunk up this stream into groups of the given size, with the last group
            possibly smaller than requested due to end-of-stream.
            <paramref name="n"/> must be positive, otherwise <see cref="T:System.ArgumentException"/> is thrown.
            <para>
            '''Emits when''' the specified number of elements has been accumulated or upstream completed
            </para>
            '''Backpressures when''' a group has been assembled and downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <exception cref="T:System.ArgumentException">Thrown, if <paramref name="n"/> is less than or equal zero.</exception>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Limit``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int64)">
            <summary>
            Ensure stream boundedness by limiting the number of elements from upstream.
            If the number of incoming elements exceeds max, it will signal
            upstream failure <see cref="!:StreamLimitException"/> downstream.
            
            Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if `n` is zero
            or negative.
            <para>
            '''Emits when''' the specified number of elements to take has not yet been reached
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' the defined number of elements has been taken or upstream completes
            </para>
            '''Cancels when''' the defined number of elements has been taken or downstream cancels
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.FlowOperations.Take``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int64)"/>
            <seealso cref="M:Akka.Streams.Dsl.FlowOperations.TakeWithin``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.TimeSpan)"/>
            <seealso cref="M:Akka.Streams.Dsl.FlowOperations.TakeWhile``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Predicate{``1})"/>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.LimitWeighted``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int64,System.Func{``1,System.Int64})">
            <summary>
            Ensure stream boundedness by evaluating the cost of incoming elements
            using a cost function. Exactly how many elements will be allowed to travel downstream depends on the
            evaluated cost of each element. If the accumulated cost exceeds max, it will signal
            upstream failure <see cref="!:StreamLimitException"/> downstream.
            
            Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if `n` is zero
            or negative.
            <para>
            '''Emits when''' the specified number of elements to take has not yet been reached
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' the defined number of elements has been taken or upstream completes
            </para>
            '''Cancels when''' the defined number of elements has been taken or downstream cancels
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.FlowOperations.Take``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int64)"/>
            <seealso cref="M:Akka.Streams.Dsl.FlowOperations.TakeWithin``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.TimeSpan)"/>
            <seealso cref="M:Akka.Streams.Dsl.FlowOperations.TakeWhile``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Predicate{``1})"/>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Sliding``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int32,System.Int32)">
            <summary>
            Apply a sliding window over the stream and return the windows as groups of elements, with the last group
            possibly smaller than requested due to end-of-stream.
            
            <paramref name="n"/> must be positive, otherwise IllegalArgumentException is thrown.
            <paramref name="step"/> must be positive, otherwise IllegalArgumentException is thrown.
            <para>
            '''Emits when''' enough elements have been collected within the window or upstream completed
            </para>
            '''Backpressures when''' a window has been assembled and downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="n"/> or <paramref name="step"/> is less than or equal zero.</exception>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Scan``4(Akka.Streams.Dsl.Flow{``0,``1,``3},``2,System.Func{``2,``1,``2})">
            <summary>
            Similar to <see cref="T:Akka.Streams.Implementation.Fusing.Fold`2"/> but is not a terminal operation,
            emits its current value which starts at <paramref name="zero"/> and then
            applies the current and next value to the given function <paramref name="scan"/>,
            emitting the next current value.
            
            If the function <paramref name="scan"/> throws an exception and the supervision decision is
            <see cref="T:Akka.Dispatch.SysMsg.Restart"/> current value starts at <paramref name="zero"/> again
            the stream will continue.
            <para>
            '''Emits when''' the function scanning the element returns a new element
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Fold``4(Akka.Streams.Dsl.Flow{``0,``1,``3},``2,System.Func{``2,``1,``2})">
            <summary>
            Similar to `scan` but only emits its result when the upstream completes,
            after which it also completes. Applies the given function towards its current and next value,
            yielding the next current value.
            
            If the function `f` throws an exception and the supervision decision is
            [[akka.stream.Supervision.Restart]] current value starts at `zero` again
            the stream will continue.
            <para>
            '''Emits when''' upstream completes
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Reduce``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,``1,``1})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.FlowOperations.Fold``4(Akka.Streams.Dsl.Flow{``0,``1,``3},``2,System.Func{``2,``1,``2})"/> but uses first element as zero element.
            Applies the given function towards its current and next value,
            yielding the next current value. 
            <para>
            '''Emits when''' upstream completes
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Intersperse``3(Akka.Streams.Dsl.Flow{``0,``1,``2},``1,``1,``1)">
            <summary>
            Intersperses stream with provided element, similar to how <see cref="M:System.String.Join(System.String,System.String[])"/>
            injects a separator between a collection's elements.
            
            Additionally can inject start and end marker elements to stream.
            
            In case you want to only prepend or only append an element (yet still use the `intercept` feature
            to inject a separator between elements, you may want to use the following pattern instead of the 3-argument
            version of intersperse (See <see cref="!:Concat&lt;T&gt;"/> for semantics details). 
            <para>
            '''Emits when''' upstream emits (or before with the `start` element if provided)
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <exception cref="T:System.ArgumentNullException">Thrown when any of the <paramref name="start"/>, <paramref name="inject"/> or <paramref name="end"/> is null.</exception>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Intersperse``3(Akka.Streams.Dsl.Flow{``0,``1,``2},``1)">
            <summary>
            Intersperses stream with provided element, similar to how <see cref="M:System.String.Join(System.String,System.String[])"/>
            injects a separator between a collection's elements.
            
            Additionally can inject start and end marker elements to stream.
            
            In case you want to only prepend or only append an element (yet still use the `intercept` feature
            to inject a separator between elements, you may want to use the following pattern instead of the 3-argument
            version of intersperse (See <see cref="!:Concat&lt;T&gt;"/> for semantics details). 
            <para>
            '''Emits when''' upstream emits (or before with the `start` element if provided)
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="inject"/> is null.</exception>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.GroupedWithin``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int32,System.TimeSpan)">
            <summary>
            Chunk up this stream into groups of elements received within a time window,
            or limited by the given number of elements, whatever happens first.
            Empty groups will not be emitted if no elements are received from upstream.
            The last group before end-of-stream will contain the buffered elements
            since the previously emitted group.
            
            <paramref name="n"/> must be positive, and <paramref name="timeout"/> must be greater than 0 seconds, otherwise
            <see cref="T:System.ArgumentException"/> is thrown.
            <para>
            '''Emits when''' the configured time elapses since the last group has been emitted
            </para>
            '''Backpressures when''' the configured time elapses since the last group has been emitted
            <para>
            '''Completes when''' upstream completes (emits last group)
            </para>
            '''Cancels when''' downstream completes
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="n"/> is less than or equal zero or <paramref name="timeout"/> is <see cref="F:System.TimeSpan.Zero"/>.</exception>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Delay``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.TimeSpan,System.Nullable{Akka.Streams.DelayOverflowStrategy})">
            <summary>
            Shifts elements emission in time by a specified amount. It allows to store elements
            in internal buffer while waiting for next element to be emitted. Depending on the defined
            <see cref="T:Akka.Streams.DelayOverflowStrategy"/> it might drop elements or backpressure the upstream if
            there is no space available in the buffer.
            
            Delay precision is 10ms to avoid unnecessary timer scheduling cycles
            
            Internal buffer has default capacity 16. You can set buffer size by calling <see cref="M:Akka.Streams.Attributes.CreateInputBuffer(System.Int32,System.Int32)"/>
            <para>
            '''Emits when''' there is a pending element in the buffer and configured time for this element elapsed
             * EmitEarly - strategy do not wait to emit element if buffer is full
            </para>
            '''Backpressures when''' depending on OverflowStrategy
             * Backpressure - backpressures when buffer is full
             * DropHead, DropTail, DropBuffer - never backpressures
             * Fail - fails the stream if buffer gets full
            <para>
            '''Completes when''' upstream completes and buffered elements has been drained
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <param name="of">Time to shift all messages.</param>
            <param name="strategy">Strategy that is used when incoming elements cannot fit inside the buffer</param>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Drop``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int64)">
            <summary>
            Discard the given number of elements at the beginning of the stream.
            No elements will be dropped if <paramref name="n"/> is zero or negative.
            <para>
            '''Emits when''' the specified number of elements has been dropped already
            </para>
            '''Backpressures when''' the specified number of elements has been dropped and downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.DropWithin``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.TimeSpan)">
            <summary>
            Discard the elements received within the given duration at beginning of the stream.
            <para>
            '''Emits when''' the specified time elapsed and a new upstream element arrives
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Take``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int64)">
            <summary>
            Terminate processing (and cancel the upstream publisher) after the given
            number of elements. Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if <paramref name="n"/> is zero
            or negative.
            <para>
            '''Emits when''' the specified number of elements to take has not yet been reached
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' the defined number of elements has been taken or upstream completes
            </para>
            '''Cancels when''' the defined number of elements has been taken or downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.TakeWithin``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.TimeSpan)">
            <summary>
            Terminate processing (and cancel the upstream publisher) after the given
            duration. Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            Note that this can be combined with <see cref="T:Akka.Streams.Implementation.Stages.Take`1"/> to limit the number of elements
            within the duration.
            <para>
            '''Emits when''' an upstream element arrives
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes or timer fires
            </para>
            '''Cancels when''' downstream cancels or timer fires
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.ConflateWithSeed``4(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,``3},System.Func{``3,``1,``3})">
            <summary>
            Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
            until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
            upstream publisher is faster.
            
            This version of conflate allows to derive a seed from the first element and change the aggregated type to
            be different than the input type. See <see cref="M:Akka.Streams.Dsl.FlowOperations.Conflate``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,``1,``1})"/> for a simpler version that does not change types.
            
            This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
            duplicate elements.
            <para>
            '''Emits when''' downstream stops backpressuring and there is a conflated element available
            </para>
            '''Backpressures when''' never
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <param name="seed">Provides the first state for a conflated value using the first unconsumed element as a start</param> 
            <param name="aggregate">Takes the currently aggregated value and the current pending element to produce a new aggregate</param>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Conflate``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,``1,``1})">
            <summary>
            Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
            until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
            upstream publisher is faster.
            
            This version of conflate does not change the output type of the stream. See <see cref="M:Akka.Streams.Dsl.FlowOperations.ConflateWithSeed``4(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,``3},System.Func{``3,``1,``3})"/>
            for a more flexible version that can take a seed function and transform elements while rolling up.
            
            This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
            duplicate elements.
            <para>
            '''Emits when''' downstream stops backpressuring and there is a conflated element available
            </para>
            '''Backpressures when''' never
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <param name="aggregate">Takes the currently aggregated value and the current pending element to produce a new aggregate</param>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Batch``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Int64,System.Func{``1,``2},System.Func{``2,``1,``2})">
             <summary>
             Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
             until the subscriber is ready to accept them.For example a batch step might store received elements in
             an array up to the allowed max limit if the upstream publisher is faster.
            
             This only rolls up elements if the upstream is faster, but if the downstream is faster it will not
             duplicate elements.
            
             '''Emits when''' downstream stops backpressuring and there is an aggregated element available
            
             '''Backpressures when''' there are `max` batched elements and 1 pending element and downstream backpressures
            
             '''Completes when''' upstream completes and there is no batched/pending element waiting
            
             '''Cancels when''' downstream cancels
            
             See also <seealso cref="M:Akka.Streams.Dsl.FlowOperations.ConflateWithSeed``4(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,``3},System.Func{``3,``1,``3})"/>, <seealso cref="M:Akka.Streams.Dsl.FlowOperations.BatchWeighted``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Int64,System.Func{``1,System.Int64},System.Func{``1,``2},System.Func{``2,``1,``2})"/>
             </summary>
             <param name="max">maximum number of elements to batch before backpressuring upstream (must be positive non-zero)</param>
             <param name="seed">Provides the first state for a batched value using the first unconsumed element as a start</param>
             <param name="aggregate">Takes the currently batched value and the current pending element to produce a new aggregate</param>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.BatchWeighted``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Int64,System.Func{``1,System.Int64},System.Func{``1,``2},System.Func{``2,``1,``2})">
              <summary>
             Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
             until the subscriber is ready to accept them.For example a batch step might concatenate `ByteString`
             elements up to the allowed max limit if the upstream publisher is faster.
            
             This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
             duplicate elements.
            
             Batching will apply for all elements, even if a single element cost is greater than the total allowed limit.
             In this case, previous batched elements will be emitted, then the "heavy" element will be emitted (after
             being applied with the `seed` function) without batching further elements with it, and then the rest of the
             incoming elements are batched.
            
             '''Emits when''' downstream stops backpressuring and there is a batched element available
            
             '''Backpressures when''' there are `max` weighted batched elements + 1 pending element and downstream backpressures
            
             '''Completes when''' upstream completes and there is no batched/pending element waiting
            
             '''Cancels when''' downstream cancels
            
             See also <seealso cref="M:Akka.Streams.Dsl.FlowOperations.ConflateWithSeed``4(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,``3},System.Func{``3,``1,``3})"/>, <seealso cref="M:Akka.Streams.Dsl.FlowOperations.Batch``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Int64,System.Func{``1,``2},System.Func{``2,``1,``2})"/>
             </summary>
             <param name="max">maximum weight of elements to batch before backpressuring upstream (must be positive non-zero)</param>
             <param name="costFunction">a function to compute a single element weight</param>
             <param name="seed">Provides the first state for a batched value using the first unconsumed element as a start</param>
             <param name="aggregate">Takes the currently batched value and the current pending element to produce a new aggregate</param>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Expand``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,System.Collections.Generic.IEnumerator{``2}})">
            <summary>
            Allows a faster downstream to progress independently of a slower publisher by extrapolating elements from an older
            element until new element comes from the upstream. For example an expand step might repeat the last element for
            the subscriber until it receives an update from upstream.
            
            This element will never "drop" upstream elements as all elements go through at least one extrapolation step.
            This means that if the upstream is actually faster than the upstream it will be backpressured by the downstream
            subscriber.
            
            Expand does not support <see cref="T:Akka.Dispatch.SysMsg.Restart"/> and <see cref="!:Directive.Resume"/>.
            Exceptions from the <paramref name="seed"/> or <paramref name="extrapolate"/> functions will complete the stream with failure.
            <para>
            '''Emits when''' downstream stops backpressuring
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <param name="extrapolate">Takes the current extrapolation state to produce an output element and the next extrapolation state.</param>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Buffer``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int32,Akka.Streams.OverflowStrategy)">
            <summary>
            Adds a fixed size buffer in the flow that allows to store elements from a faster upstream until it becomes full.
            Depending on the defined <see cref="T:Akka.Streams.OverflowStrategy"/> it might drop elements or backpressure the upstream if
            there is no space available
            <para>
            '''Emits when''' downstream stops backpressuring and there is a pending element in the buffer
            </para>
            '''Backpressures when''' depending on OverflowStrategy
             * Backpressure - backpressures when buffer is full
             * DropHead, DropTail, DropBuffer - never backpressures
             * Fail - fails the stream if buffer gets full
            <para>
            '''Completes when''' upstream completes and buffered elements has been drained
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <param name="size">The size of the buffer in element count</param>
            <param name="strategy">Strategy that is used when incoming elements cannot fit inside the buffer</param>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Transform``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{Akka.Streams.Stage.IStage{``1,``2}})">
            <summary>
            Generic transformation of a stream with a custom processing <see cref="T:Akka.Streams.Stage.IStage`2"/>.
            This operator makes it possible to extend the <see cref="T:Akka.Streams.Dsl.Flow"/> API when there is no specialized
            operator that performs the transformation.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.PrefixAndTail``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int32)">
            <summary>
            Takes up to <paramref name="n"/> elements from the stream and returns a pair containing a strict sequence of the taken element
            and a stream representing the remaining elements. If <paramref name="n"/> is zero or negative, then this will return a pair
            of an empty collection and a stream containing the whole upstream unchanged.
            <para>
            '''Emits when''' the configured number of prefix elements are available. Emits this prefix, and the rest
            as a substream
            </para>
            '''Backpressures when''' downstream backpressures or substream backpressures
            <para>
            '''Completes when''' prefix elements has been consumed and substream has been consumed
            </para>
            '''Cancels when''' downstream cancels or substream cancels
            </summary> 
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.GroupBy``4(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int32,System.Func{``1,``3})">
            <summary>
            This operation demultiplexes the incoming stream into separate output
            streams, one for each element key. The key is computed for each element
            using the given function. When a new key is encountered for the first time
            it is emitted to the downstream subscriber together with a fresh
            flow that will eventually produce all the elements of the substream
            for that key. Not consuming the elements from the created streams will
            stop this processor from processing more elements, therefore you must take
            care to unblock (or cancel) all of the produced streams even if you want
            to consume only one of them.
            
            If the group by function <paramref name="groupingFunc"/> throws an exception and the supervision decision
            is <see cref="T:Akka.Dispatch.SysMsg.Stop"/> the stream and substreams will be completed
            with failure.
            
            If the group by <paramref name="groupingFunc"/> throws an exception and the supervision decision
            is <see cref="!:Directive.Resume"/> or <see cref="T:Akka.Dispatch.SysMsg.Restart"/>
            the element is dropped and the stream and substreams continue.
            <para>
            '''Emits when''' an element for which the grouping function returns a group that has not yet been created.
            Emits the new group
            </para>
            '''Backpressures when''' there is an element pending for a group whose substream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels and all substreams cancel
            </summary> 
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.SplitWhen``3(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.SubstreamCancelStrategy,System.Func{``1,System.Boolean})">
            <summary>
            This operation applies the given predicate to all incoming elements and
            emits them to a stream of output streams, always beginning a new one with
            the current element if the given predicate returns true for it. This means
            that for the following series of predicate values, three substreams will
            be produced with lengths 1, 2, and 3:
            
            {{{
            false,             // element goes into first substream
            true, false,       // elements go into second substream
            true, false, false // elements go into third substream
            }}}
            
            In case the *first* element of the stream matches the predicate, the first
            substream emitted by splitWhen will start from that element. For example:
            
            {{{
            true, false, false // first substream starts from the split-by element
            true, false        // subsequent substreams operate the same way
            }}}
            
            The object returned from this method is not a normal [[Source]] or [[Flow]],
            it is a [[SubFlow]]. This means that after this combinator all transformations
            are applied to all encountered substreams in the same fashion. Substream mode
            is exited either by closing the substream (i.e. connecting it to a [[Sink]])
            or by merging the substreams back together; see the `to` and `mergeBack` methods
            on [[SubFlow]] for more information.
            
            It is important to note that the substreams also propagate back-pressure as
            any other stream, which means that blocking one substream will block the `splitWhen`
            operator itselfâ€”and thereby all substreamsâ€”once all internal or
            explicit buffers are filled.
            
            If the split <paramref name="predicate"/> throws an exception and the supervision decision
            is <see cref="T:Akka.Dispatch.SysMsg.Stop"/> the stream and substreams will be completed
            with failure.
            
            If the split <paramref name="predicate"/> throws an exception and the supervision decision
            is <see cref="!:Directive.Resume"/> or <see cref="T:Akka.Dispatch.SysMsg.Restart"/>
            the element is dropped and the stream and substreams continue.
            <para>
            '''Emits when''' an element for which the provided predicate is true, opening and emitting
            a new substream for subsequent element
            </para>
            '''Backpressures when''' there is an element pending for the next substream, but the previous
            is not fully consumed yet, or the substream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels and substreams cancel
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.FlowOperations.SplitAfter``3(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.SubstreamCancelStrategy,System.Func{``1,System.Boolean})"/> 
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.SplitWhen``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,System.Boolean})">
            <summary>
            This operation applies the given predicate to all incoming elements and
            emits them to a stream of output streams, always beginning a new one with
            the current element if the given predicate returns true for it.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.SplitAfter``3(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.SubstreamCancelStrategy,System.Func{``1,System.Boolean})">
             <summary>
             This operation applies the given predicate to all incoming elements and
             emits them to a stream of output streams.It* ends* the current substream when the
             predicate is true. This means that for the following series of predicate values,
             three substreams will be produced with lengths 2, 2, and 3:
            
             {{{
             false, true,        // elements go into first substream
             false, true,        // elements go into second substream
             false, false, true  // elements go into third substream
             }}}
            
             The object returned from this method is not a normal[[Source]] or[[Flow]],
             it is a[[SubFlow]]. This means that after this combinator all transformations
            are applied to all encountered substreams in the same fashion.Substream mode
             is exited either by closing the substream(i.e.connecting it to a [[Sink]])
             or by merging the substreams back together; see the `to` and `mergeBack` methods
             on[[SubFlow]] for more information.
            
             It is important to note that the substreams also propagate back-pressure as
             any other stream, which means that blocking one substream will block the `splitAfter`
             operator itselfâ€”and thereby all substreamsâ€”once all internal or
             explicit buffers are filled.
            
             If the split <paramref name="predicate"/> throws an exception and the supervision decision
             is <see cref="T:Akka.Dispatch.SysMsg.Stop"/> the stream and substreams will be completed
             with failure.
            
             If the split <paramref name="predicate"/> throws an exception and the supervision decision
             is <see cref="!:Directive.Resume"/> or <see cref="T:Akka.Dispatch.SysMsg.Restart"/>
             the element is dropped and the stream and substreams continue.
             <para>
             '''Emits when''' an element passes through.When the provided predicate is true it emitts the element
             and opens a new substream for subsequent element
             </para>
             '''Backpressures when''' there is an element pending for the next substream, but the previous
             is not fully consumed yet, or the substream backpressures
             <para>
             '''Completes when''' upstream completes
             </para>
             '''Cancels when''' downstream cancels and substreams cancel
             </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.SplitAfter``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,System.Boolean})">
            <summary>
            This operation applies the given predicate to all incoming elements and
            emits them to a stream of output streams. It *ends* the current substream when the
            predicate is true.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.FlatMapConcat``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,Akka.Streams.IGraph{Akka.Streams.SourceShape{``2},``3}})">
            <summary>
            Transform each input element into a `Source` of output elements that is
            then flattened into the output stream by concatenation,
            fully consuming one Source after the other.
            <para>
            '''Emits when''' a currently consumed substream has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes and all consumed substreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.FlatMapMerge``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Int32,System.Func{``1,Akka.Streams.IGraph{Akka.Streams.SourceShape{``2},``3}})">
            <summary>
            Transform each input element into a `Source` of output elements that is
            then flattened into the output stream by merging, where at most <paramref name="breadth"/>
            substreams are being consumed at any given time.
            <para>
            '''Emits when''' a currently consumed substream has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes and all consumed substreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.InitialTimeout``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.TimeSpan)">
            <summary>
            If the first element has not passed through this stage before the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>.
            <para>
            '''Emits when''' upstream emits an element
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes or fails if timeout elapses before first element arrives
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.CompletionTimeout``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.TimeSpan)">
            <summary>
            If the completion of the stream does not happen until the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>.
            <para>
            '''Emits when''' upstream emits an element
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes or fails if timeout elapses before upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.IdleTimeout``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.TimeSpan)">
            <summary>
            If the time between two processed elements exceed the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>.
            <para>
            '''Emits when''' upstream emits an element
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes or fails if timeout elapses between two emitted elements
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.KeepAlive``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.TimeSpan,System.Func{``2})">
            <summary>
            Injects additional elements if the upstream does not emit for a configured amount of time. In other words, this
            stage attempts to maintains a base rate of emitted elements towards the downstream.
            
            If the downstream backpressures then no element is injected until downstream demand arrives. Injected elements
            do not accumulate during this period.
            
            Upstream elements are always preferred over injected elements.
            <para>
            '''Emits when''' upstream emits an element or if the upstream was idle for the configured period
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Throttle``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int32,System.TimeSpan,System.Int32,Akka.Streams.ThrottleMode)">
            <summary>
            Sends elements downstream with speed limited to `<paramref name="elements"/>/<paramref name="per"/>`. In other words, this stage set the maximum rate
            for emitting messages. This combinator works for streams where all elements have the same cost or length.
            
            Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
            Tokens drops into the bucket at a given rate and can be "spared" for later use up to bucket capacity
            to allow some burstyness. Whenever stream wants to send an element, it takes as many
            tokens from the bucket as number of elements. If there isn't any, throttle waits until the
            bucket accumulates enough tokens.
            
            Parameter <paramref name="mode"/> manages behaviour when upstream is faster than throttle rate:
             - <see cref="F:Akka.Streams.ThrottleMode.Shaping"/> makes pauses before emitting messages to meet throttle rate
             - <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> fails with exception when upstream is faster than throttle rate. Enforcing
             cannot emit elements that cost more than the maximumBurst
            <para>
            '''Emits when''' upstream emits an element and configured time per each element elapsed
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <exception cref="T:System.ArgumentException">Thow when <paramref name="elements"/> is less than or equal zero, 
            or <paramref name="per"/> timeout is equal <see cref="F:System.TimeSpan.Zero"/> 
            or <paramref name="maximumBurst"/> is less than or equal zero in in <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> <paramref name="mode"/>.</exception>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Throttle``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Int32,System.TimeSpan,System.Int32,System.Func{``1,System.Int32},Akka.Streams.ThrottleMode)">
            <summary>
            Sends elements downstream with speed limited to `<paramref name="cost"/>/<paramref name="per"/>`. Cost is
            calculating for each element individually by calling <paramref name="calculateCost"/> function.
            This combinator works for streams when elements have different cost(length).
            Streams of <see cref="T:Akka.IO.ByteString"/> for example.
            
            Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
            Tokens drops into the bucket at a given rate and can be `spared` for later use up to bucket capacity
            to allow some burstyness. Whenever stream wants to send an element, it takes as many
            tokens from the bucket as element cost. If there isn't any, throttle waits until the
            bucket accumulates enough tokens. Elements that costs more than the allowed burst will be delayed proportionally
            to their cost minus available tokens, meeting the target rate.
            
            Parameter <paramref name="mode"/> manages behaviour when upstream is faster than throttle rate:
             - <see cref="F:Akka.Streams.ThrottleMode.Shaping"/> makes pauses before emitting messages to meet throttle rate
             - <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> fails with exception when upstream is faster than throttle rate. Enforcing
             cannot emit elements that cost more than the maximumBurst
            <para>
            '''Emits when''' upstream emits an element and configured time per each element elapsed
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.AlsoToMaterialized``5(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.IGraph{Akka.Streams.SinkShape{``1},``3},System.Func{``2,``3,``4})">
            <summary>
            Attaches the given <seealso cref="T:Akka.Streams.Dsl.Sink`2"/> to this <seealso cref="T:Akka.Streams.Dsl.Flow`3"/>, meaning that elements that passes
            through will also be sent to the <seealso cref="T:Akka.Streams.Dsl.Sink`2"/>.
            
            @see <seealso cref="!:AlsoTo&lt;TOut,TMat&gt;"/>
            
            It is recommended to use the internally optimized <seealso cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <seealso cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
            where appropriate instead of manually writing functions that pass through one of the values.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.AlsoTo``3(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.IGraph{Akka.Streams.SinkShape{``1},``2})">
             <summary>
             Attaches the given <seealso cref="T:Akka.Streams.Dsl.Sink`2"/> to this <seealso cref="T:Akka.Streams.Dsl.Flow`3"/>, meaning that elements that passes
             through will also be sent to the <seealso cref="T:Akka.Streams.Dsl.Sink`2"/>.
             
             '''Emits when''' element is available and demand exists both from the Sink and the downstream.
            
             '''Backpressures when''' downstream or Sink backpressures
            
             '''Completes when''' upstream completes
            
             '''Cancels when''' downstream cancels
             </summary>
             <returns></returns>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.WatchTermination``4(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``2,System.Threading.Tasks.Task,``3})">
            <summary>
            Materializes to `Future[Done]` that completes on getting termination message.
            The Future completes with success when received complete message from upstream or cancel
            from downstream. It fails with the same error when received error message from downstream.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Detach``3(Akka.Streams.Dsl.Flow{``0,``1,``2})">
             <summary>
             Detaches upstream demand from downstream demand without detaching the
             stream rates; in other words acts like a buffer of size 1.
            
             '''Emits when''' upstream emits an element
            
             '''Backpressures when''' downstream backpressures
            
             '''Completes when''' upstream completes
            
             '''Cancels when''' downstream cancels
             </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.InitialDelay``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.TimeSpan)">
            <summary>
            Delays the initial element by the specified duration.
            <para>
            '''Emits when''' upstream emits an element if the initial delay already elapsed
            </para>
            '''Backpressures when''' downstream backpressures or initial delay not yet elapsed
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Log``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.String,System.Func{``1,System.Object},Akka.Event.ILoggingAdapter)">
            <summary>
            Logs elements flowing through the stream as well as completion and erroring.
            
            By default element and completion signals are logged on debug level, and errors are logged on Error level.
            This can be adjusted according to your needs by providing a custom <see cref="T:Akka.Streams.Attributes.LogLevels"/> attribute on the given Flow.
            <para>
            '''Emits when''' the mapping function returns an element
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Zip``4(Akka.Streams.Dsl.Flow{``0,``1,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``2},``3})">
            <summary>
            Combine the elements of current flow and the given [[Source]] into a stream of tuples.
            <para>
            '''Emits when''' all of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' any upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.ZipWith``5(Akka.Streams.Dsl.Flow{``0,``1,``4},Akka.Streams.IGraph{Akka.Streams.SourceShape{``2},``4},System.Func{``1,``2,``3})">
            <summary>
            Put together the elements of current flow and the given [[Source]]
            into a stream of combined elements using a combiner function.
            <para>
            '''Emits when''' all of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' any upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Interleave``4(Akka.Streams.Dsl.Flow{``0,``1,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``2},``3},System.Int32)">
            <summary>
            Interleave is a deterministic merge of the given [[Source]] with elements of this [[Flow]].
            It first emits <paramref name="segmentSize"/> number of elements from this flow to downstream, then - same amount for <paramref name="other"/>
            source, then repeat process.
             
            After one of upstreams is complete than all the rest elements will be emitted from the second one
            
            If it gets error from one of upstreams - stream completes with failure.
            <para>
            '''Emits when''' element is available from the currently consumed upstream
            </para>
            '''Backpressures when''' downstream backpressures. Signal to current
            upstream, switch to next upstream when received `segmentSize` elements
            <para>
            '''Completes when''' the [[Flow]] and given [[Source]] completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <example>
            <code>
            Source(List(1, 2, 3)).Interleave(List(4, 5, 6, 7), 2) // 1, 2, 4, 5, 3, 6, 7
            </code>
            </example>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.InterleaveMaterialized``6(Akka.Streams.Dsl.Flow{``0,``1,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``2},``4},System.Int32,System.Func{``3,``4,``5})">
             <summary>
             Interleave is a deterministic merge of the given <see cref="T:Akka.Streams.Dsl.Source`2"/> with elements of this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>.
             It first emits `segmentSize` number of elements from this flow to downstream, then - same amount for `that` source,
             then repeat process.
            
             After one of upstreams is complete than all the rest elements will be emitted from the second one
            
             If it gets error from one of upstreams - stream completes with failure.
            
             @see<see cref="T:Akka.Streams.Dsl.Interleave`2"/>.
            
            It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
             where appropriate instead of manually writing functions that pass through one of the values.
             </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Merge``4(Akka.Streams.Dsl.Flow{``0,``1,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``2},``3})">
            <summary>
            Merge the given [[Source]] to this [[Flow]], taking elements as they arrive from input streams,
            picking randomly when several elements ready.
            <para>
            '''Emits when''' one of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' all upstreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.MergeMaterialized``6(Akka.Streams.Dsl.Flow{``0,``1,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``2},``4},System.Func{``3,``4,``5},System.Boolean)">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source"/> to this <see cref="T:Akka.Streams.Dsl.Flow"/>, taking elements as they arrive from input streams,
            picking randomly when several elements ready.
            
            @see <see cref="M:Akka.Streams.Dsl.FlowOperations.Merge``4(Akka.Streams.Dsl.Flow{``0,``1,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``2},``3})"/>
            
            It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
            where appropriate instead of manually writing functions that pass through one of the values.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.MergeSorted``3(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2},System.Func{``1,``1,System.Int32})">
            <summary>
            Merge the given [[Source]] to this [[Flow]], taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            '''Emits when''' one of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' all upstreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.MergeSorted``3(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2})">
            <summary>
            Merge the given [[Source]] to this [[Flow]], taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            '''Emits when''' one of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' all upstreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.MergeSorted``3(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2},System.Collections.Generic.IComparer{``1})">
            <summary>
            Merge the given [[Source]] to this [[Flow]], taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            '''Emits when''' one of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' all upstreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Concat``3(Akka.Streams.Dsl.Flow{``0,``1,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2})">
            <summary>
            Concatenate the given [[Source]] to this [[Flow]], meaning that once this
            Flowâ€™s input is exhausted and all result elements have been generated,
            the Sourceâ€™s elements will be produced.
            
            Note that the [[Source]] is materialized together with this Flow and just kept
            from producing elements by asserting back-pressure until its time comes.
            
            If this [[Flow]] gets upstream error - no elements from the given [[Source]] will be pulled.
            <para>
            '''Emits when''' element is available from current stream or from the given [[Source]] when current is completed
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' given [[Source]] completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.FlowOperations.Prepend``4(Akka.Streams.Dsl.Flow{``0,``1,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``2},``3})">
             <summary>
             Prepend the given <seealso cref="T:Akka.Streams.Dsl.Source"/> to this <seealso cref="T:Akka.Streams.Dsl.Flow"/>, meaning that before elements
             are generated from this <seealso cref="T:Akka.Streams.Dsl.Flow"/>, the Source's elements will be produced until it
             is exhausted, at which point Flow elements will start being produced.
            
             Note that this <seealso cref="T:Akka.Streams.Dsl.Flow"/> will be materialized together with the <seealso cref="T:Akka.Streams.Dsl.Source"/> and just kept
             from producing elements by asserting back-pressure until its time comes.
            
             If the given <seealso cref="T:Akka.Streams.Dsl.Source"/> gets upstream error - no elements from this <seealso cref="T:Akka.Streams.Dsl.Flow"/> will be pulled.
            
             '''Emits when''' element is available from the given <seealso cref="T:Akka.Streams.Dsl.Source"/> or from current stream when the <seealso cref="T:Akka.Streams.Dsl.Source"/> is completed
            
             '''Backpressures when''' downstream backpressures
            
             '''Completes when''' this <seealso cref="T:Akka.Streams.Dsl.Flow"/> completes
            
             '''Cancels when''' downstream cancels
             </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Framing.Delimiter(Akka.IO.ByteString,System.Int32,System.Boolean)">
            <summary>
            Creates a Flow that handles decoding a stream of unstructured byte chunks into a stream of frames where the
            incoming chunk stream uses a specific byte-sequence to mark frame boundaries.
            
            The decoded frames will not include the separator sequence.
            
            If there are buffered bytes (an incomplete frame) when the input stream finishes and <paramref name="allowTruncation"/> is set to
            false then this Flow will fail the stream reporting a truncated frame.
            </summary>
            <param name="delimiter">The byte sequence to be treated as the end of the frame.</param>
            <param name="maximumFrameLength">The maximum length of allowed frames while decoding. If the maximum length is exceeded this Flow will fail the stream.</param>
            <param name="allowTruncation">If false, then when the last frame being decoded contains no valid delimiter this Flow fails the stream instead of returning a truncated frame.</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Framing.LengthField(System.Int32,System.Int32,System.Int32,Akka.IO.ByteOrder)">
            <summary>
            Creates a Flow that decodes an incoming stream of unstructured byte chunks into a stream of frames, assuming that
            incoming frames have a field that encodes their length.
            
            If the input stream finishes before the last frame has been fully decoded this Flow will fail the stream reporting
            a truncated frame.
            </summary>
            <param name="fieldLength">The length of the "Count" field in bytes</param>
            <param name="maximumFramelength">The maximum length of allowed frames while decoding. If the maximum length is exceeded this Flow will fail the stream. This length *includes* the header (i.e the offset and the length of the size field)</param>
            <param name="fieldOffset">The offset of the field from the beginning of the frame in bytes</param>
            <param name="byteOrder">The <see cref="T:Akka.IO.ByteOrder"/> to be used when decoding the field</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Framing.SimpleFramingProtocol(System.Int32)">
            <summary>
            Returns a BidiFlow that implements a simple framing protocol. This is a convenience wrapper over <see cref="M:Akka.Streams.Dsl.Framing.LengthField(System.Int32,System.Int32,System.Int32,Akka.IO.ByteOrder)"/>
            and simply attaches a length field header of four bytes (using big endian encoding) to outgoing messages, and decodes
            such messages in the inbound direction. The decoded messages do not contain the header.
            
            This BidiFlow is useful if a simple message framing protocol is needed (for example when TCP is used to send
            individual messages) but no compatibility with existing protocols is necessary.
            
            The encoded frames have the layout
            {{{
                [4 bytes length field, Big Endian][User Payload]
            }}}
            The length field encodes the length of the user payload excluding the header itself.
            </summary>
            <param name="maximumMessageLength">Maximum length of allowed messages. If sent or received messages exceed the configured limit this BidiFlow will fail the stream. The header attached by this BidiFlow are not included in this limit.</param>
            <returns></returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Merge`2">
            <summary>
            Merge several streams, taking elements as they arrive from input streams
            (picking randomly when several have elements ready).
            <para>
            '''Emits when''' one of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' all upstreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.Merge`1">
            <summary>
            Merge several streams, taking elements as they arrive from input streams
            (picking randomly when several have elements ready).
            <para>
            '''Emits when''' one of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' all upstreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.MergePreferred`1">
            <summary>
            Merge several streams, taking elements as they arrive from input streams
            (picking from preferred when several have elements ready).
            
            A <see cref="T:Akka.Streams.Dsl.MergePreferred`1"/> has one `out` port, one `preferred` input port and 0 or more secondary `in` ports.
            <para>
            '''Emits when''' one of the inputs has an element available, preferring
            a specified input if multiple have elements available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' all upstreams complete (eagerComplete=false) or one upstream completes (eagerComplete=true)
            </para>
            '''Cancels when''' downstream cancels
            <para>
            A `Broadcast` has one `in` port and 2 or more `out` ports.
            </para>
            </summary>
        </member>
        <member name="F:Akka.Streams.Dsl.MergePreferred`1.Logic.MaxEmitting">
            <summary>
            This determines the unfairness of the merge:
            - at 1 the preferred will grab 40% of the bandwidth against three equally fast secondaries
            - at 2 the preferred will grab almost all bandwidth against three equally fast secondaries
            (measured with eventLimit=1 in the GraphInterpreter, so may not be accurate)
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.Interleave`2">
            <summary>
            Interleave represents deterministic merge which takes N elements per input stream,
            in-order of inputs, emits them downstream and then cycles/"wraps-around" the inputs.
            <para>
            '''Emits when''' element is available from current input (depending on phase)
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' all upstreams complete (eagerComplete=false) or one upstream completes (eagerComplete=true)
            </para>
            '''Cancels when''' downstream cancels
            </summary> 
        </member>
        <member name="T:Akka.Streams.Dsl.MergeSorted`1">
            <summary>
            Merge two pre-sorted streams such that the resulting stream is sorted.
            <para>
            '''Emits when''' both inputs have an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' all upstreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.Broadcast`1">
            <summary>
            Fan-out the stream to several streams emitting each incoming upstream element to all downstream consumers.
            It will not shut down until the subscriptions for at least two downstream subscribers have been established.
            <para>
            '''Emits when''' all of the outputs stops backpressuring and there is an input element available
            </para>
            '''Backpressures when''' any of the outputs backpressure
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' If eagerCancel is enabled: when any downstream cancels; otherwise: when all downstreams cancel
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.Partition`1">
            <summary>
            Fan-out the stream to several streams. emitting an incoming upstream element to one downstream consumer according
            to the partitioner function applied to the element
            <para>
            '''Emits when''' an element is available from the input and the chosen output has demand
            </para>
            '''Backpressures when''' the currently chosen output back-pressures
            <para>
            '''Completes when''' upstream completes and no output is pending
            </para>
            '''Cancels when''' when all downstreams cancel
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.Balance`1">
            <summary>
            Fan-out the stream to several streams. Each upstream element is emitted to the first available downstream consumer.
            It will not shut down until the subscriptions
            for at least two downstream subscribers have been established.
            
            A <see cref="T:Akka.Streams.Dsl.Balance`1"/> has one <see cref="P:Akka.Streams.Dsl.Balance`1.In"/> port and 2 or more <see cref="M:Akka.Streams.Dsl.Balance`1.Out(System.Int32)"/> ports.
            <para>
            '''Emits when''' any of the outputs stops backpressuring; emits the element to the first available output
            </para>
            '''Backpressures when''' all of the outputs backpressure
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' all downstreams cancel
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.Zip`2">
            <summary>
            Combine the elements of 2 streams into a stream of tuples.
            
            A <see cref="T:Akka.Streams.Dsl.Zip`2"/> has a `left` and a `right` input port and one `out` port
            <para>
            '''Emits when''' all of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' any upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.UnZip`2">
            <summary>
            Takes a stream of pair elements and splits each pair to two output streams.
            
            An <see cref="T:Akka.Streams.Dsl.UnZip`2"/> has one `in` port and one `left` and one `right` output port.
            <para>
            '''Emits when''' all of the outputs stops backpressuring and there is an input element available
            </para>
            '''Backpressures when''' any of the outputs backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' any downstream cancels
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.Concat`2">
            <summary>
            Takes two streams and outputs one stream formed from the two input streams
            by first emitting all of the elements from the first stream and then emitting
            all of the elements from the second stream.
            
            A <see cref="T:Akka.Streams.Dsl.Concat`2"/> has one `first` port, one `second` port and one `out` port.
            <para>
            '''Emits when''' the current stream has an element available; if the current input completes, it tries the next one
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' all upstreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Recover``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{System.Exception,Akka.Streams.Util.Option{``0}})">
            <summary>
            Recover allows to send last element on failure and gracefully complete the stream
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            <para>
            '''Emits when''' element is available from the upstream or upstream is failed and pf returns an element
            </para>
            <para>
            '''Backpressures when''' downstream backpressures
            </para>
            <para>
            '''Completes when''' upstream completes or upstream failed with exception pf can handle
            </para>
            '''Cancels when''' downstream cancels 
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.RecoverWith``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{System.Exception,Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1}})">
            <summary>
            RecoverWith allows to switch to alternative Source on flow failure. It will stay in effect after
            a failure has been recovered so that each time there is a failure it is fed into the <paramref name="partialFunc"/> and a new
            Source may be materialized.
            <para>
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            </para>
            <para>
            '''Emits when''' element is available from the upstream or upstream is failed and element is available from alternative Source
            </para>
            <para>
            '''Backpressures when''' downstream backpressures
            </para>
            <para>
            '''Completes when''' upstream completes or upstream failed with exception pf can handle
            </para>
            '''Cancels when''' downstream cancels 
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Map``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Func{``0,``1})">
            <summary>
            Transform this stream by applying the given function to each of the elements
            as they pass through this processing step.
            <para>
            '''Emits when''' the mapping function returns an element
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            <para>
            '''Cancels when''' downstream cancels
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.MapConcat``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Transform each input element into a sequence of output elements that is
            then flattened into the output stream.
            
            The returned sequence MUST NOT contain `null` values,
            as they are illegal as stream elements - according to the Reactive Streams specification.
            <para>
            '''Emits when''' the mapping function returns an element or there are still remaining elements
            from the previously calculated collection
            </para>
            <para>
            '''Backpressures when''' downstream backpressures or there are still remaining elements from the
            previously calculated collection
            </para>
            <para>
            '''Completes when''' upstream completes and all remaining elements has been emitted
            </para>
            <para>
            '''Cancels when''' downstream cancels
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.StatefulMapConcat``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Func{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})">
            <summary>
            Transform each input element into an `Iterable` of output elements that is
            then flattened into the output stream. The transformation is meant to be stateful,
            which is enabled by creating the transformation function anew for every materialization â€”
            the returned function will typically close over mutable objects to store state between
            invocations. For the stateless variant see <see cref="M:Akka.Streams.Dsl.FlowOperations.MapConcat``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,System.Collections.Generic.IEnumerable{``2}})"/>.
            
            The returned `Iterable` MUST NOT contain `null` values,
            as they are illegal as stream elements - according to the Reactive Streams specification.
            
            <para>
            '''Emits when''' the mapping function returns an element or there are still remaining elements
            from the previously calculated collection
            </para>
            <para>
            '''Backpressures when''' downstream backpressures or there are still remaining elements from the
            previously calculated collection
            </para>
            <para>
            '''Completes when''' upstream completes and all remaining elements has been emitted
            </para>
            <para>
            '''Cancels when''' downstream cancels
            </para>
            See also <see cref="M:Akka.Streams.Dsl.FlowOperations.MapConcat``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,System.Collections.Generic.IEnumerable{``2}})"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.MapAsync``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Transform this stream by applying the given function to each of the elements
            as they pass through this processing step. The function returns a `Future` and the
            value of that future will be emitted downstream. The number of Futures
            that shall run in parallel is given as the first argument to ``mapAsync``.
            These Futures may complete in any order, but the elements that
            are emitted downstream are in the same order as received from upstream.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/>
            the stream will be completed with failure.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> the element is dropped and the stream continues.
            <para>
            '''Emits when''' the Task returned by the provided function finishes for the next element in sequence
            </para>
            <para>
            '''Backpressures when''' the number of futures reaches the configured parallelism and the downstream
            backpressures or the first future is not completed
            </para>
            <para>
            '''Completes when''' upstream completes and all futures has been completed and all elements has been emitted
            </para>
            <para>
            '''Cancels when''' downstream cancels
            </para>
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.MapAsyncUnordered``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})"/>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.MapAsyncUnordered``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Transform this stream by applying the given function to each of the elements
            as they pass through this processing step. The function returns a <see cref="T:System.Threading.Tasks.Task"/> and the
            value of that future will be emitted downstreams. As many futures as requested elements by
            downstream may run in parallel and each processed element will be emitted dowstream
            as soon as it is ready, i.e. it is possible that the elements are not emitted downstream
            in the same order as received from upstream.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="T:Akka.Dispatch.SysMsg.Stop"/>
            the stream will be completed with failure.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the<see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or
            <see cref="T:Akka.Dispatch.SysMsg.Restart"/> the element is dropped and the stream continues.
            <para>
            '''Emits when''' any of the Futures returned by the provided function complete
            </para>
            <para>
            '''Backpressures when''' the number of futures reaches the configured parallelism and the downstream backpressures
            </para>
            <para>
            '''Completes when''' upstream completes and all futures has been completed and all elements has been emitted
            </para>
            <para>
            '''Cancels when''' downstream cancels
            </para>
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.MapAsync``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})"/>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Filter``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Predicate{``0})">
            <summary>
            Only pass on those elements that satisfy the given predicate.
            <para>
            '''Emits when''' the given predicate returns true for the element
            </para>
            <para>
            '''Backpressures when''' the given predicate returns true for the element and downstream backpressures
            </para>
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.FilterNot``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Predicate{``0})">
            <summary>
            Only pass on those elements that NOT satisfy the given predicate.
            <para>
            '''Emits when''' the given predicate returns true for the element
            </para>
            <para>
            '''Backpressures when''' the given predicate returns true for the element and downstream backpressures
            </para>
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.TakeWhile``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Predicate{``0})">
            <summary>
            Terminate processing (and cancel the upstream publisher) after predicate
            returns false for the first time. Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if predicate is false for
            the first stream element.
            <para>
            '''Emits when''' the predicate is true
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' predicate returned false or upstream completes
            </para>
            '''Cancels when''' predicate returned false or downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.DropWhile``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Predicate{``0})">
            <summary>
            Discard elements at the beginning of the stream while predicate is true.
            All elements will be taken after predicate returns false first time.
            <para>
            '''Emits when''' predicate returned false and for all following stream elements
            </para>
            '''Backpressures when''' predicate returned false and downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Collect``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Func{``0,``1})">
            <summary>
            Transform this stream by applying the given partial function to each of the elements
            on which the function is defined (read: returns not null) as they pass through this processing step.
            Non-matching elements are filtered out.
            <para>
            '''Emits when''' the provided partial function is defined for the element
            </para>
            '''Backpressures when''' the partial function is defined for the element and downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Grouped``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int32)">
            <summary>
            Chunk up this stream into groups of the given size, with the last group
            possibly smaller than requested due to end-of-stream.
            <paramref name="n"/> must be positive, otherwise <see cref="T:System.ArgumentException"/> is thrown.
            <para>
            '''Emits when''' the specified number of elements has been accumulated or upstream completed
            </para>
            '''Backpressures when''' a group has been assembled and downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <exception cref="T:System.ArgumentException">Thrown, if <paramref name="n"/> is less than or equal zero.</exception>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Limit``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int64)">
            <summary>
            Ensure stream boundedness by limiting the number of elements from upstream.
            If the number of incoming elements exceeds max, it will signal
            upstream failure <see cref="!:StreamLimitException"/> downstream.
            
            Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if `n` is zero
            or negative.
            <para>
            '''Emits when''' the specified number of elements to take has not yet been reached
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' the defined number of elements has been taken or upstream completes
            </para>
            '''Cancels when''' the defined number of elements has been taken or downstream cancels
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Take``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int64)"/>
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.TakeWithin``2(Akka.Streams.Dsl.IFlow{``0,``1},System.TimeSpan)"/>
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.TakeWhile``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Predicate{``0})"/>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.LimitWeighted``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int64,System.Func{``0,System.Int64})">
            <summary>
            Ensure stream boundedness by evaluating the cost of incoming elements
            using a cost function. Exactly how many elements will be allowed to travel downstream depends on the
            evaluated cost of each element. If the accumulated cost exceeds max, it will signal
            upstream failure <see cref="!:StreamLimitException"/> downstream.
            
            Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if `n` is zero
            or negative.
            <para>
            '''Emits when''' the specified number of elements to take has not yet been reached
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' the defined number of elements has been taken or upstream completes
            </para>
            '''Cancels when''' the defined number of elements has been taken or downstream cancels
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Take``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int64)"/>
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.TakeWithin``2(Akka.Streams.Dsl.IFlow{``0,``1},System.TimeSpan)"/>
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.TakeWhile``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Predicate{``0})"/>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Sliding``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int32,System.Int32)">
            <summary>
            Apply a sliding window over the stream and return the windows as groups of elements, with the last group
            possibly smaller than requested due to end-of-stream.
            
            <paramref name="n"/> must be positive, otherwise IllegalArgumentException is thrown.
            <paramref name="step"/> must be positive, otherwise IllegalArgumentException is thrown.
            <para>
            '''Emits when''' enough elements have been collected within the window or upstream completed
            </para>
            '''Backpressures when''' a window has been assembled and downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="n"/> or <paramref name="step"/> is less than or equal zero.</exception>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Scan``3(Akka.Streams.Dsl.IFlow{``0,``2},``1,System.Func{``1,``0,``1})">
            <summary>
            Similar to <see cref="T:Akka.Streams.Implementation.Stages.Fold`2"/> but is not a terminal operation,
            emits its current value which starts at <paramref name="zero"/> and then
            applies the current and next value to the given function <paramref name="scan"/>,
            emitting the next current value.
            
            If the function <paramref name="scan"/> throws an exception and the supervision decision is
            <see cref="T:Akka.Dispatch.SysMsg.Restart"/> current value starts at <paramref name="zero"/> again
            the stream will continue.
            <para>
            '''Emits when''' the function scanning the element returns a new element
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Fold``3(Akka.Streams.Dsl.IFlow{``0,``2},``1,System.Func{``1,``0,``1})">
            <summary>
            Similar to `scan` but only emits its result when the upstream completes,
            after which it also completes. Applies the given function towards its current and next value,
            yielding the next current value.
            
            If the function `f` throws an exception and the supervision decision is
            [[akka.stream.Supervision.Restart]] current value starts at `zero` again
            the stream will continue.
            <para>
            '''Emits when''' upstream completes
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Reduce``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{``0,``0,``0})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Fold``3(Akka.Streams.Dsl.IFlow{``0,``2},``1,System.Func{``1,``0,``1})"/> but uses first element as zero element.
            Applies the given function towards its current and next value,
            yielding the next current value. 
            <para>
            '''Emits when''' upstream completes
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Intersperse``2(Akka.Streams.Dsl.IFlow{``0,``1},``0,``0,``0)">
            <summary>
            Intersperses stream with provided element, similar to how <see cref="M:System.String.Join(System.String,System.String[])"/>
            injects a separator between a collection's elements.
            
            Additionally can inject start and end marker elements to stream.
            
            In case you want to only prepend or only append an element (yet still use the `intercept` feature
            to inject a separator between elements, you may want to use the following pattern instead of the 3-argument
            version of intersperse (See <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Concat``2(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})"/> for semantics details). 
            <para>
            '''Emits when''' upstream emits (or before with the `start` element if provided)
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <exception cref="T:System.ArgumentNullException">Thrown when any of the <paramref name="start"/>, <paramref name="inject"/> or <paramref name="end"/> is null.</exception>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Intersperse``2(Akka.Streams.Dsl.IFlow{``0,``1},``0)">
            <summary>
            Intersperses stream with provided element, similar to how <see cref="M:System.String.Join(System.String,System.String[])"/>
            injects a separator between a collection's elements.
            
            Additionally can inject start and end marker elements to stream.
            
            In case you want to only prepend or only append an element (yet still use the `intercept` feature
            to inject a separator between elements, you may want to use the following pattern instead of the 3-argument
            version of intersperse (See <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Concat``2(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})"/> for semantics details). 
            <para>
            '''Emits when''' upstream emits (or before with the `start` element if provided)
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="inject"/> is null.</exception>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.GroupedWithin``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int32,System.TimeSpan)">
            <summary>
            Chunk up this stream into groups of elements received within a time window,
            or limited by the given number of elements, whatever happens first.
            Empty groups will not be emitted if no elements are received from upstream.
            The last group before end-of-stream will contain the buffered elements
            since the previously emitted group.
            
            <paramref name="n"/> must be positive, and <paramref name="timeout"/> must be greater than 0 seconds, otherwise
            <see cref="T:System.ArgumentException"/> is thrown.
            <para>
            '''Emits when''' the configured time elapses since the last group has been emitted
            </para>
            '''Backpressures when''' the configured time elapses since the last group has been emitted
            <para>
            '''Completes when''' upstream completes (emits last group)
            </para>
            '''Cancels when''' downstream completes
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="n"/> is less than or equal zero or <paramref name="timeout"/> is <see cref="F:System.TimeSpan.Zero"/>.</exception>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Delay``2(Akka.Streams.Dsl.IFlow{``0,``1},System.TimeSpan,System.Nullable{Akka.Streams.DelayOverflowStrategy})">
            <summary>
            Shifts elements emission in time by a specified amount. It allows to store elements
            in internal buffer while waiting for next element to be emitted. Depending on the defined
            <see cref="T:Akka.Streams.DelayOverflowStrategy"/> it might drop elements or backpressure the upstream if
            there is no space available in the buffer.
            
            Delay precision is 10ms to avoid unnecessary timer scheduling cycles
            
            Internal buffer has default capacity 16. You can set buffer size by calling <see cref="M:Akka.Streams.Attributes.CreateInputBuffer(System.Int32,System.Int32)"/>
            <para>
            '''Emits when''' there is a pending element in the buffer and configured time for this element elapsed
             * EmitEarly - strategy do not wait to emit element if buffer is full
            </para>
            '''Backpressures when''' depending on OverflowStrategy
             * Backpressure - backpressures when buffer is full
             * DropHead, DropTail, DropBuffer - never backpressures
             * Fail - fails the stream if buffer gets full
            <para>
            '''Completes when''' upstream completes and buffered elements has been drained
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <param name="of">Time to shift all messages.</param>
            <param name="strategy">Strategy that is used when incoming elements cannot fit inside the buffer</param>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Drop``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int64)">
            <summary>
            Discard the given number of elements at the beginning of the stream.
            No elements will be dropped if <paramref name="n"/> is zero or negative.
            <para>
            '''Emits when''' the specified number of elements has been dropped already
            </para>
            '''Backpressures when''' the specified number of elements has been dropped and downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.DropWithin``2(Akka.Streams.Dsl.IFlow{``0,``1},System.TimeSpan)">
            <summary>
            Discard the elements received within the given duration at beginning of the stream.
            <para>
            '''Emits when''' the specified time elapsed and a new upstream element arrives
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Take``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int64)">
            <summary>
            Terminate processing (and cancel the upstream publisher) after the given
            number of elements. Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if <paramref name="n"/> is zero
            or negative.
            <para>
            '''Emits when''' the specified number of elements to take has not yet been reached
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' the defined number of elements has been taken or upstream completes
            </para>
            '''Cancels when''' the defined number of elements has been taken or downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.TakeWithin``2(Akka.Streams.Dsl.IFlow{``0,``1},System.TimeSpan)">
            <summary>
            Terminate processing (and cancel the upstream publisher) after the given
            duration. Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            Note that this can be combined with <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Take``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int64)"/> to limit the number of elements
            within the duration.
            <para>
            '''Emits when''' an upstream element arrives
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes or timer fires
            </para>
            '''Cancels when''' downstream cancels or timer fires
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.ConflateWithSeed``3(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{``0,``2},System.Func{``2,``0,``2})">
            <summary>
            Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
            until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
            upstream publisher is faster.
            
            This version of conflate allows to derive a seed from the first element and change the aggregated type to
            be different than the input type. See <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Conflate``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{``0,``0,``0})"/> for a simpler version that does not change types.
            
            This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
            duplicate elements.
            <para>
            '''Emits when''' downstream stops backpressuring and there is a conflated element available
            </para>
            '''Backpressures when''' never
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <param name="seed">Provides the first state for a conflated value using the first unconsumed element as a start</param> 
            <param name="aggregate">Takes the currently aggregated value and the current pending element to produce a new aggregate</param>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Conflate``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{``0,``0,``0})">
            <summary>
            Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
            until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
            upstream publisher is faster.
            
            This version of conflate does not change the output type of the stream. See <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.ConflateWithSeed``3(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{``0,``2},System.Func{``2,``0,``2})"/>
            for a more flexible version that can take a seed function and transform elements while rolling up.
            
            This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
            duplicate elements.
            <para>
            '''Emits when''' downstream stops backpressuring and there is a conflated element available
            </para>
            '''Backpressures when''' never
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <param name="aggregate">Takes the currently aggregated value and the current pending element to produce a new aggregate</param>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Batch``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Int64,System.Func{``0,``1},System.Func{``1,``0,``1})">
             <summary>
             Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
             until the subscriber is ready to accept them.For example a batch step might store received elements in
             an array up to the allowed max limit if the upstream publisher is faster.
            
             This only rolls up elements if the upstream is faster, but if the downstream is faster it will not
             duplicate elements.
            
             '''Emits when''' downstream stops backpressuring and there is an aggregated element available
            
             '''Backpressures when''' there are `max` batched elements and 1 pending element and downstream backpressures
            
             '''Completes when''' upstream completes and there is no batched/pending element waiting
            
             '''Cancels when''' downstream cancels
            
             See also <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.ConflateWithSeed``3(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{``0,``2},System.Func{``2,``0,``2})"/>, <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.BatchWeighted``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Int64,System.Func{``0,System.Int64},System.Func{``0,``1},System.Func{``1,``0,``1})"/>
             </summary>
             <param name="max">maximum number of elements to batch before backpressuring upstream (must be positive non-zero)</param>
             <param name="seed">Provides the first state for a batched value using the first unconsumed element as a start</param>
             <param name="aggregate">Takes the currently batched value and the current pending element to produce a new aggregate</param>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.BatchWeighted``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Int64,System.Func{``0,System.Int64},System.Func{``0,``1},System.Func{``1,``0,``1})">
              <summary>
             Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
             until the subscriber is ready to accept them.For example a batch step might concatenate `ByteString`
             elements up to the allowed max limit if the upstream publisher is faster.
            
             This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
             duplicate elements.
            
             Batching will apply for all elements, even if a single element cost is greater than the total allowed limit.
             In this case, previous batched elements will be emitted, then the "heavy" element will be emitted (after
             being applied with the `seed` function) without batching further elements with it, and then the rest of the
             incoming elements are batched.
            
             '''Emits when''' downstream stops backpressuring and there is a batched element available
            
             '''Backpressures when''' there are `max` weighted batched elements + 1 pending element and downstream backpressures
            
             '''Completes when''' upstream completes and there is no batched/pending element waiting
            
             '''Cancels when''' downstream cancels
            
             See also <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.ConflateWithSeed``3(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{``0,``2},System.Func{``2,``0,``2})"/>, <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Batch``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Int64,System.Func{``0,``1},System.Func{``1,``0,``1})"/>
             </summary>
             <param name="max">maximum weight of elements to batch before backpressuring upstream (must be positive non-zero)</param>
             <param name="costFunction">a function to compute a single element weight</param>
             <param name="seed">Provides the first state for a batched value using the first unconsumed element as a start</param>
             <param name="aggregate">Takes the currently batched value and the current pending element to produce a new aggregate</param>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Expand``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Func{``0,System.Collections.Generic.IEnumerator{``1}})">
            <summary>
            Allows a faster downstream to progress independently of a slower publisher by extrapolating elements from an older
            element until new element comes from the upstream. For example an expand step might repeat the last element for
            the subscriber until it receives an update from upstream.
            
            This element will never "drop" upstream elements as all elements go through at least one extrapolation step.
            This means that if the upstream is actually faster than the upstream it will be backpressured by the downstream
            subscriber.
            
            Expand does not support <see cref="T:Akka.Dispatch.SysMsg.Restart"/> and <see cref="F:Akka.Streams.Supervision.Directive.Resume"/>.
            Exceptions from the <paramref name="seed"/> or <paramref name="extrapolate"/> functions will complete the stream with failure.
            <para>
            '''Emits when''' downstream stops backpressuring
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <param name="extrapolate">Takes the current extrapolation state to produce an output element and the next extrapolation state.</param>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Buffer``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int32,Akka.Streams.OverflowStrategy)">
            <summary>
            Adds a fixed size buffer in the flow that allows to store elements from a faster upstream until it becomes full.
            Depending on the defined <see cref="T:Akka.Streams.OverflowStrategy"/> it might drop elements or backpressure the upstream if
            there is no space available
            <para>
            '''Emits when''' downstream stops backpressuring and there is a pending element in the buffer
            </para>
            '''Backpressures when''' depending on OverflowStrategy
             * Backpressure - backpressures when buffer is full
             * DropHead, DropTail, DropBuffer - never backpressures
             * Fail - fails the stream if buffer gets full
            <para>
            '''Completes when''' upstream completes and buffered elements has been drained
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <param name="size">The size of the buffer in element count</param>
            <param name="strategy">Strategy that is used when incoming elements cannot fit inside the buffer</param>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Transform``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Func{Akka.Streams.Stage.IStage{``0,``1}})">
            <summary>
            Generic transformation of a stream with a custom processing <see cref="T:Akka.Streams.Stage.IStage`2"/>.
            This operator makes it possible to extend the <see cref="T:Akka.Streams.Dsl.Flow"/> API when there is no specialized
            operator that performs the transformation.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.PrefixAndTail``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int32)">
            <summary>
            Takes up to <paramref name="n"/> elements from the stream and returns a pair containing a strict sequence of the taken element
            and a stream representing the remaining elements. If <paramref name="n"/> is zero or negative, then this will return a pair
            of an empty collection and a stream containing the whole upstream unchanged.
            <para>
            '''Emits when''' the configured number of prefix elements are available. Emits this prefix, and the rest
            as a substream
            </para>
            '''Backpressures when''' downstream backpressures or substream backpressures
            <para>
            '''Completes when''' prefix elements has been consumed and substream has been consumed
            </para>
            '''Cancels when''' downstream cancels or substream cancels
            </summary> 
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.GroupBy``4(Akka.Streams.Dsl.IFlow{``0,``1},System.Int32,System.Func{``0,``2},System.Func{Akka.Streams.Dsl.IFlow{Akka.Streams.Dsl.Source{``0,System.Reactive.Streams.Unit},``1},Akka.Streams.Dsl.Sink{Akka.Streams.Dsl.Source{``0,System.Reactive.Streams.Unit},System.Threading.Tasks.Task},``3},System.Func{Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.Implementation.Stages.StageModule{``0,Akka.Streams.Dsl.Source{``0,System.Reactive.Streams.Unit}},Akka.Streams.Dsl.IFlow{Akka.Streams.Dsl.Source{``0,System.Reactive.Streams.Unit},``1}})">
            <summary>
            This operation demultiplexes the incoming stream into separate output
            streams, one for each element key. The key is computed for each element
            using the given function. When a new key is encountered for the first time
            it is emitted to the downstream subscriber together with a fresh
            flow that will eventually produce all the elements of the substream
            for that key. Not consuming the elements from the created streams will
            stop this processor from processing more elements, therefore you must take
            care to unblock (or cancel) all of the produced streams even if you want
            to consume only one of them.
            
            If the group by function <paramref name="groupingFunc"/> throws an exception and the supervision decision
            is <see cref="T:Akka.Dispatch.SysMsg.Stop"/> the stream and substreams will be completed
            with failure.
            
            If the group by <paramref name="groupingFunc"/> throws an exception and the supervision decision
            is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or <see cref="T:Akka.Dispatch.SysMsg.Restart"/>
            the element is dropped and the stream and substreams continue.
            <para>
            '''Emits when''' an element for which the grouping function returns a group that has not yet been created.
            Emits the new group
            </para>
            '''Backpressures when''' there is an element pending for a group whose substream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels and all substreams cancel
            </summary> 
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SplitWhen``3(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.SubstreamCancelStrategy,System.Func{``0,System.Boolean},System.Func{Akka.Streams.Dsl.IFlow{Akka.Streams.Dsl.Source{``0,System.Reactive.Streams.Unit},``1},Akka.Streams.Dsl.Sink{Akka.Streams.Dsl.Source{``0,System.Reactive.Streams.Unit},System.Threading.Tasks.Task},``2})">
            <summary>
            This operation applies the given predicate to all incoming elements and
            emits them to a stream of output streams, always beginning a new one with
            the current element if the given predicate returns true for it. This means
            that for the following series of predicate values, three substreams will
            be produced with lengths 1, 2, and 3:
            
            {{{
            false,             // element goes into first substream
            true, false,       // elements go into second substream
            true, false, false // elements go into third substream
            }}}
            
            In case the * first * element of the stream matches the predicate, the first
            substream emitted by splitWhen will start from that element. For example:
            
            {{{
            true, false, false // first substream starts from the split-by element
            true, false        // subsequent substreams operate the same way
            }}}
            
            The object returned from this method is not a normal [[Source]] or [[Flow]],
            it is a [[SubFlow]]. This means that after this combinator all transformations
            are applied to all encountered substreams in the same fashion. Substream mode
            is exited either by closing the substream (i.e. connecting it to a [[Sink]])
            or by merging the substreams back together; see the `to` and `mergeBack` methods
            on [[SubFlow]] for more information.
            
            It is important to note that the substreams also propagate back-pressure as
            any other stream, which means that blocking one substream will block the `splitWhen`
            operator itselfâ€”and thereby all substreamsâ€”once all internal or
            explicit buffers are filled.
            
            If the split <paramref name="predicate"/> throws an exception and the supervision decision
            is <see cref="T:Akka.Dispatch.SysMsg.Stop"/> the stream and substreams will be completed
            with failure.
            
            If the split <paramref name="predicate"/> throws an exception and the supervision decision
            is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or <see cref="T:Akka.Dispatch.SysMsg.Restart"/>
            the element is dropped and the stream and substreams continue.
            <para>
            '''Emits when''' an element for which the provided predicate is true, opening and emitting
            a new substream for subsequent element
            </para>
            '''Backpressures when''' there is an element pending for the next substream, but the previous
            is not fully consumed yet, or the substream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels and substreams cancel
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SplitAfter``3(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.SubstreamCancelStrategy,System.Func{``0,System.Boolean},System.Func{Akka.Streams.Dsl.IFlow{Akka.Streams.Dsl.Source{``0,System.Reactive.Streams.Unit},``1},Akka.Streams.Dsl.Sink{Akka.Streams.Dsl.Source{``0,System.Reactive.Streams.Unit},System.Threading.Tasks.Task},``2})"/> 
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SplitAfter``3(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.SubstreamCancelStrategy,System.Func{``0,System.Boolean},System.Func{Akka.Streams.Dsl.IFlow{Akka.Streams.Dsl.Source{``0,System.Reactive.Streams.Unit},``1},Akka.Streams.Dsl.Sink{Akka.Streams.Dsl.Source{``0,System.Reactive.Streams.Unit},System.Threading.Tasks.Task},``2})">
             <summary>
             This operation applies the given predicate to all incoming elements and
             emits them to a stream of output streams.It * ends * the current substream when the
             predicate is true. This means that for the following series of predicate values,
             three substreams will be produced with lengths 2, 2, and 3:
            
             {{{
             false, true,        // elements go into first substream
             false, true,        // elements go into second substream
             false, false, true  // elements go into third substream
             }}}
            
             The object returned from this method is not a normal[[Source]] or[[Flow]],
             it is a[[SubFlow]]. This means that after this combinator all transformations
            are applied to all encountered substreams in the same fashion.Substream mode
             is exited either by closing the substream(i.e.connecting it to a [[Sink]])
             or by merging the substreams back together; see the `to` and `mergeBack` methods
             on[[SubFlow]] for more information.
            
             It is important to note that the substreams also propagate back-pressure as
             any other stream, which means that blocking one substream will block the `splitAfter`
             operator itselfâ€”and thereby all substreamsâ€”once all internal or
             explicit buffers are filled.
            
             If the split <paramref name="predicate"/> throws an exception and the supervision decision
             is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/> the stream and substreams will be completed
             with failure.
            
             If the split <paramref name="predicate"/> throws an exception and the supervision decision
             is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or <see cref="F:Akka.Streams.Supervision.Directive.Restart"/>
             the element is dropped and the stream and substreams continue.
             <para>
             '''Emits when''' an element passes through.When the provided predicate is true it emitts the element
             and opens a new substream for subsequent element
             </para>
             '''Backpressures when''' there is an element pending for the next substream, but the previous
             is not fully consumed yet, or the substream backpressures
             <para>
             '''Completes when''' upstream completes
             </para>
             '''Cancels when''' downstream cancels and substreams cancel
             </summary>
             <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.SplitWhen``3(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.SubstreamCancelStrategy,System.Func{``0,System.Boolean},System.Func{Akka.Streams.Dsl.IFlow{Akka.Streams.Dsl.Source{``0,System.Reactive.Streams.Unit},``1},Akka.Streams.Dsl.Sink{Akka.Streams.Dsl.Source{``0,System.Reactive.Streams.Unit},System.Threading.Tasks.Task},``2})"/> 
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.FlatMapConcat``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Func{``0,Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2}})">
            <summary>
            Transform each input element into a `Source` of output elements that is
            then flattened into the output stream by concatenation,
            fully consuming one Source after the other.
            <para>
            '''Emits when''' a currently consumed substream has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes and all consumed substreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.FlatMapMerge``3(Akka.Streams.Dsl.IFlow{``0,``2},System.Int32,System.Func{``0,Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2}})">
            <summary>
            Transform each input element into a `Source` of output elements that is
            then flattened into the output stream by merging, where at most <paramref name="breadth"/>
            substreams are being consumed at any given time.
            <para>
            '''Emits when''' a currently consumed substream has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes and all consumed substreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.InitialTimeout``2(Akka.Streams.Dsl.IFlow{``0,``1},System.TimeSpan)">
            <summary>
            If the first element has not passed through this stage before the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>.
            <para>
            '''Emits when''' upstream emits an element
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes or fails if timeout elapses before first element arrives
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.CompletionTimeout``2(Akka.Streams.Dsl.IFlow{``0,``1},System.TimeSpan)">
            <summary>
            If the completion of the stream does not happen until the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>.
            <para>
            '''Emits when''' upstream emits an element
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes or fails if timeout elapses before upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.IdleTimeout``2(Akka.Streams.Dsl.IFlow{``0,``1},System.TimeSpan)">
            <summary>
            If the time between two processed elements exceed the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>.
            <para>
            '''Emits when''' upstream emits an element
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes or fails if timeout elapses between two emitted elements
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.KeepAlive``3(Akka.Streams.Dsl.IFlow{``0,``2},System.TimeSpan,System.Func{``1})">
            <summary>
            Injects additional elements if the upstream does not emit for a configured amount of time. In other words, this
            stage attempts to maintains a base rate of emitted elements towards the downstream.
            
            If the downstream backpressures then no element is injected until downstream demand arrives. Injected elements
            do not accumulate during this period.
            
            Upstream elements are always preferred over injected elements.
            <para>
            '''Emits when''' upstream emits an element or if the upstream was idle for the configured period
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Throttle``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int32,System.TimeSpan,System.Int32,Akka.Streams.ThrottleMode)">
            <summary>
            Sends elements downstream with speed limited to `<paramref name="elements"/>/<paramref name="per"/>`. In other words, this stage set the maximum rate
            for emitting messages. This combinator works for streams where all elements have the same cost or length.
            
            Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
            Tokens drops into the bucket at a given rate and can be "spared" for later use up to bucket capacity
            to allow some burstyness. Whenever stream wants to send an element, it takes as many
            tokens from the bucket as number of elements. If there isn't any, throttle waits until the
            bucket accumulates enough tokens.
            
            Parameter <paramref name="mode"/> manages behaviour when upstream is faster than throttle rate:
             - <see cref="F:Akka.Streams.ThrottleMode.Shaping"/> makes pauses before emitting messages to meet throttle rate
             - <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> fails with exception when upstream is faster than throttle rate. Enforcing
             cannot emit elements that cost more than the maximumBurst
            <para>
            '''Emits when''' upstream emits an element and configured time per each element elapsed
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <exception cref="T:System.ArgumentException">Thow when <paramref name="elements"/> is less than or equal zero, 
            or <paramref name="per"/> timeout is equal <see cref="F:System.TimeSpan.Zero"/> 
            or <paramref name="maximumBurst"/> is less than or equal zero in in <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> <paramref name="mode"/>.</exception>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Throttle``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Int32,System.TimeSpan,System.Int32,System.Func{``0,System.Int32},Akka.Streams.ThrottleMode)">
            <summary>
            Sends elements downstream with speed limited to `<paramref name="cost"/>/<paramref name="per"/>`. Cost is
            calculating for each element individually by calling <paramref name="calculateCost"/> function.
            This combinator works for streams when elements have different cost(length).
            Streams of <see cref="T:Akka.IO.ByteString"/> for example.
            
            Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
            Tokens drops into the bucket at a given rate and can be `spared` for later use up to bucket capacity
            to allow some burstyness. Whenever stream wants to send an element, it takes as many
            tokens from the bucket as element cost. If there isn't any, throttle waits until the
            bucket accumulates enough tokens. Elements that costs more than the allowed burst will be delayed proportionally
            to their cost minus available tokens, meeting the target rate.
            
            Parameter <paramref name="mode"/> manages behaviour when upstream is faster than throttle rate:
             - <see cref="F:Akka.Streams.ThrottleMode.Shaping"/> makes pauses before emitting messages to meet throttle rate
             - <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> fails with exception when upstream is faster than throttle rate. Enforcing
             cannot emit elements that cost more than the maximumBurst
            <para>
            '''Emits when''' upstream emits an element and configured time per each element elapsed
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Detach``2(Akka.Streams.Dsl.IFlow{``0,``1})">
             <summary>
             Detaches upstream demand from downstream demand without detaching the
             stream rates; in other words acts like a buffer of size 1.
            
             '''Emits when''' upstream emits an element
            
             '''Backpressures when''' downstream backpressures
            
             '''Completes when''' upstream completes
            
             '''Cancels when''' downstream cancels
             </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.InitialDelay``2(Akka.Streams.Dsl.IFlow{``0,``1},System.TimeSpan)">
            <summary>
            Delays the initial element by the specified duration.
            <para>
            '''Emits when''' upstream emits an element if the initial delay already elapsed
            </para>
            '''Backpressures when''' downstream backpressures or initial delay not yet elapsed
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Log``2(Akka.Streams.Dsl.IFlow{``0,``1},System.String,System.Func{``0,System.Object},Akka.Event.ILoggingAdapter)">
            <summary>
            Logs elements flowing through the stream as well as completion and erroring.
            
            By default element and completion signals are logged on debug level, and errors are logged on Error level.
            This can be adjusted according to your needs by providing a custom <see cref="T:Akka.Streams.Attributes.LogLevels"/> attribute on the given Flow.
            <para>
            '''Emits when''' the mapping function returns an element
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Zip``3(Akka.Streams.Dsl.IFlow{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2})">
            <summary>
            Combine the elements of current flow and the given [[Source]] into a stream of tuples.
            <para>
            '''Emits when''' all of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' any upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.ZipWith``4(Akka.Streams.Dsl.IFlow{``0,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``3},System.Func{``0,``1,``2})">
            <summary>
            Put together the elements of current flow and the given [[Source]]
            into a stream of combined elements using a combiner function.
            <para>
            '''Emits when''' all of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' any upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Interleave``3(Akka.Streams.Dsl.IFlow{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2},System.Int32)">
            <summary>
            Interleave is a deterministic merge of the given [[Source]] with elements of this [[Flow]].
            It first emits <paramref name="segmentSize"/> number of elements from this flow to downstream, then - same amount for <paramref name="graph"/>
            source, then repeat process.
             
            After one of upstreams is complete than all the rest elements will be emitted from the second one
            
            If it gets error from one of upstreams - stream completes with failure.
            <para>
            '''Emits when''' element is available from the currently consumed upstream
            </para>
            '''Backpressures when''' downstream backpressures. Signal to current
            upstream, switch to next upstream when received `segmentSize` elements
            <para>
            '''Completes when''' the [[Flow]] and given [[Source]] completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <example>
            <code>
            Source(List(1, 2, 3)).Interleave(List(4, 5, 6, 7), 2) // 1, 2, 4, 5, 3, 6, 7
            </code>
            </example>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.InterleaveMaterialized``5(Akka.Streams.Dsl.IFlow{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``3},System.Int32,System.Func{``2,``3,``4})">
             <summary>
             Interleave is a deterministic merge of the given <see cref="T:Akka.Streams.Dsl.Source`2"/> with elements of this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>.
             It first emits `segmentSize` number of elements from this flow to downstream, then - same amount for `that` source,
             then repeat process.
            
             After one of upstreams is complete than all the rest elements will be emitted from the second one
            
             If it gets error from one of upstreams - stream completes with failure.
            
             @see<see cref="T:Akka.Streams.Dsl.Interleave`2"/>.
            
            It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
             where appropriate instead of manually writing functions that pass through one of the values.
             </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Merge``3(Akka.Streams.Dsl.IFlow{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2},System.Boolean)">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source"/> to this <see cref="T:Akka.Streams.Dsl.Flow"/>, taking elements as they arrive from input streams,
            picking randomly when several elements ready.
            <para>
            '''Emits when''' one of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' all upstreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.MergeMaterialized``5(Akka.Streams.Dsl.IFlow{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``3},System.Func{``2,``3,``4},System.Boolean)">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source"/> to this <see cref="T:Akka.Streams.Dsl.Flow"/>, taking elements as they arrive from input streams,
            picking randomly when several elements ready.
            
            @see <see cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Merge``3(Akka.Streams.Dsl.IFlow{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2},System.Boolean)"/>
            
            It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
            where appropriate instead of manually writing functions that pass through one of the values.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.MergeSorted``2(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1},System.Func{``0,``0,System.Int32})">
            <summary>
            Merge the given [[Source]] to this [[Flow]], taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            '''Emits when''' one of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' all upstreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.MergeSorted``2(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})">
            <summary>
            Merge the given [[Source]] to this [[Flow]], taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            '''Emits when''' one of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' all upstreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.MergeSorted``2(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1},System.Collections.Generic.IComparer{``0})">
            <summary>
            Merge the given [[Source]] to this [[Flow]], taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            '''Emits when''' one of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' all upstreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Concat``2(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})">
            <summary>
            Concatenate the given [[Source]] to this [[Flow]], meaning that once this
            Flowâ€™s input is exhausted and all result elements have been generated,
            the Sourceâ€™s elements will be produced.
            
            Note that the [[Source]] is materialized together with this Flow and just kept
            from producing elements by asserting back-pressure until its time comes.
            
            If this [[Flow]] gets upstream error - no elements from the given [[Source]] will be pulled.
            <para>
            '''Emits when''' element is available from current stream or from the given [[Source]] when current is completed
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' given [[Source]] completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.Prepend``3(Akka.Streams.Dsl.IFlow{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2})">
             <summary>
             Prepend the given <seealso cref="T:Akka.Streams.Dsl.Source"/> to this <seealso cref="T:Akka.Streams.Dsl.Flow"/>, meaning that before elements
             are generated from this <seealso cref="T:Akka.Streams.Dsl.Flow"/>, the Source's elements will be produced until it
             is exhausted, at which point Flow elements will start being produced.
            
             Note that this <seealso cref="T:Akka.Streams.Dsl.Flow"/> will be materialized together with the <seealso cref="T:Akka.Streams.Dsl.Source"/> and just kept
             from producing elements by asserting back-pressure until its time comes.
            
             If the given <seealso cref="T:Akka.Streams.Dsl.Source"/> gets upstream error - no elements from this <seealso cref="T:Akka.Streams.Dsl.Flow"/> will be pulled.
            
             '''Emits when''' element is available from the given <seealso cref="T:Akka.Streams.Dsl.Source"/> or from current stream when the <seealso cref="T:Akka.Streams.Dsl.Source"/> is completed
            
             '''Backpressures when''' downstream backpressures
            
             '''Completes when''' this <seealso cref="T:Akka.Streams.Dsl.Flow"/> completes
            
             '''Cancels when''' downstream cancels
             </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.AlsoToMaterialized``4(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``2},System.Func{``1,``2,``3})">
            <summary>
            Attaches the given <seealso cref="T:Akka.Streams.Dsl.Sink`2"/> to this <seealso cref="T:Akka.Streams.Dsl.Flow`3"/>, meaning that elements that passes
            through will also be sent to the <seealso cref="T:Akka.Streams.Dsl.Sink`2"/>.
            
            @see <seealso cref="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.AlsoTo``2(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``1})"/>
            
            It is recommended to use the internally optimized <seealso cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <seealso cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
            where appropriate instead of manually writing functions that pass through one of the values.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.AlsoTo``2(Akka.Streams.Dsl.IFlow{``0,``1},Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``1})">
             <summary>
             Attaches the given <seealso cref="T:Akka.Streams.Dsl.Sink`2"/> to this <seealso cref="T:Akka.Streams.Dsl.Flow`3"/>, meaning that elements that passes
             through will also be sent to the <seealso cref="T:Akka.Streams.Dsl.Sink`2"/>.
             
             '''Emits when''' element is available and demand exists both from the Sink and the downstream.
            
             '''Backpressures when''' downstream or Sink backpressures
            
             '''Completes when''' upstream completes
            
             '''Cancels when''' downstream cancels
             </summary>
             <returns></returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Internal.InternalFlowOperations.WatchTermination``3(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{``1,System.Threading.Tasks.Task{System.Reactive.Streams.Unit},``2})">
            <summary>
             Materializes to `Future[Done]` that completes on getting termination message.
             The Future completes with success when received complete message from upstream or cancel
             from downstream. It fails with the same error when received error message from
             downstream.
            
             It is recommended to use the internally optimized `Keep.left` and `Keep.right` combiners
             where appropriate instead of manually writing functions that pass through one of the values.
            </summary>    
        </member>
        <member name="T:Akka.Streams.Dsl.IRunnableGraph`1">
            <summary>
            Flow with attached input and output, can be executed.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.IRunnableGraph`1.MapMaterializedValue``1(System.Func{`0,``0})">
            <summary>
            Transform only the materialized value of this RunnableGraph, leaving all other properties as they were.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.IRunnableGraph`1.Run(Akka.Streams.IMaterializer)">
            <summary>
            Run this flow and return the materialized instance from the flow.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.RunnableGraph.FromGraph``1(Akka.Streams.IGraph{Akka.Streams.ClosedShape,``0})">
            <summary>
            A graph with a closed shape is logically a runnable graph, this method makes
            it so also in type.
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.Sink`2">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> is a set of stream processing steps that has one open input and an attached output.
            Can be used as a <see cref="T:System.Reactive.Streams.ISubscriber`1"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink`2.ContraMap``1(System.Func{``0,`0})">
            <summary>
            Transform this <see cref="T:Akka.Streams.Dsl.Sink"/> by applying a function to each *incoming* upstream element before
            it is passed to the <see cref="T:Akka.Streams.Dsl.Sink"/>
            
            '''Backpressures when''' original <see cref="T:Akka.Streams.Dsl.Sink"/> backpressures
            
            '''Cancels when''' original <see cref="T:Akka.Streams.Dsl.Sink"/> backpressures
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink`2.RunWith``1(Akka.Streams.IGraph{Akka.Streams.SourceShape{`0},``0},Akka.Streams.IMaterializer)">
            <summary>
            Connect this <see cref="T:Akka.Streams.Dsl.Sink`2"/> to a <see cref="T:Akka.Streams.Dsl.Source`2"/> and run it. The returned value is the materialized value
            of the <see cref="T:Akka.Streams.Dsl.Source`2"/>, e.g. the <see cref="T:System.Reactive.Streams.ISubscriber`1"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Wrap``2(Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``1})">
            <summary>
            A graph with the shape of a sink logically is a sink, this method makes
            it so also in type.
            </summary> 
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Create``1(System.Reactive.Streams.ISubscriber{``0})">
            <summary>
            Helper to create <see cref="T:Akka.Streams.Dsl.Sink`2"/> from <see cref="T:System.Reactive.Streams.ISubscriber`1"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.First``1">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that materializes into a <see cref="T:System.Threading.Tasks.Task`1"/> of the first value received.
            If the stream completes before signaling at least a single element, the Task will be failed with a <see cref="T:Akka.Streams.NoSuchElementException"/>.
            If the stream signals an error errors before signaling at least a single element, the Task will be failed with the streams exception.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.FirstOrDefault``1">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that materializes into a <see cref="T:System.Threading.Tasks.Task`1"/> of the first value received.
            If the stream completes before signaling at least a single element, the Task will return default value.
            If the stream signals an error errors before signaling at least a single element, the Task will be failed with the streams exception.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Last``1">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that materializes into a <see cref="T:System.Threading.Tasks.Task`1"/> of the last value received.
            If the stream completes before signaling at least a single element, the Task will be failed with a <see cref="T:Akka.Streams.NoSuchElementException"/>.
            If the stream signals an error errors before signaling at least a single element, the Task will be failed with the streams exception.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.LastOrDefault``1">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that materializes into a <see cref="T:System.Threading.Tasks.Task`1"/> of the last value received.
            If the stream completes before signaling at least a single element, the Task will be return a default value.
            If the stream signals an error errors before signaling at least a single element, the Task will be failed with the streams exception.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Publisher``1">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that materializes into a <see cref="T:System.Reactive.Streams.IPublisher`1"/>.
            that can handle one <see cref="T:System.Reactive.Streams.ISubscriber`1"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.FanoutPublisher``1(System.Int32,System.Int32)">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that materializes into <see cref="T:System.Reactive.Streams.IPublisher`1"/>
            that can handle more than one <see cref="T:System.Reactive.Streams.ISubscriber`1"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Ignore``1">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that will consume the stream and discard the elements.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.ForEach``1(System.Action{``0})">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that will invoke the given <paramref name="action"/> for each received element. 
            The sink is materialized into a <see cref="T:System.Threading.Tasks.Task"/> will be completed with success when reaching the
            normal end of the stream, or completed with a failure if there is a failure signaled in
            the stream..
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Combine``3(System.Func{System.Int32,Akka.Streams.IGraph{Akka.Streams.UniformFanOutShape{``0,``1},``2}},Akka.Streams.Dsl.Sink{``1,``2},Akka.Streams.Dsl.Sink{``1,``2},Akka.Streams.Dsl.Sink{``1,``2}[])">
            <summary>
            Combine several sinks with fun-out strategy like <see cref="T:Akka.Streams.Dsl.Broadcast`1"/> or <see cref="T:Akka.Streams.Dsl.Balance`1"/> and returns <see cref="T:Akka.Streams.Dsl.Sink`2"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.ForEachParallel``1(System.Int32,System.Action{``0},Akka.Dispatch.MessageDispatcher)">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that will invoke the given <paramref name="action"/> 
            to each of the elements as they pass in. The sink is materialized into a <see cref="T:System.Threading.Tasks.Task"/>.
            
            If the action throws an exception and the supervision decision is
            <see cref="F:Akka.Actor.Directive.Stop"/> the <see cref="T:System.Threading.Tasks.Task"/> will be completed with failure.
            
            If the action throws an exception and the supervision decision is
            <see cref="F:Akka.Actor.Directive.Resume"/> or <see cref="F:Akka.Actor.Directive.Restart"/> the
            element is dropped and the stream continues. 
            
             <para/>
            See also <seealso cref="T:Akka.Streams.Implementation.Fusing.MapAsyncUnordered`2"/> 
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Fold``2(``1,System.Func{``1,``0,``1})">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that will invoke the given <paramref name="aggregate"/> function for every received element, 
            giving it its previous output (or the given <paramref name="zero"/> value) and the element as input.
            The returned <see cref="T:System.Threading.Tasks.Task"/> will be completed with value of the final
            function evaluation when the input stream ends, or completed with the streams exception
            if there is a failure signaled in the stream.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Reduce``1(System.Func{``0,``0,``0})">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that will invoke the given <paramref name="reduce"/> for every received element, giving it its previous
            output (from the second element) and the element as input.
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will be completed with value of the final
            function evaluation when the input stream ends, or completed with `Failure`
            if there is a failure signaled in the stream.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.OnComplete``1(System.Action,System.Action{System.Exception})">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that when the flow is completed, either through a failure or normal
            completion, apply the provided function with <paramref name="success"/> or <paramref name="failure"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.ActorRef``1(Akka.Actor.IActorRef,System.Object)">
            <summary>
             Sends the elements of the stream to the given <see cref="T:Akka.Actor.IActorRef"/>.
             If the target actor terminates the stream will be canceled.
             When the stream is completed successfully the given <paramref name="onCompleteMessage"/>
             will be sent to the destination actor.
             When the stream is completed with failure a <see cref="T:Akka.Actor.Status.Failure"/>
             message will be sent to the destination actor.
            
             It will request at most <see cref="F:Akka.Streams.ActorMaterializerSettings.MaxInputBufferSize"/> number of elements from
             upstream, but there is no back-pressure signal from the destination actor,
             i.e. if the actor is not consuming the messages fast enough the mailbox
             of the actor will grow. For potentially slow consumer actors it is recommended
             to use a bounded mailbox with zero <see cref="P:Akka.Dispatch.MessageQueues.BoundedMessageQueue.PushTimeOut"/> or use a rate
             limiting stage in front of this <see cref="T:Akka.Streams.Dsl.Sink`2"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.ActorRefWithAck``1(Akka.Actor.IActorRef,System.Object,System.Object,System.Object,System.Func{System.Exception,System.Object})">
             <summary>
             Sends the elements of the stream to the given <see cref="T:Akka.Actor.IActorRef"/> that sends back back-pressure signal.
             First element is always <paramref name="onInitMessage"/>, then stream is waiting for acknowledgement message
             <paramref name="ackMessage"/> from the given actor which means that it is ready to process
             elements.It also requires <paramref name="ackMessage"/> message after each stream element
             to make backpressure work.
            
             If the target actor terminates the stream will be canceled.
             When the stream is completed successfully the given <paramref name="onCompleteMessage"/>
             will be sent to the destination actor.
             When the stream is completed with failure - result of <paramref name="onFailureMessage"/>
             function will be sent to the destination actor.
             </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.ActorSubscriber``1(Akka.Actor.Props)">
            <summary>
             Creates a <see cref="T:Akka.Streams.Dsl.Sink`2"/> that is materialized to an <see cref="T:Akka.Actor.IActorRef"/> which points to an Actor
             created according to the passed in <see cref="T:Akka.Actor.Props"/>. Actor created by the <paramref name="props"/> should
             be <see cref="T:Akka.Streams.Implementation.ActorSubscriberSink`1"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Queue``1">
            <summary>
             <para>
             Creates a <see cref="T:Akka.Streams.Dsl.Sink`2"/> that is materialized as an <see cref="T:Akka.Streams.ISinkQueue`1"/>.
             <see cref="M:Akka.Streams.ISinkQueue`1.PullAsync"/> method is pulling element from the stream and returns <see cref="T:System.Threading.Tasks.Task`1"/>.
             <see cref="T:System.Threading.Tasks.Task"/> completes when element is available.
             </para>
             <para>
             Before calling the pull method a second time you need to wait until previous future completes.
             Pull returns failed future with <see cref="T:Akka.Pattern.IllegalStateException"/> if previous future has not yet completed.
             </para>
             <para>
             <see cref="T:Akka.Streams.Dsl.Sink`2"/> will request at most number of elements equal to size of inputBuffer from
             upstream and then stop back pressure. You can configure size of input by using WithAttributes method.
             </para>
             <para>
             For stream completion you need to pull all elements from <see cref="T:Akka.Streams.ISinkQueue`1"/> including last None
             as completion marker.
             </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.FromGraph``2(Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``1})">
            <summary>
            A graph with the shape of a sink logically is a sink, this method makes
            it so also in type.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.FromSubscriber``1(System.Reactive.Streams.ISubscriber{``0})">
            <summary>
            Helper to create <see cref="T:Akka.Streams.Dsl.Sink`2"/> from <see cref="T:System.Reactive.Streams.ISubscriber`1"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.Cancelled``1">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that immediately cancels its upstream after materialization.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Sink.AsPublisher``1(System.Boolean)">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Sink`2"/> that materializes into a <see cref="T:System.Reactive.Streams.IPublisher`1"/>.
            If <paramref name="fanout"/> is true, the materialized <see cref="T:System.Reactive.Streams.IPublisher`1"/> will support multiple <see cref="T:System.Reactive.Streams.ISubscriber`1"/>`s and
            the size of the <see cref="F:Akka.Streams.ActorMaterializerSettings.MaxInputBufferSize"/> configured for this stage becomes the maximum number of elements that
            the fastest <see cref="T:System.Reactive.Streams.ISubscriber`1"/> can be ahead of the slowest one before slowing
            the processing down due to back pressure.
            
            If <paramref name="fanout"/> is false then the materialized <see cref="T:System.Reactive.Streams.IPublisher`1"/> will only support a single <see cref="T:System.Reactive.Streams.ISubscriber`1"/> and
            reject any additional <see cref="T:System.Reactive.Streams.ISubscriber`1"/>`s.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Recover``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{System.Exception,Akka.Streams.Util.Option{``0}})">
            <summary>
            Recover allows to send last element on failure and gracefully complete the stream
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            <para>
            '''Emits when''' element is available from the upstream or upstream is failed and pf returns an element
            </para>
            <para>
            '''Backpressures when''' downstream backpressures
            </para>
            <para>
            '''Completes when''' upstream completes or upstream failed with exception pf can handle
            </para>
            '''Cancels when''' downstream cancels 
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.RecoverWith``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{System.Exception,Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1}})">
            <summary>
            RecoverWith allows to switch to alternative Source on flow failure. It will stay in effect after
            a failure has been recovered so that each time there is a failure it is fed into the <paramref name="partialFunc"/> and a new
            Source may be materialized.
            <para>
            Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
            This stage can recover the failure signal, but not the skipped elements, which will be dropped.
            </para>
            <para>
            '''Emits when''' element is available from the upstream or upstream is failed and element is available from alternative Source
            </para>
            <para>
            '''Backpressures when''' downstream backpressures
            </para>
            <para>
            '''Completes when''' upstream completes or upstream failed with exception pf can handle
            </para>
            '''Cancels when''' downstream cancels 
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Map``3(Akka.Streams.Dsl.Source{``0,``2},System.Func{``0,``1})">
            <summary>
            Transform this stream by applying the given function to each of the elements
            as they pass through this processing step.
            <para>
            '''Emits when''' the mapping function returns an element
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            <para>
            '''Cancels when''' downstream cancels
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.MapConcat``3(Akka.Streams.Dsl.Source{``0,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Transform each input element into a sequence of output elements that is
            then flattened into the output stream.
            
            The returned sequence MUST NOT contain `null` values,
            as they are illegal as stream elements - according to the Reactive Streams specification.
            <para>
            '''Emits when''' the mapping function returns an element or there are still remaining elements
            from the previously calculated collection
            </para>
            <para>
            '''Backpressures when''' downstream backpressures or there are still remaining elements from the
            previously calculated collection
            </para>
            <para>
            '''Completes when''' upstream completes and all remaining elements has been emitted
            </para>
            <para>
            '''Cancels when''' downstream cancels
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.StatefulMapConcat``3(Akka.Streams.Dsl.Source{``0,``2},System.Func{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})">
            <summary>
            Transform each input element into an `Iterable` of output elements that is
            then flattened into the output stream. The transformation is meant to be stateful,
            which is enabled by creating the transformation function anew for every materialization â€”
            the returned function will typically close over mutable objects to store state between
            invocations. For the stateless variant see <see cref="M:Akka.Streams.Dsl.FlowOperations.MapConcat``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,System.Collections.Generic.IEnumerable{``2}})"/>.
            
            The returned `Iterable` MUST NOT contain `null` values,
            as they are illegal as stream elements - according to the Reactive Streams specification.
            
            <para>
            '''Emits when''' the mapping function returns an element or there are still remaining elements
            from the previously calculated collection
            </para>
            <para>
            '''Backpressures when''' downstream backpressures or there are still remaining elements from the
            previously calculated collection
            </para>
            <para>
            '''Completes when''' upstream completes and all remaining elements has been emitted
            </para>
            <para>
            '''Cancels when''' downstream cancels
            </para>
            See also <see cref="M:Akka.Streams.Dsl.FlowOperations.MapConcat``4(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{``1,System.Collections.Generic.IEnumerable{``2}})"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.MapAsync``3(Akka.Streams.Dsl.Source{``0,``2},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Transform this stream by applying the given function to each of the elements
            as they pass through this processing step. The function returns a `Future` and the
            value of that future will be emitted downstream. The number of Futures
            that shall run in parallel is given as the first argument to ``mapAsync``.
            These Futures may complete in any order, but the elements that
            are emitted downstream are in the same order as received from upstream.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/>
            the stream will be completed with failure.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or
            <see cref="F:Akka.Streams.Supervision.Directive.Restart"/> the element is dropped and the stream continues.
            <para>
            '''Emits when''' the Task returned by the provided function finishes for the next element in sequence
            </para>
            <para>
            '''Backpressures when''' the number of futures reaches the configured parallelism and the downstream
            backpressures or the first future is not completed
            </para>
            <para>
            '''Completes when''' upstream completes and all futures has been completed and all elements has been emitted
            </para>
            <para>
            '''Cancels when''' downstream cancels
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.MapAsyncUnordered``3(Akka.Streams.Dsl.Source{``0,``2},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Transform this stream by applying the given function to each of the elements
            as they pass through this processing step. The function returns a <see cref="T:System.Threading.Tasks.Task"/> and the
            value of that future will be emitted downstreams. As many futures as requested elements by
            downstream may run in parallel and each processed element will be emitted dowstream
            as soon as it is ready, i.e. it is possible that the elements are not emitted downstream
            in the same order as received from upstream.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the <see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="!:Stop"/>
            the stream will be completed with failure.
            
            If the group by function <paramref name="asyncMapper"/> throws an exception or if the<see cref="T:System.Threading.Tasks.Task"/> is completed
            with failure and the supervision decision is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or
            <see cref="!:Restart"/> the element is dropped and the stream continues.
            <para>
            '''Emits when''' any of the Futures returned by the provided function complete
            </para>
            <para>
            '''Backpressures when''' the number of futures reaches the configured parallelism and the downstream backpressures
            </para>
            <para>
            '''Completes when''' upstream completes and all futures has been completed and all elements has been emitted
            </para>
            <para>
            '''Cancels when''' downstream cancels
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Filter``2(Akka.Streams.Dsl.Source{``0,``1},System.Predicate{``0})">
            <summary>
            Only pass on those elements that satisfy the given predicate.
            <para>
            '''Emits when''' the given predicate returns true for the element
            </para>
            <para>
            '''Backpressures when''' the given predicate returns true for the element and downstream backpressures
            </para>
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.FilterNot``2(Akka.Streams.Dsl.Source{``0,``1},System.Predicate{``0})">
            <summary>
            Only pass on those elements that NOT satisfy the given predicate.
            <para>
            '''Emits when''' the given predicate returns true for the element
            </para>
            <para>
            '''Backpressures when''' the given predicate returns true for the element and downstream backpressures
            </para>
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.TakeWhile``2(Akka.Streams.Dsl.Source{``0,``1},System.Predicate{``0})">
            <summary>
            Terminate processing (and cancel the upstream publisher) after predicate
            returns false for the first time. Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if predicate is false for
            the first stream element.
            <para>
            '''Emits when''' the predicate is true
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' predicate returned false or upstream completes
            </para>
            '''Cancels when''' predicate returned false or downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.DropWhile``2(Akka.Streams.Dsl.Source{``0,``1},System.Predicate{``0})">
            <summary>
            Discard elements at the beginning of the stream while predicate is true.
            All elements will be taken after predicate returns false first time.
            <para>
            '''Emits when''' predicate returned false and for all following stream elements
            </para>
            '''Backpressures when''' predicate returned false and downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Collect``3(Akka.Streams.Dsl.Source{``0,``2},System.Func{``0,``1})">
            <summary>
            Transform this stream by applying the given partial function to each of the elements
            on which the function is defined (read: returns not null) as they pass through this processing step.
            Non-matching elements are filtered out.
            <para>
            '''Emits when''' the provided partial function is defined for the element
            </para>
            '''Backpressures when''' the partial function is defined for the element and downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Grouped``2(Akka.Streams.Dsl.Source{``0,``1},System.Int32)">
            <summary>
            Chunk up this stream into groups of the given size, with the last group
            possibly smaller than requested due to end-of-stream.
            <paramref name="n"/> must be positive, otherwise <see cref="T:System.ArgumentException"/> is thrown.
            <para>
            '''Emits when''' the specified number of elements has been accumulated or upstream completed
            </para>
            '''Backpressures when''' a group has been assembled and downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <exception cref="T:System.ArgumentException">Thrown, if <paramref name="n"/> is less than or equal zero.</exception>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Limit``2(Akka.Streams.Dsl.Source{``0,``1},System.Int64)">
            <summary>
            Ensure stream boundedness by limiting the number of elements from upstream.
            If the number of incoming elements exceeds max, it will signal
            upstream failure <see cref="!:StreamLimitException"/> downstream.
            
            Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if `n` is zero
            or negative.
            <para>
            '''Emits when''' the specified number of elements to take has not yet been reached
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' the defined number of elements has been taken or upstream completes
            </para>
            '''Cancels when''' the defined number of elements has been taken or downstream cancels
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.SourceOperations.Take``2(Akka.Streams.Dsl.Source{``0,``1},System.Int64)"/>
            <seealso cref="M:Akka.Streams.Dsl.SourceOperations.TakeWithin``2(Akka.Streams.Dsl.Source{``0,``1},System.TimeSpan)"/>
            <seealso cref="M:Akka.Streams.Dsl.SourceOperations.TakeWhile``2(Akka.Streams.Dsl.Source{``0,``1},System.Predicate{``0})"/>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.LimitWeighted``2(Akka.Streams.Dsl.Source{``0,``1},System.Int64,System.Func{``0,System.Int64})">
            <summary>
            Ensure stream boundedness by evaluating the cost of incoming elements
            using a cost function. Exactly how many elements will be allowed to travel downstream depends on the
            evaluated cost of each element. If the accumulated cost exceeds max, it will signal
            upstream failure <see cref="!:StreamLimitException"/> downstream.
            
            Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if `n` is zero
            or negative.
            <para>
            '''Emits when''' the specified number of elements to take has not yet been reached
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' the defined number of elements has been taken or upstream completes
            </para>
            '''Cancels when''' the defined number of elements has been taken or downstream cancels
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.SourceOperations.Take``2(Akka.Streams.Dsl.Source{``0,``1},System.Int64)"/>
            <seealso cref="M:Akka.Streams.Dsl.SourceOperations.TakeWithin``2(Akka.Streams.Dsl.Source{``0,``1},System.TimeSpan)"/>
            <seealso cref="M:Akka.Streams.Dsl.SourceOperations.TakeWhile``2(Akka.Streams.Dsl.Source{``0,``1},System.Predicate{``0})"/>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Sliding``2(Akka.Streams.Dsl.Source{``0,``1},System.Int32,System.Int32)">
            <summary>
            Apply a sliding window over the stream and return the windows as groups of elements, with the last group
            possibly smaller than requested due to end-of-stream.
            
            <paramref name="n"/> must be positive, otherwise IllegalArgumentException is thrown.
            <paramref name="step"/> must be positive, otherwise IllegalArgumentException is thrown.
            <para>
            '''Emits when''' enough elements have been collected within the window or upstream completed
            </para>
            '''Backpressures when''' a window has been assembled and downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="n"/> or <paramref name="step"/> is less than or equal zero.</exception>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Scan``3(Akka.Streams.Dsl.Source{``0,``2},``1,System.Func{``1,``0,``1})">
            <summary>
            Similar to <see cref="T:Akka.Streams.Implementation.Fusing.Fold`2"/> but is not a terminal operation,
            emits its current value which starts at <paramref name="zero"/> and then
            applies the current and next value to the given function <paramref name="scan"/>,
            emitting the next current value.
            
            If the function <paramref name="scan"/> throws an exception and the supervision decision is
            <see cref="!:Restart"/> current value starts at <paramref name="zero"/> again
            the stream will continue.
            <para>
            '''Emits when''' the function scanning the element returns a new element
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Fold``3(Akka.Streams.Dsl.Source{``0,``2},``1,System.Func{``1,``0,``1})">
            <summary>
            Similar to `scan` but only emits its result when the upstream completes,
            after which it also completes. Applies the given function towards its current and next value,
            yielding the next current value.
            
            If the function `f` throws an exception and the supervision decision is
            [[akka.stream.Supervision.Restart]] current value starts at `zero` again
            the stream will continue.
            <para>
            '''Emits when''' upstream completes
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Reduce``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{``0,``0,``0})">
            <summary>
            Similar to <see cref="M:Akka.Streams.Dsl.SourceOperations.Fold``3(Akka.Streams.Dsl.Source{``0,``2},``1,System.Func{``1,``0,``1})"/> but uses first element as zero element.
            Applies the given function towards its current and next value,
            yielding the next current value. 
            <para>
            '''Emits when''' upstream completes
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Intersperse``2(Akka.Streams.Dsl.Source{``0,``1},``0,``0,``0)">
            <summary>
            Intersperses stream with provided element, similar to how <see cref="M:System.String.Join(System.String,System.String[])"/>
            injects a separator between a collection's elements.
            
            Additionally can inject start and end marker elements to stream.
            
            In case you want to only prepend or only append an element (yet still use the `intercept` feature
            to inject a separator between elements, you may want to use the following pattern instead of the 3-argument
            version of intersperse (See <see cref="M:Akka.Streams.Dsl.SourceOperations.Concat``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})"/> for semantics details). 
            <para>
            '''Emits when''' upstream emits (or before with the `start` element if provided)
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <exception cref="T:System.ArgumentNullException">Thrown when any of the <paramref name="start"/>, <paramref name="inject"/> or <paramref name="end"/> is null.</exception>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Intersperse``2(Akka.Streams.Dsl.Source{``0,``1},``0)">
            <summary>
            Intersperses stream with provided element, similar to how <see cref="M:System.String.Join(System.String,System.String[])"/>
            injects a separator between a collection's elements.
            
            Additionally can inject start and end marker elements to stream.
            
            In case you want to only prepend or only append an element (yet still use the `intercept` feature
            to inject a separator between elements, you may want to use the following pattern instead of the 3-argument
            version of intersperse (See <see cref="M:Akka.Streams.Dsl.SourceOperations.Concat``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})"/> for semantics details). 
            <para>
            '''Emits when''' upstream emits (or before with the `start` element if provided)
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="inject"/> is null.</exception>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.GroupedWithin``2(Akka.Streams.Dsl.Source{``0,``1},System.Int32,System.TimeSpan)">
            <summary>
            Chunk up this stream into groups of elements received within a time window,
            or limited by the given number of elements, whatever happens first.
            Empty groups will not be emitted if no elements are received from upstream.
            The last group before end-of-stream will contain the buffered elements
            since the previously emitted group.
            
            <paramref name="n"/> must be positive, and <paramref name="timeout"/> must be greater than 0 seconds, otherwise
            <see cref="T:System.ArgumentException"/> is thrown.
            <para>
            '''Emits when''' the configured time elapses since the last group has been emitted
            </para>
            '''Backpressures when''' the configured time elapses since the last group has been emitted
            <para>
            '''Completes when''' upstream completes (emits last group)
            </para>
            '''Cancels when''' downstream completes
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="n"/> is less than or equal zero or <paramref name="timeout"/> is <see cref="F:System.TimeSpan.Zero"/>.</exception>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Delay``2(Akka.Streams.Dsl.Source{``0,``1},System.TimeSpan,System.Nullable{Akka.Streams.DelayOverflowStrategy})">
            <summary>
            Shifts elements emission in time by a specified amount. It allows to store elements
            in internal buffer while waiting for next element to be emitted. Depending on the defined
            <see cref="T:Akka.Streams.DelayOverflowStrategy"/> it might drop elements or backpressure the upstream if
            there is no space available in the buffer.
            
            Delay precision is 10ms to avoid unnecessary timer scheduling cycles
            
            Internal buffer has default capacity 16. You can set buffer size by calling <see cref="M:Akka.Streams.Attributes.CreateInputBuffer(System.Int32,System.Int32)"/>
            <para>
            '''Emits when''' there is a pending element in the buffer and configured time for this element elapsed
             * EmitEarly - strategy do not wait to emit element if buffer is full
            </para>
            '''Backpressures when''' depending on OverflowStrategy
             * Backpressure - backpressures when buffer is full
             * DropHead, DropTail, DropBuffer - never backpressures
             * Fail - fails the stream if buffer gets full
            <para>
            '''Completes when''' upstream completes and buffered elements has been drained
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <param name="of">Time to shift all messages.</param>
            <param name="strategy">Strategy that is used when incoming elements cannot fit inside the buffer</param>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Drop``2(Akka.Streams.Dsl.Source{``0,``1},System.Int64)">
            <summary>
            Discard the given number of elements at the beginning of the stream.
            No elements will be dropped if <paramref name="n"/> is zero or negative.
            <para>
            '''Emits when''' the specified number of elements has been dropped already
            </para>
            '''Backpressures when''' the specified number of elements has been dropped and downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.DropWithin``2(Akka.Streams.Dsl.Source{``0,``1},System.TimeSpan)">
            <summary>
            Discard the elements received within the given duration at beginning of the stream.
            <para>
            '''Emits when''' the specified time elapsed and a new upstream element arrives
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Take``2(Akka.Streams.Dsl.Source{``0,``1},System.Int64)">
            <summary>
            Terminate processing (and cancel the upstream publisher) after the given
            number of elements. Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            The stream will be completed without producing any elements if <paramref name="n"/> is zero
            or negative.
            <para>
            '''Emits when''' the specified number of elements to take has not yet been reached
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' the defined number of elements has been taken or upstream completes
            </para>
            '''Cancels when''' the defined number of elements has been taken or downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.TakeWithin``2(Akka.Streams.Dsl.Source{``0,``1},System.TimeSpan)">
            <summary>
            Terminate processing (and cancel the upstream publisher) after the given
            duration. Due to input buffering some elements may have been
            requested from upstream publishers that will then not be processed downstream
            of this step.
            
            Note that this can be combined with <see cref="M:Akka.Streams.Dsl.SourceOperations.Take``2(Akka.Streams.Dsl.Source{``0,``1},System.Int64)"/> to limit the number of elements
            within the duration.
            <para>
            '''Emits when''' an upstream element arrives
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes or timer fires
            </para>
            '''Cancels when''' downstream cancels or timer fires
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.ConflateWithSeed``3(Akka.Streams.Dsl.Source{``0,``1},System.Func{``0,``2},System.Func{``2,``0,``2})">
            <summary>
            Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
            until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
            upstream publisher is faster.
            
            This version of conflate allows to derive a seed from the first element and change the aggregated type to
            be different than the input type. See <see cref="M:Akka.Streams.Dsl.SourceOperations.Conflate``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{``0,``0,``0})"/> for a simpler version that does not change types.
            
            This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
            duplicate elements.
            <para>
            '''Emits when''' downstream stops backpressuring and there is a conflated element available
            </para>
            '''Backpressures when''' never
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <param name="seed">Provides the first state for a conflated value using the first unconsumed element as a start</param> 
            <param name="aggregate">Takes the currently aggregated value and the current pending element to produce a new aggregate</param>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Conflate``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{``0,``0,``0})">
            <summary>
            Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
            until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
            upstream publisher is faster.
            
            This version of conflate does not change the output type of the stream. See <see cref="M:Akka.Streams.Dsl.SourceOperations.ConflateWithSeed``3(Akka.Streams.Dsl.Source{``0,``1},System.Func{``0,``2},System.Func{``2,``0,``2})"/>
            for a more flexible version that can take a seed function and transform elements while rolling up.
            
            This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
            duplicate elements.
            <para>
            '''Emits when''' downstream stops backpressuring and there is a conflated element available
            </para>
            '''Backpressures when''' never
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <param name="aggregate">Takes the currently aggregated value and the current pending element to produce a new aggregate</param>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Batch``3(Akka.Streams.Dsl.Source{``0,``2},System.Int64,System.Func{``0,``1},System.Func{``1,``0,``1})">
             <summary>
             Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
             until the subscriber is ready to accept them.For example a batch step might store received elements in
             an array up to the allowed max limit if the upstream publisher is faster.
            
             This only rolls up elements if the upstream is faster, but if the downstream is faster it will not
             duplicate elements.
            
             '''Emits when''' downstream stops backpressuring and there is an aggregated element available
            
             '''Backpressures when''' there are `max` batched elements and 1 pending element and downstream backpressures
            
             '''Completes when''' upstream completes and there is no batched/pending element waiting
            
             '''Cancels when''' downstream cancels
            
             See also <seealso cref="M:Akka.Streams.Dsl.SourceOperations.ConflateWithSeed``3(Akka.Streams.Dsl.Source{``0,``1},System.Func{``0,``2},System.Func{``2,``0,``2})"/>, <seealso cref="M:Akka.Streams.Dsl.SourceOperations.BatchWeighted``3(Akka.Streams.Dsl.Source{``0,``2},System.Int64,System.Func{``0,System.Int64},System.Func{``0,``1},System.Func{``1,``0,``1})"/>
             </summary>
             <param name="max">maximum number of elements to batch before backpressuring upstream (must be positive non-zero)</param>
             <param name="seed">Provides the first state for a batched value using the first unconsumed element as a start</param>
             <param name="aggregate">Takes the currently batched value and the current pending element to produce a new aggregate</param>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.BatchWeighted``3(Akka.Streams.Dsl.Source{``0,``2},System.Int64,System.Func{``0,System.Int64},System.Func{``0,``1},System.Func{``1,``0,``1})">
              <summary>
             Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
             until the subscriber is ready to accept them.For example a batch step might concatenate `ByteString`
             elements up to the allowed max limit if the upstream publisher is faster.
            
             This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
             duplicate elements.
            
             Batching will apply for all elements, even if a single element cost is greater than the total allowed limit.
             In this case, previous batched elements will be emitted, then the "heavy" element will be emitted (after
             being applied with the `seed` function) without batching further elements with it, and then the rest of the
             incoming elements are batched.
            
             '''Emits when''' downstream stops backpressuring and there is a batched element available
            
             '''Backpressures when''' there are `max` weighted batched elements + 1 pending element and downstream backpressures
            
             '''Completes when''' upstream completes and there is no batched/pending element waiting
            
             '''Cancels when''' downstream cancels
            
             See also <seealso cref="M:Akka.Streams.Dsl.SourceOperations.ConflateWithSeed``3(Akka.Streams.Dsl.Source{``0,``1},System.Func{``0,``2},System.Func{``2,``0,``2})"/>, <seealso cref="M:Akka.Streams.Dsl.SourceOperations.Batch``3(Akka.Streams.Dsl.Source{``0,``2},System.Int64,System.Func{``0,``1},System.Func{``1,``0,``1})"/>
             </summary>
             <param name="max">maximum weight of elements to batch before backpressuring upstream (must be positive non-zero)</param>
             <param name="costFunction">a function to compute a single element weight</param>
             <param name="seed">Provides the first state for a batched value using the first unconsumed element as a start</param>
             <param name="aggregate">Takes the currently batched value and the current pending element to produce a new aggregate</param>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Expand``3(Akka.Streams.Dsl.Source{``0,``2},System.Func{``0,System.Collections.Generic.IEnumerator{``1}})">
            <summary>
            Allows a faster downstream to progress independently of a slower publisher by extrapolating elements from an older
            element until new element comes from the upstream. For example an expand step might repeat the last element for
            the subscriber until it receives an update from upstream.
            
            This element will never "drop" upstream elements as all elements go through at least one extrapolation step.
            This means that if the upstream is actually faster than the upstream it will be backpressured by the downstream
            subscriber.
            
            Expand does not support <see cref="!:Restart"/> and <see cref="F:Akka.Streams.Supervision.Directive.Resume"/>.
            Exceptions from the <paramref name="seed"/> or <paramref name="extrapolate"/> functions will complete the stream with failure.
            <para>
            '''Emits when''' downstream stops backpressuring
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <param name="extrapolate">Takes the current extrapolation state to produce an output element and the next extrapolation state.</param>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Buffer``2(Akka.Streams.Dsl.Source{``0,``1},System.Int32,Akka.Streams.OverflowStrategy)">
            <summary>
            Adds a fixed size buffer in the flow that allows to store elements from a faster upstream until it becomes full.
            Depending on the defined <see cref="T:Akka.Streams.OverflowStrategy"/> it might drop elements or backpressure the upstream if
            there is no space available
            <para>
            '''Emits when''' downstream stops backpressuring and there is a pending element in the buffer
            </para>
            '''Backpressures when''' depending on OverflowStrategy
             * Backpressure - backpressures when buffer is full
             * DropHead, DropTail, DropBuffer - never backpressures
             * Fail - fails the stream if buffer gets full
            <para>
            '''Completes when''' upstream completes and buffered elements has been drained
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <param name="size">The size of the buffer in element count</param>
            <param name="strategy">Strategy that is used when incoming elements cannot fit inside the buffer</param>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Transform``3(Akka.Streams.Dsl.Source{``0,``2},System.Func{Akka.Streams.Stage.IStage{``0,``1}})">
            <summary>
            Generic transformation of a stream with a custom processing <see cref="T:Akka.Streams.Stage.IStage`2"/>.
            This operator makes it possible to extend the <see cref="T:Akka.Streams.Dsl.Flow"/> API when there is no specialized
            operator that performs the transformation.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.PrefixAndTail``2(Akka.Streams.Dsl.Source{``0,``1},System.Int32)">
            <summary>
            Takes up to <paramref name="n"/> elements from the stream and returns a pair containing a strict sequence of the taken element
            and a stream representing the remaining elements. If <paramref name="n"/> is zero or negative, then this will return a pair
            of an empty collection and a stream containing the whole upstream unchanged.
            <para>
            '''Emits when''' the configured number of prefix elements are available. Emits this prefix, and the rest
            as a substream
            </para>
            '''Backpressures when''' downstream backpressures or substream backpressures
            <para>
            '''Completes when''' prefix elements has been consumed and substream has been consumed
            </para>
            '''Cancels when''' downstream cancels or substream cancels
            </summary> 
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.GroupBy``3(Akka.Streams.Dsl.Source{``0,``1},System.Int32,System.Func{``0,``2})">
            <summary>
            This operation demultiplexes the incoming stream into separate output
            streams, one for each element key. The key is computed for each element
            using the given function. When a new key is encountered for the first time
            it is emitted to the downstream subscriber together with a fresh
            flow that will eventually produce all the elements of the substream
            for that key. Not consuming the elements from the created streams will
            stop this processor from processing more elements, therefore you must take
            care to unblock (or cancel) all of the produced streams even if you want
            to consume only one of them.
            
            If the group by function <paramref name="groupingFunc"/> throws an exception and the supervision decision
            is <see cref="!:Stop"/> the stream and substreams will be completed
            with failure.
            
            If the group by <paramref name="groupingFunc"/> throws an exception and the supervision decision
            is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or <see cref="!:Restart"/>
            the element is dropped and the stream and substreams continue.
            <para>
            '''Emits when''' an element for which the grouping function returns a group that has not yet been created.
            Emits the new group
            </para>
            '''Backpressures when''' there is an element pending for a group whose substream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels and all substreams cancel
            </summary> 
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.SplitWhen``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.SubstreamCancelStrategy,System.Func{``0,System.Boolean})">
            <summary>
            This operation applies the given predicate to all incoming elements and
            emits them to a stream of output streams, always beginning a new one with
            the current element if the given predicate returns true for it. This means
            that for the following series of predicate values, three substreams will
            be produced with lengths 1, 2, and 3:
            
            {{{
            false,             // element goes into first substream
            true, false,       // elements go into second substream
            true, false, false // elements go into third substream
            }}}
            
            In case the *first* element of the stream matches the predicate, the first
            substream emitted by splitWhen will start from that element. For example:
            
            {{{
            true, false, false // first substream starts from the split-by element
            true, false        // subsequent substreams operate the same way
            }}}
            
            The object returned from this method is not a normal [[Source]] or [[Flow]],
            it is a [[SubFlow]]. This means that after this combinator all transformations
            are applied to all encountered substreams in the same fashion. Substream mode
            is exited either by closing the substream (i.e. connecting it to a [[Sink]])
            or by merging the substreams back together; see the `to` and `mergeBack` methods
            on [[SubFlow]] for more information.
            
            It is important to note that the substreams also propagate back-pressure as
            any other stream, which means that blocking one substream will block the `splitWhen`
            operator itselfâ€”and thereby all substreamsâ€”once all internal or
            explicit buffers are filled.
            
            If the split <paramref name="predicate"/> throws an exception and the supervision decision
            is <see cref="!:Stop"/> the stream and substreams will be completed
            with failure.
            
            If the split <paramref name="predicate"/> throws an exception and the supervision decision
            is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or <see cref="!:Restart"/>
            the element is dropped and the stream and substreams continue.
            <para>
            '''Emits when''' an element for which the provided predicate is true, opening and emitting
            a new substream for subsequent element
            </para>
            '''Backpressures when''' there is an element pending for the next substream, but the previous
            is not fully consumed yet, or the substream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels and substreams cancel
            </summary>
            <seealso cref="M:Akka.Streams.Dsl.SourceOperations.SplitAfter``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.SubstreamCancelStrategy,System.Func{``0,System.Boolean})"/> 
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.SplitWhen``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{``0,System.Boolean})">
            <summary>
            This operation applies the given predicate to all incoming elements and
            emits them to a stream of output streams, always beginning a new one with
            the current element if the given predicate returns true for it.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.SplitAfter``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.SubstreamCancelStrategy,System.Func{``0,System.Boolean})">
             <summary>
             This operation applies the given predicate to all incoming elements and
             emits them to a stream of output streams.It* ends* the current substream when the
             predicate is true. This means that for the following series of predicate values,
             three substreams will be produced with lengths 2, 2, and 3:
            
             {{{
             false, true,        // elements go into first substream
             false, true,        // elements go into second substream
             false, false, true  // elements go into third substream
             }}}
            
             The object returned from this method is not a normal[[Source]] or[[Flow]],
             it is a[[SubFlow]]. This means that after this combinator all transformations
            are applied to all encountered substreams in the same fashion.Substream mode
             is exited either by closing the substream(i.e.connecting it to a [[Sink]])
             or by merging the substreams back together; see the `to` and `mergeBack` methods
             on[[SubFlow]] for more information.
            
             It is important to note that the substreams also propagate back-pressure as
             any other stream, which means that blocking one substream will block the `splitAfter`
             operator itselfâ€”and thereby all substreamsâ€”once all internal or
             explicit buffers are filled.
            
             If the split <paramref name="predicate"/> throws an exception and the supervision decision
             is <see cref="F:Akka.Streams.Supervision.Directive.Stop"/> the stream and substreams will be completed
             with failure.
            
             If the split <paramref name="predicate"/> throws an exception and the supervision decision
             is <see cref="F:Akka.Streams.Supervision.Directive.Resume"/> or <see cref="F:Akka.Streams.Supervision.Directive.Restart"/>
             the element is dropped and the stream and substreams continue.
             <para>
             '''Emits when''' an element passes through.When the provided predicate is true it emitts the element
             and opens a new substream for subsequent element
             </para>
             '''Backpressures when''' there is an element pending for the next substream, but the previous
             is not fully consumed yet, or the substream backpressures
             <para>
             '''Completes when''' upstream completes
             </para>
             '''Cancels when''' downstream cancels and substreams cancel
             </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.SplitAfter``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{``0,System.Boolean})">
            <summary>
            This operation applies the given predicate to all incoming elements and
            emits them to a stream of output streams. It *ends* the current substream when the
            predicate is true.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.FlatMapConcat``3(Akka.Streams.Dsl.Source{``0,``2},System.Func{``0,Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2}})">
            <summary>
            Transform each input element into a `Source` of output elements that is
            then flattened into the output stream by concatenation,
            fully consuming one Source after the other.
            <para>
            '''Emits when''' a currently consumed substream has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes and all consumed substreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.FlatMapMerge``3(Akka.Streams.Dsl.Source{``0,``2},System.Int32,System.Func{``0,Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2}})">
            <summary>
            Transform each input element into a `Source` of output elements that is
            then flattened into the output stream by merging, where at most <paramref name="breadth"/>
            substreams are being consumed at any given time.
            <para>
            '''Emits when''' a currently consumed substream has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes and all consumed substreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.InitialTimeout``2(Akka.Streams.Dsl.Source{``0,``1},System.TimeSpan)">
            <summary>
            If the first element has not passed through this stage before the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>.
            <para>
            '''Emits when''' upstream emits an element
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes or fails if timeout elapses before first element arrives
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.CompletionTimeout``2(Akka.Streams.Dsl.Source{``0,``1},System.TimeSpan)">
            <summary>
            If the completion of the stream does not happen until the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>.
            <para>
            '''Emits when''' upstream emits an element
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes or fails if timeout elapses before upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.IdleTimeout``2(Akka.Streams.Dsl.Source{``0,``1},System.TimeSpan)">
            <summary>
            If the time between two processed elements exceed the provided timeout, the stream is failed
            with a <see cref="T:System.TimeoutException"/>.
            <para>
            '''Emits when''' upstream emits an element
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes or fails if timeout elapses between two emitted elements
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.KeepAlive``3(Akka.Streams.Dsl.Source{``0,``2},System.TimeSpan,System.Func{``1})">
            <summary>
            Injects additional elements if the upstream does not emit for a configured amount of time. In other words, this
            stage attempts to maintains a base rate of emitted elements towards the downstream.
            
            If the downstream backpressures then no element is injected until downstream demand arrives. Injected elements
            do not accumulate during this period.
            
            Upstream elements are always preferred over injected elements.
            <para>
            '''Emits when''' upstream emits an element or if the upstream was idle for the configured period
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Throttle``2(Akka.Streams.Dsl.Source{``0,``1},System.Int32,System.TimeSpan,System.Int32,Akka.Streams.ThrottleMode)">
            <summary>
            Sends elements downstream with speed limited to `<paramref name="elements"/>/<paramref name="per"/>`. In other words, this stage set the maximum rate
            for emitting messages. This combinator works for streams where all elements have the same cost or length.
            
            Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
            Tokens drops into the bucket at a given rate and can be "spared" for later use up to bucket capacity
            to allow some burstyness. Whenever stream wants to send an element, it takes as many
            tokens from the bucket as number of elements. If there isn't any, throttle waits until the
            bucket accumulates enough tokens.
            
            Parameter <paramref name="mode"/> manages behaviour when upstream is faster than throttle rate:
             - <see cref="F:Akka.Streams.ThrottleMode.Shaping"/> makes pauses before emitting messages to meet throttle rate
             - <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> fails with exception when upstream is faster than throttle rate. Enforcing
             cannot emit elements that cost more than the maximumBurst
            <para>
            '''Emits when''' upstream emits an element and configured time per each element elapsed
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <exception cref="T:System.ArgumentException">Thow when <paramref name="elements"/> is less than or equal zero, 
            or <paramref name="per"/> timeout is equal <see cref="F:System.TimeSpan.Zero"/> 
            or <paramref name="maximumBurst"/> is less than or equal zero in in <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> <paramref name="mode"/>.</exception>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Throttle``2(Akka.Streams.Dsl.Source{``0,``1},System.Int32,System.TimeSpan,System.Int32,System.Func{``0,System.Int32},Akka.Streams.ThrottleMode)">
            <summary>
            Sends elements downstream with speed limited to `<paramref name="cost"/>/<paramref name="per"/>`. Cost is
            calculating for each element individually by calling <paramref name="calculateCost"/> function.
            This combinator works for streams when elements have different cost(length).
            Streams of <see cref="!:ByteString"/> for example.
            
            Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
            Tokens drops into the bucket at a given rate and can be `spared` for later use up to bucket capacity
            to allow some burstyness. Whenever stream wants to send an element, it takes as many
            tokens from the bucket as element cost. If there isn't any, throttle waits until the
            bucket accumulates enough tokens. Elements that costs more than the allowed burst will be delayed proportionally
            to their cost minus available tokens, meeting the target rate.
            
            Parameter <paramref name="mode"/> manages behaviour when upstream is faster than throttle rate:
             - <see cref="F:Akka.Streams.ThrottleMode.Shaping"/> makes pauses before emitting messages to meet throttle rate
             - <see cref="F:Akka.Streams.ThrottleMode.Enforcing"/> fails with exception when upstream is faster than throttle rate. Enforcing
             cannot emit elements that cost more than the maximumBurst
            <para>
            '''Emits when''' upstream emits an element and configured time per each element elapsed
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.AlsoToMaterialized``4(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``2},System.Func{``1,``2,``3})">
            <summary>
            Attaches the given <seealso cref="T:Akka.Streams.Dsl.Sink`2"/> to this <seealso cref="T:Akka.Streams.Dsl.Flow`3"/>, meaning that elements that passes
            through will also be sent to the <seealso cref="T:Akka.Streams.Dsl.Sink`2"/>.
            
            @see <seealso cref="M:Akka.Streams.Dsl.SourceOperations.AlsoTo``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``1})"/>
            
            It is recommended to use the internally optimized <seealso cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <seealso cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
            where appropriate instead of manually writing functions that pass through one of the values.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.AlsoTo``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``1})">
             <summary>
             Attaches the given <seealso cref="T:Akka.Streams.Dsl.Sink`2"/> to this <seealso cref="T:Akka.Streams.Dsl.Flow`3"/>, meaning that elements that passes
             through will also be sent to the <seealso cref="T:Akka.Streams.Dsl.Sink`2"/>.
             
             '''Emits when''' element is available and demand exists both from the Sink and the downstream.
            
             '''Backpressures when''' downstream or Sink backpressures
            
             '''Completes when''' upstream completes
            
             '''Cancels when''' downstream cancels
             </summary>
             <returns></returns>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.WatchTermination``3(Akka.Streams.Dsl.Source{``0,``1},System.Func{``1,System.Threading.Tasks.Task{System.Reactive.Streams.Unit},``2})">
            <summary>
            Materializes to `Future[Done]` that completes on getting termination message.
            The Future completes with success when received complete message from upstream or cancel
            from downstream. It fails with the same error when received error message from downstream.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Detach``2(Akka.Streams.Dsl.Source{``0,``1})">
             <summary>
             Detaches upstream demand from downstream demand without detaching the
             stream rates; in other words acts like a buffer of size 1.
            
             '''Emits when''' upstream emits an element
            
             '''Backpressures when''' downstream backpressures
            
             '''Completes when''' upstream completes
            
             '''Cancels when''' downstream cancels
             </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.InitialDelay``2(Akka.Streams.Dsl.Source{``0,``1},System.TimeSpan)">
            <summary>
            Delays the initial element by the specified duration.
            <para>
            '''Emits when''' upstream emits an element if the initial delay already elapsed
            </para>
            '''Backpressures when''' downstream backpressures or initial delay not yet elapsed
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Log``2(Akka.Streams.Dsl.Source{``0,``1},System.String,System.Func{``0,System.Object},Akka.Event.ILoggingAdapter)">
            <summary>
            Logs elements flowing through the stream as well as completion and erroring.
            
            By default element and completion signals are logged on debug level, and errors are logged on Error level.
            This can be adjusted according to your needs by providing a custom <see cref="T:Akka.Streams.Attributes.LogLevels"/> attribute on the given Flow.
            <para>
            '''Emits when''' the mapping function returns an element
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Zip``3(Akka.Streams.Dsl.Source{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2})">
            <summary>
            Combine the elements of current flow and the given [[Source]] into a stream of tuples.
            <para>
            '''Emits when''' all of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' any upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.ZipWith``4(Akka.Streams.Dsl.Source{``0,``3},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``3},System.Func{``0,``1,``2})">
            <summary>
            Put together the elements of current flow and the given [[Source]]
            into a stream of combined elements using a combiner function.
            <para>
            '''Emits when''' all of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' any upstream completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Interleave``3(Akka.Streams.Dsl.Source{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2},System.Int32)">
            <summary>
            Interleave is a deterministic merge of the given [[Source]] with elements of this [[Flow]].
            It first emits <paramref name="segmentSize"/> number of elements from this flow to downstream, then - same amount for <paramref name="other"/>
            source, then repeat process.
             
            After one of upstreams is complete than all the rest elements will be emitted from the second one
            
            If it gets error from one of upstreams - stream completes with failure.
            <para>
            '''Emits when''' element is available from the currently consumed upstream
            </para>
            '''Backpressures when''' downstream backpressures. Signal to current
            upstream, switch to next upstream when received `segmentSize` elements
            <para>
            '''Completes when''' the [[Flow]] and given [[Source]] completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
            <example>
            <code>
            Source(List(1, 2, 3)).Interleave(List(4, 5, 6, 7), 2) // 1, 2, 4, 5, 3, 6, 7
            </code>
            </example>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.InterleaveMaterialized``5(Akka.Streams.Dsl.Source{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``3},System.Int32,System.Func{``2,``3,``4})">
             <summary>
             Interleave is a deterministic merge of the given <see cref="T:Akka.Streams.Dsl.Source`2"/> with elements of this <see cref="T:Akka.Streams.Dsl.IFlow`2"/>.
             It first emits `segmentSize` number of elements from this flow to downstream, then - same amount for `that` source,
             then repeat process.
            
             After one of upstreams is complete than all the rest elements will be emitted from the second one
            
             If it gets error from one of upstreams - stream completes with failure.
            
             @see<see cref="T:Akka.Streams.Dsl.Interleave`2"/>.
            
            It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
             where appropriate instead of manually writing functions that pass through one of the values.
             </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Merge``3(Akka.Streams.Dsl.Source{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2})">
            <summary>
            Merge the given [[Source]] to this [[Flow]], taking elements as they arrive from input streams,
            picking randomly when several elements ready.
            <para>
            '''Emits when''' one of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' all upstreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.MergeMaterialized``5(Akka.Streams.Dsl.Source{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``3},System.Func{``2,``3,``4},System.Boolean)">
            <summary>
            Merge the given <see cref="T:Akka.Streams.Dsl.Source"/> to this <see cref="T:Akka.Streams.Dsl.Flow"/>, taking elements as they arrive from input streams,
            picking randomly when several elements ready.
            
            @see <see cref="M:Akka.Streams.Dsl.SourceOperations.Merge``3(Akka.Streams.Dsl.Source{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2})"/>
            
            It is recommended to use the internally optimized <see cref="M:Akka.Streams.Dsl.Keep.Left``2(``0,``1)"/> and <see cref="M:Akka.Streams.Dsl.Keep.Right``2(``0,``1)"/> combiners
            where appropriate instead of manually writing functions that pass through one of the values.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.MergeSorted``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1},System.Func{``0,``0,System.Int32})">
            <summary>
            Merge the given [[Source]] to this [[Flow]], taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            '''Emits when''' one of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' all upstreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.MergeSorted``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})">
            <summary>
            Merge the given [[Source]] to this [[Flow]], taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            '''Emits when''' one of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' all upstreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.MergeSorted``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1},System.Collections.Generic.IComparer{``0})">
            <summary>
            Merge the given [[Source]] to this [[Flow]], taking elements as they arrive from input streams,
            picking always the smallest of the available elements(waiting for one element from each side
            to be available). This means that possible contiguity of the input streams is not exploited to avoid
            waiting for elements, this merge will block when one of the inputs does not have more elements(and
            does not complete).
            <para>
            '''Emits when''' one of the inputs has an element available
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' all upstreams complete
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Concat``2(Akka.Streams.Dsl.Source{``0,``1},Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})">
            <summary>
            Concatenate the given [[Source]] to this [[Flow]], meaning that once this
            Flowâ€™s input is exhausted and all result elements have been generated,
            the Sourceâ€™s elements will be produced.
            
            Note that the [[Source]] is materialized together with this Flow and just kept
            from producing elements by asserting back-pressure until its time comes.
            
            If this [[Flow]] gets upstream error - no elements from the given [[Source]] will be pulled.
            <para>
            '''Emits when''' element is available from current stream or from the given [[Source]] when current is completed
            </para>
            '''Backpressures when''' downstream backpressures
            <para>
            '''Completes when''' given [[Source]] completes
            </para>
            '''Cancels when''' downstream cancels
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SourceOperations.Prepend``3(Akka.Streams.Dsl.Source{``0,``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2})">
             <summary>
             Prepend the given <seealso cref="T:Akka.Streams.Dsl.Source"/> to this <seealso cref="T:Akka.Streams.Dsl.Flow"/>, meaning that before elements
             are generated from this <seealso cref="T:Akka.Streams.Dsl.Flow"/>, the Source's elements will be produced until it
             is exhausted, at which point Flow elements will start being produced.
            
             Note that this <seealso cref="T:Akka.Streams.Dsl.Flow"/> will be materialized together with the <seealso cref="T:Akka.Streams.Dsl.Source"/> and just kept
             from producing elements by asserting back-pressure until its time comes.
            
             If the given <seealso cref="T:Akka.Streams.Dsl.Source"/> gets upstream error - no elements from this <seealso cref="T:Akka.Streams.Dsl.Flow"/> will be pulled.
            
             '''Emits when''' element is available from the given <seealso cref="T:Akka.Streams.Dsl.Source"/> or from current stream when the <seealso cref="T:Akka.Streams.Dsl.Source"/> is completed
            
             '''Backpressures when''' downstream backpressures
            
             '''Completes when''' this <seealso cref="T:Akka.Streams.Dsl.Flow"/> completes
            
             '''Cancels when''' downstream cancels
             </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.StreamConverters">
            <summary>
            Converters for interacting with the IO streams APIs
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.StreamConverters.FromInputStream(System.Func{System.IO.Stream},System.Int32)">
             Creates a Source from an [[InputStream]] created by the given function.
             Emitted elements are `chunkSize` sized [[akka.util.ByteString]] elements,
             except the final element, which will be up to `chunkSize` in size.
            
             You can configure the default dispatcher for this Source by changing the `akka.stream.blocking-io-dispatcher` or
             set it for a given Source by using [[ActorAttributes]].
            
             It materializes a [[Future]] of [[IOResult]] containing the number of bytes read from the source file upon completion,
             and a possible exception if IO operation was not completed successfully.
            
             The created [[InputStream]] will be closed when the [[Source]] is cancelled.
            
             @param in a function which creates the InputStream to read from
             @param chunkSize the size of each read operation, defaults to 8192
        </member>
        <member name="M:Akka.Streams.Dsl.StreamConverters.AsOutputStream(System.Nullable{System.TimeSpan})">
             Creates a Source which when materialized will return an [[OutputStream]] which it is possible
             to write the ByteStrings to the stream this Source is attached to.
            
             This Source is intended for inter-operation with legacy APIs since it is inherently blocking.
            
             You can configure the default dispatcher for this Source by changing the `akka.stream.blocking-io-dispatcher` or
             set it for a given Source by using [[ActorAttributes]].
            
             The created [[OutputStream]] will be closed when the [[Source]] is cancelled, and closing the [[OutputStream]]
             will complete this [[Source]].
            
             @param writeTimeout the max time the write operation on the materialized OutputStream should block, defaults to 5 seconds
        </member>
        <member name="M:Akka.Streams.Dsl.StreamConverters.FromOutputStream(System.Func{System.IO.Stream},System.Boolean)">
             Creates a Sink which writes incoming [[ByteString]]s to an [[OutputStream]] created by the given function.
            
             Materializes a [[Future]] of [[IOResult]] that will be completed with the size of the file (in bytes) at the streams completion,
             and a possible exception if IO operation was not completed successfully.
            
             You can configure the default dispatcher for this Source by changing the `akka.stream.blocking-io-dispatcher` or
             set it for a given Source by using [[ActorAttributes]].
             If `autoFlush` is true the OutputStream will be flushed whenever a byte array is written, defaults to false.
            
             The [[OutputStream]] will be closed when the stream flowing into this [[Sink]] is completed. The [[Sink]]
             will cancel the stream when the [[OutputStream]] is no longer writable.
        </member>
        <member name="M:Akka.Streams.Dsl.StreamConverters.AsInputStream(System.Nullable{System.TimeSpan})">
             Creates a Sink which when materialized will return an [[InputStream]] which it is possible
             to read the values produced by the stream this Sink is attached to.
            
             This Sink is intended for inter-operation with legacy APIs since it is inherently blocking.
            
             You can configure the default dispatcher for this Source by changing the `akka.stream.blocking-io-dispatcher` or
             set it for a given Source by using [[ActorAttributes]].
            
             The [[InputStream]] will be closed when the stream flowing into this [[Sink]] completes, and
             closing the [[InputStream]] will cancel this [[Sink]].
            
             @param readTimeout the max time the read operation on the materialized InputStream should block
        </member>
        <member name="T:Akka.Streams.Dsl.SubFlow`3">
            <summary>
            A â€œstream of streamsâ€ sub-flow of data elements, e.g. produced by <see cref="!:GroupBy"/>.
            SubFlows cannot contribute to the super-flowâ€™s materialized value since they
            are materialized later, during the runtime of the flow graph processing.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlow`3.RunWith``1(Akka.Streams.IGraph{Akka.Streams.SinkShape{`0},``0},Akka.Streams.IMaterializer)">
            <summary>
            Connect this `Source` to a `Sink` and run it. The returned value is the materialized value
            of the `Sink`, e.g. the `Publisher` of a <see cref="T:System.Reactive.Streams.IPublisher"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlow`3.To``1(Akka.Streams.IGraph{Akka.Streams.SinkShape{`0},``0})">
            <summary>
            Attach a <see cref="T:Akka.Streams.Dsl.Sink"/> to each sub-flow, closing the overall Graph that is being
            constructed.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlow`3.MergeSubstreams">
            <summary>
            Flatten the sub-flows back into the super-flow by performing a merge
            without parallelism limit (i.e. having an unbounded number of sub-flows
            active concurrently).
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlow`3.MergeSubstreamsWithParallelism(System.Int32)">
            <summary>
            Flatten the sub-flows back into the super-flow by performing a merge
            with the given parallelism limit. This means that only up to <paramref name="parallelism"/>
            substreams will be executed at any given time. Substreams that are not
            yet executed are also not materialized, meaning that back-pressure will
            be exerted at the operator that creates the substreams when the parallelism
            limit is reached.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.SubFlow`3.ConcatSubstream">
            <summary>
            Flatten the sub-flows back into the super-flow by concatenating them.
            This is usually a bad idea when combined with <see cref="!:GroupBy"/> since it can
            easily lead to deadlockâ€”the concatenation does not consume from the second
            substream until the first has finished and the <see cref="!:GroupBy"/> stage will get
            back-pressure from the second stream.
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.Tcp.ServerBinding">
            <summary>
            Represents a successful TCP server binding.
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.Tcp.IncomingConnection">
            <summary>
            Represents an accepted incoming TCP connection.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Tcp.IncomingConnection.HandleWith``1(Akka.Streams.Dsl.Flow{Akka.IO.ByteString,Akka.IO.ByteString,``0},Akka.Streams.IMaterializer)">
            <summary>
            Handles the connection using the given flow, which is materialized exactly once and the respective
            materialized instance is returned.
            <para/>
            Convenience shortcut for: flow.join(handler).run().
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.Tcp.OutgoingConnection">
            <summary>
            Represents a prospective outgoing TCP connection.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.TcpExt.Bind(System.String,System.Int32,System.Int32,System.Collections.Immutable.IImmutableList{Akka.IO.Inet.SocketOption},System.Boolean,System.Nullable{System.TimeSpan})">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Tcp.ServerBinding"/> instance which represents a prospective TCP server binding on the given <paramref name="host"/> and <paramref name="port"/>/>.
            <para/>
            Please note that the startup of the server is asynchronous, i.e. after materializing the enclosing
            <see cref="T:Akka.Streams.Dsl.RunnableGraph`1"/> the server is not immediately available. Only after the materialized future
            completes is the server ready to accept client connections.
            </summary>
            <param name="host">The host to listen on</param>
            <param name="port">The port to listen on</param>
            <param name="backlog">Controls the size of the connection backlog</param>
            <param name="options">TCP options for the connections, see <see cref="T:Akka.IO.Tcp"/> for details</param>
            <param name="halfClose">Controls whether the connection is kept open even after writing has been completed to the accepted TCP connections.
            If set to true, the connection will implement the TCP half-close mechanism, allowing the client to
            write to the connection even after the server has finished writing. The TCP socket is only closed
            after both the client and server finished writing.
            If set to false, the connection will immediately closed once the server closes its write side,
            independently whether the client is still attempting to write. This setting is recommended
            for servers, and therefore it is the default setting.
            </param>
        </member>
        <member name="M:Akka.Streams.Dsl.TcpExt.BindAndHandle(Akka.Streams.Dsl.Flow{Akka.IO.ByteString,Akka.IO.ByteString,System.Reactive.Streams.Unit},Akka.Streams.IMaterializer,System.String,System.Int32,System.Int32,System.Collections.Immutable.IImmutableList{Akka.IO.Inet.SocketOption},System.Boolean,System.Nullable{System.TimeSpan})">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Tcp.ServerBinding"/> instance which represents a prospective TCP server binding on the given <paramref name="host"/> and <paramref name="port"/>/>
            handling the incoming connections using the provided Flow.
            <para/>
            Please note that the startup of the server is asynchronous, i.e. after materializing the enclosing
            <see cref="T:Akka.Streams.Dsl.RunnableGraph`1"/> the server is not immediately available. Only after the materialized future
            completes is the server ready to accept client connections.
            </summary>
            <param name="handler">A Flow that represents the server logic</param>
            <param name="host">The host to listen on</param>
            <param name="port">The port to listen on</param>
            <param name="backlog">Controls the size of the connection backlog</param>
            <param name="options">TCP options for the connections, see <see cref="T:Akka.IO.Tcp"/> for details</param>
            <param name="halfClose">Controls whether the connection is kept open even after writing has been completed to the accepted TCP connections.
            If set to true, the connection will implement the TCP half-close mechanism, allowing the client to
            write to the connection even after the server has finished writing. The TCP socket is only closed
            after both the client and server finished writing.
            If set to false, the connection will immediately closed once the server closes its write side,
            independently whether the client is still attempting to write. This setting is recommended
            for servers, and therefore it is the default setting.
            </param>
        </member>
        <member name="M:Akka.Streams.Dsl.TcpExt.OutgoingConnection(System.Net.EndPoint,System.Net.EndPoint,System.Collections.Immutable.IImmutableList{Akka.IO.Inet.SocketOption},System.Boolean,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan})">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Tcp.OutgoingConnection"/> instance representing a prospective TCP client connection to the given endpoint.
            </summary>
            <param name="remoteAddress"> The remote address to connect to</param>
            <param name="localAddress">Optional local address for the connection</param>
            <param name="options">TCP options for the connections, see <see cref="T:Akka.IO.Tcp"/> for details</param>
            <param name="halfClose"> Controls whether the connection is kept open even after writing has been completed to the accepted TCP connections.
            If set to true, the connection will implement the TCP half-close mechanism, allowing the server to
            write to the connection even after the client has finished writing.The TCP socket is only closed
            after both the client and server finished writing. This setting is recommended for clients and therefore it is the default setting.
            If set to false, the connection will immediately closed once the client closes its write side,
            independently whether the server is still attempting to write.
            </param>
        </member>
        <member name="M:Akka.Streams.Dsl.TcpExt.OutgoingConnection(System.String,System.Int32)">
            <summary>
            Creates an <see cref="T:Akka.Streams.Dsl.Tcp.OutgoingConnection"/> without specifying options.
            It represents a prospective TCP client connection to the given endpoint.
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.Flow`3">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Flow`3"/> is a set of stream processing steps that has one open input and one open output.
            </summary>
            <typeparam name="TIn">Type of the flow input.</typeparam>
            <typeparam name="TOut">Type of the flow output.</typeparam>
            <typeparam name="TMat">Type of value, flow graph may materialize to.</typeparam>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            Change the attributes of this <see cref="T:Akka.Streams.Dsl.Flow`3"/> to the given ones. Note that this
            operation has no effect on an empty Flow (because the attributes apply
            only to the contained processing stages).
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.MapMaterializedValue``1(System.Func{`2,``0})">
            <summary>
            Transform the materialized value of this Flow, leaving all other properties as they were.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.To``1(Akka.Streams.IGraph{Akka.Streams.SinkShape{`1},``0})">
            <summary>
            Connect this <see cref="T:Akka.Streams.Dsl.Flow`3"/> to a <see cref="T:Akka.Streams.Dsl.Sink`2"/>, concatenating the processing steps of both.
            The materialized value of the combined <see cref="T:Akka.Streams.Dsl.Sink`2"/> will be the materialized
            value of the current flow (ignoring the given Sinkâ€™s value), use
            <see cref="M:Akka.Streams.Dsl.Flow`3.ToMaterialized``2(Akka.Streams.IGraph{Akka.Streams.SinkShape{`1},``0},System.Func{`2,``0,``1})"/> if a different strategy is needed.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.ToMaterialized``2(Akka.Streams.IGraph{Akka.Streams.SinkShape{`1},``0},System.Func{`2,``0,``1})">
            <summary>
            Connect this <see cref="T:Akka.Streams.Dsl.Flow`3"/> to a <see cref="T:Akka.Streams.Dsl.Sink`2"/>, concatenating the processing steps of both.
            The <paramref name="combine"/> function is used to compose the materialized values of this flow and that
            Sink into the materialized value of the resulting Sink.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.ConcatMaterialized``2(Akka.Streams.IGraph{Akka.Streams.SourceShape{`1},``0},System.Func{`2,``0,``1})">
             <summary>
             Concatenate the given <seealso cref="T:Akka.Streams.Dsl.Source`2"/> to this <seealso cref="T:Akka.Streams.Dsl.Flow`3"/>, meaning that once this
             Flowâ€™s input is exhausted and all result elements have been generated,
             the Sourceâ€™s elements will be produced.
            
             Note that the <seealso cref="T:Akka.Streams.Dsl.Source`2"/> is materialized together with this Flow and just kept
             from producing elements by asserting back-pressure until its time comes.
            
             If this <seealso cref="T:Akka.Streams.Dsl.Flow`3"/> gets upstream error - no elements from the given <seealso cref="T:Akka.Streams.Dsl.Source`2"/> will be pulled.
            
             @see <seealso cref="T:Akka.Streams.Dsl.Concat`2"/>.
            
             It is recommended to use the internally optimized `Keep.left` and `Keep.right` combiners
             where appropriate instead of manually writing functions that pass through one of the values.
             </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.Join``1(Akka.Streams.IGraph{Akka.Streams.FlowShape{`1,`0},``0})">
            <summary>
            Join this <see cref="T:Akka.Streams.Dsl.Flow`3"/> to another <see cref="T:Akka.Streams.Dsl.Flow`3"/>, by cross connecting the inputs and outputs,
            creating a <see cref="T:Akka.Streams.Dsl.IRunnableGraph`1"/>.
            The materialized value of the combined <see cref="T:Akka.Streams.Dsl.Flow`3"/> will be the materialized
            value of the current flow (ignoring the other Flowâ€™s value), use
            <see cref="M:Akka.Streams.Dsl.Flow`3.JoinMaterialized``2(Akka.Streams.IGraph{Akka.Streams.FlowShape{`1,`0},``0},System.Func{`2,``0,``1})"/> if a different strategy is needed.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.JoinMaterialized``2(Akka.Streams.IGraph{Akka.Streams.FlowShape{`1,`0},``0},System.Func{`2,``0,``1})">
            <summary>
            Join this [[Flow]] to another [[Flow]], by cross connecting the inputs and outputs, creating a [[RunnableGraph]]
            The <paramref name="combine"/> function is used to compose the materialized values of this flow and that
            Flow into the materialized value of the resulting Flow.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.RunWith``2(Akka.Streams.IGraph{Akka.Streams.SourceShape{`0},``0},Akka.Streams.IGraph{Akka.Streams.SinkShape{`1},``1},Akka.Streams.IMaterializer)">
            <summary>
            Connect the <see cref="T:Akka.Streams.Dsl.Source`2"/> to this <see cref="T:Akka.Streams.Dsl.Flow`3"/> and then connect it to the <see cref="T:Akka.Streams.Dsl.Sink`2"/> and run it. 
            The returned tuple contains the materialized values of the <paramref name="source"/> and <paramref name="sink"/>, e.g. the <see cref="T:System.Reactive.Streams.ISubscriber`1"/> 
            of a of a <see cref="!:Source&lt;TOut,TMat&gt;.Subscriber"/> and <see cref="T:System.Reactive.Streams.IPublisher`1"/> of a <see cref="T:System.Security.Policy.Publisher"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow`3.ToProcessor">
            <summary>
            Converts this Flow to a <see cref="T:Akka.Streams.Dsl.IRunnableGraph`1"/> that materializes to a Reactive Streams <see cref="T:System.Reactive.Streams.IProcessor`2"/>
            which implements the operations encapsulated by this Flow. Every materialization results in a new Processor
            instance, i.e. the returned <see cref="T:Akka.Streams.Dsl.IRunnableGraph`1"/> is reusable.
            </summary>
            <returns>A <see cref="T:Akka.Streams.Dsl.IRunnableGraph`1"/> that materializes to a <see cref="T:System.Reactive.Streams.IProcessor`2"/> when Run() is called on it.</returns>
        </member>
        <member name="T:Akka.Streams.Dsl.Flow">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Flow"/> is a set of stream processing steps that has one open input and one open output.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow.FromProcessor``2(System.Func{System.Reactive.Streams.IProcessor{``0,``1}})">
            <summary>
            Creates flow from the Reactive Streams <see cref="T:System.Reactive.Streams.IProcessor`2"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow.FromProcessorMaterialized``3(System.Func{System.Tuple{System.Reactive.Streams.IProcessor{``0,``1},``2}})">
            <summary>
            Creates a Flow from a Reactive Streams <see cref="T:System.Reactive.Streams.IProcessor`2"/> and returns a materialized value.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow.Create``1">
            <summary>
            Helper to create a <see cref="T:Akka.Streams.Dsl.Flow`3"/> without a <see cref="T:Akka.Streams.Dsl.Source"/> or <see cref="T:Akka.Streams.Dsl.Sink"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow.Create``2">
            <summary>
            Helper to create a <see cref="T:Akka.Streams.Dsl.Flow`3"/> without a <see cref="T:Akka.Streams.Dsl.Source"/> or <see cref="T:Akka.Streams.Dsl.Sink"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow.FromFunction``2(System.Func{``0,``1})">
            <summary>
            Creates a [Flow] which will use the given function to transform its inputs to outputs. It is equivalent
            to <see cref="!:Flow.Create&lt;TIn&gt;.Map(function)"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow.FromGraph``3(Akka.Streams.IGraph{Akka.Streams.FlowShape{``0,``1},``2})">
            <summary>
            A graph with the shape of a flow logically is a flow, this method makes it so also in type.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow.FromSinkAndSource``3(Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``2})">
            <summary>
            Creates a `Flow` from a `Sink` and a `Source` where the Flow's input
            will be sent to the Sink and the Flow's output will come from the Source.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Flow.FromSinkAndSource``5(Akka.Streams.IGraph{Akka.Streams.SinkShape{``0},``2},Akka.Streams.IGraph{Akka.Streams.SourceShape{``1},``3},System.Func{``2,``3,``4})">
            <summary>
             Creates a `Flow` from a `Sink` and a `Source` where the Flow's input
            will be sent to the Sink and the Flow's output will come from the Source.
            
            The `combine` function is used to compose the materialized values of the `sink` and `source`
            into the materialized value of the resulting [[Flow]].
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.IFlow`2">
            <summary>
            Operations offered by Sources and Flows with a free output side: the DSL flows left-to-right only.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.IFlow`2.Via``2(Akka.Streams.IGraph{Akka.Streams.FlowShape{`0,``0},``1})">
            <summary>
            Transform this <see cref="T:Akka.Streams.Dsl.Flow`3"/> by appending the given processing steps.
            The materialized value of the combined <see cref="T:Akka.Streams.Dsl.Flow`3"/> will be the materialized
            value of the current flow (ignoring the other Flowâ€™s value), use
            <see cref="M:Akka.Streams.Dsl.IFlow`2.ViaMaterialized``3(Akka.Streams.IGraph{Akka.Streams.FlowShape{`0,``0},``1},System.Func{`1,``1,``2})"/> if a different strategy is needed.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.IFlow`2.ViaMaterialized``3(Akka.Streams.IGraph{Akka.Streams.FlowShape{`0,``0},``1},System.Func{`1,``1,``2})">
            <summary>
            Transform this <see cref="T:Akka.Streams.Dsl.IFlow`2"/> by appending the given processing steps.
            The <paramref name="combine"/> function is used to compose the materialized values of this flow and that
            flow into the materialized value of the resulting Flow.
            </summary>
        </member>
        <member name="T:Akka.Streams.Dsl.Keep">
            <summary>
            Convenience functions for often-encountered purposes like keeping only the
            left (first) or only the right (second) of two input values.
            </summary> 
        </member>
        <member name="T:Akka.Streams.Dsl.Source`2">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Source`2"/> is a set of stream processing steps that has one open output. It can comprise
            any number of internal sources and transformations that are wired together, or it can be
            an â€œatomicâ€ source, e.g. from a collection or a file. Materialization turns a Source into
            a Reactive Streams <see cref="T:System.Reactive.Streams.IPublisher`1"/> (at least conceptually).
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.To``1(Akka.Streams.IGraph{Akka.Streams.SinkShape{`0},``0})">
            <summary>
            Connect this <see cref="T:Akka.Streams.Dsl.Source`2"/> to a <see cref="T:Akka.Streams.Dsl.Sink`2"/>,
            concatenating the processing steps of both.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.ToMaterialized``2(Akka.Streams.IGraph{Akka.Streams.SinkShape{`0},``0},System.Func{`1,``0,``1})">
            <summary>
            Connect this <see cref="T:Akka.Streams.Dsl.Source`2"/> to a <see cref="T:Akka.Streams.Dsl.Sink`2"/>,
            concatenating the processing steps of both.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.ConcatMaterialized``2(Akka.Streams.IGraph{Akka.Streams.SourceShape{`0},``0},System.Func{`1,``0,``1})">
             <summary>
             Concatenate the given <seealso cref="T:Akka.Streams.Dsl.Source`2"/> to this <seealso cref="T:Akka.Streams.Dsl.Flow`3"/>, meaning that once this
             Flowâ€™s input is exhausted and all result elements have been generated,
             the Sourceâ€™s elements will be produced.
            
             Note that the <seealso cref="T:Akka.Streams.Dsl.Source`2"/> is materialized together with this Flow and just kept
             from producing elements by asserting back-pressure until its time comes.
            
             If this <seealso cref="T:Akka.Streams.Dsl.Flow`3"/> gets upstream error - no elements from the given <seealso cref="T:Akka.Streams.Dsl.Source`2"/> will be pulled.
            
             @see <seealso cref="T:Akka.Streams.Dsl.Concat`2"/>.
            
             It is recommended to use the internally optimized `Keep.left` and `Keep.right` combiners
             where appropriate instead of manually writing functions that pass through one of the values.
             </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            Nests the current Source and returns a Source with the given Attributes
            </summary>
            <param name="attributes">The attributes to add</param>
            <returns>A new Source with the added attributes</returns>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.MapMaterializedValue``1(System.Func{`1,``0})">
            <summary>
            Transform only the materialized value of this Source, leaving all other properties as they were.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.RunWith``1(Akka.Streams.IGraph{Akka.Streams.SinkShape{`0},``0},Akka.Streams.IMaterializer)">
            <summary>
            Connect this `Source` to a `Sink` and run it. The returned value is the materialized value
            of the `Sink`, e.g. the `Publisher` of a <see cref="T:System.Security.Policy.Publisher"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.RunFold``1(``0,System.Func{``0,`0,``0},Akka.Streams.IMaterializer)">
            <summary>
            Shortcut for running this `Source` with a fold function.
            The given function is invoked for every received element, giving it its previous
            output (or the given <paramref name="zero"/> value) and the element as input.
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will be completed with value of the final
            function evaluation when the input stream ends, or completed with `Failure`
            if there is a failure signaled in the stream.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.RunReduce(System.Func{`0,`0,`0},Akka.Streams.IMaterializer)">
            <summary>
            Shortcut for running this `Source` with a reduce function.
            The given function is invoked for every received element, giving it its previous
            output (from the second element) and the element as input.
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will be completed with value of the final
            function evaluation when the input stream ends, or completed with `Failure`
            if there is a failure signaled in the stream.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.RunForeach(System.Action{`0},Akka.Streams.IMaterializer)">
            <summary>
            Shortcut for running this `Source` with a foreach procedure. The given procedure is invoked
            for each received element.
            The returned <see cref="T:System.Threading.Tasks.Task"/> will be completed with `Success` when reaching the
            normal end of the stream, or completed with `Failure` if there is a failure signaled in
            the stream.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source`2.Combine``2(Akka.Streams.Dsl.Source{``0,System.Reactive.Streams.Unit},Akka.Streams.Dsl.Source{``0,System.Reactive.Streams.Unit},Akka.Streams.Dsl.Source{``0,System.Reactive.Streams.Unit}[],System.Func{System.Int32,Akka.Streams.IGraph{Akka.Streams.UniformFanInShape{``0,``1},System.Reactive.Streams.Unit}})">
            <summary>
            Combines several sources with fun-in strategy like `Merge` or `Concat` and returns `Source`.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.FromPublisher``1(System.Reactive.Streams.IPublisher{``0})">
            <summary>
            Helper to create <see cref="T:Akka.Streams.Dsl.Source`2"/> from `Publisher`.
            
            Construct a transformation starting with given publisher. The transformation steps
            are executed by a series of <see cref="T:System.Reactive.Streams.IProcessor`2"/> instances
            that mediate the flow of elements downstream and the propagation of
            back-pressure upstream.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.FromEnumerator``1(System.Func{System.Collections.Generic.IEnumerator{``0}})">
            <summary>
            Helper to create <see cref="T:Akka.Streams.Dsl.Source`2"/> from <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            Example usage: `Source.fromIterator(() => Iterator.from(0))`
            
            Start a new `Source` from the given function that produces anIterator.
            The produced stream of elements will continue until the iterator runs empty
            or fails during evaluation of the `next()` method.
            Elements are pulled out of the iterator in accordance with the demand coming
            from the downstream transformation steps.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.From``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Helper to create <see cref="T:Akka.Streams.Dsl.Source`2"/> from <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            Example usage: `Source(Seq(1,2,3))`
            
            Starts a new `Source` from the given `Iterable`. This is like starting from an
            Iterator, but every Subscriber directly attached to the Publisher of this
            stream will see an individual flow of elements (always starting from the
            beginning) regardless of when they subscribed.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Single``1(``0)">
            <summary>
            Create a <see cref="T:Akka.Streams.Dsl.Source`2"/> with one element.
            Every connected `Sink` of this stream will see an individual stream consisting of one element.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.FromGraph``2(Akka.Streams.IGraph{Akka.Streams.SourceShape{``0},``1})">
            <summary>
            A graph with the shape of a source logically is a source, this method makes
            it so also in type.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.FromTask``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Start a new <see cref="T:Akka.Streams.Dsl.Source`2"/> from the given <see cref="T:System.Threading.Tasks.Task`1"/>. The stream will consist of
            one element when the `Future` is completed with a successful value, which
            may happen before or after materializing the `Flow`.
            The stream terminates with a failure if the `Future` is completed with a failure.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Tick``1(System.TimeSpan,System.TimeSpan,``0)">
            <summary>
            Elements are emitted periodically with the specified interval.
            The tick element will be delivered to downstream consumers that has requested any elements.
            If a consumer has not requested any elements at the point in time when the tick
            element is produced it will not receive that tick element later. It will
            receive new tick elements as soon as it has requested more elements.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Repeat``1(``0)">
            <summary>
            Create a <see cref="T:Akka.Streams.Dsl.Source`2"/> that will continually emit the given element.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Unfold``2(``0,System.Func{``0,System.Tuple{``0,``1}})">
            <summary>
            Create a <see cref="T:Akka.Streams.Dsl.Source`2"/> that will unfold a value of type <typeparamref name="TState"/> into
            a pair of the next state <typeparamref name="TState"/> and output elements of type <typeparamref name="TElem"/>.
            </summary>
            <example>
            For example, all the Fibonacci numbers under 10M:
            <code>
              Source.unfold(0 â†’ 1) {
               case (a, _) if a > 10000000 â‡’ None
               case (a, b) â‡’ Some((b â†’ (a + b)) â†’ a)
              }
            </code>
            </example>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.UnfoldAsync``2(``0,System.Func{``0,System.Threading.Tasks.Task{System.Tuple{``0,``1}}})">
            <summary>
            Same as <see cref="M:Akka.Streams.Dsl.Source.Unfold``2(``0,System.Func{``0,System.Tuple{``0,``1}})"/>, but uses an async function to generate the next state-element tuple.
            </summary>
            <example>
            For example, all the Fibonacci numbers under 10M:
            <code>
            Source.unfoldAsync(0 â†’ 1) {
             case (a, _) if a > 10000000 â‡’ Future.successful(None)
             case (a, b) â‡’ Future{
               Thread.sleep(1000)
               Some((b â†’ (a + b)) â†’ a)
             }
            }
            </code>
            </example>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.UnfoldInfinite``2(``0,System.Func{``0,System.Tuple{``0,``1}})">
            <summary>
            Simpler <see cref="M:Akka.Streams.Dsl.Source.Unfold``2(``0,System.Func{``0,System.Tuple{``0,``1}})"/>, for infinite sequences. 
            </summary>
            <example>
            <code>
            {{{
              Source.unfoldInf(0 â†’ 1) {
               case (a, b) â‡’ (b â†’ (a + b)) â†’ a
              }
            }}}
            </code>
            </example>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Empty``1">
            <summary>
            A <see cref="T:Akka.Streams.Dsl.Source`2"/> with no elements, i.e. an empty stream that is completed immediately for every connected <see cref="T:Akka.Streams.Dsl.Sink`2"/>.
            </summary> 
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Maybe``1">
            <summary>
            Create a `Source` which materializes a [[scala.concurrent.Promise]] which controls what element
            will be emitted by the Source.
            If the materialized promise is completed with a Some, that value will be produced downstream,
            followed by completion.
            If the materialized promise is completed with a None, no value will be produced downstream and completion will
            be signalled immediately.
            If the materialized promise is completed with a failure, then the returned source will terminate with that error.
            If the downstream of this source cancels before the promise has been completed, then the promise will be completed
            with None.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Failed``1(System.Exception)">
            <summary>
            Create a <see cref="T:Akka.Streams.Dsl.Source`2"/> that immediately ends the stream with the <paramref name="cause"/> error to every connected <see cref="T:Akka.Streams.Dsl.Sink`2"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.AsSubscriber``1">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Source`2"/> that is materialized as a <see cref="T:System.Reactive.Streams.ISubscriber`1"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.ActorPublisher``1(Akka.Actor.Props)">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Source`2"/> that is materialized to an <see cref="T:Akka.Actor.IActorRef"/> which points to an Actor
            created according to the passed in <see cref="T:Akka.Actor.Props"/>. Actor created by the `props` must
            be <see cref="T:Akka.Streams.Actors.ActorPublisher`1"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.ActorRef``1(System.Int32,Akka.Streams.OverflowStrategy)">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Source`2"/> that is materialized as an <see cref="T:Akka.Actor.IActorRef"/>.
            Messages sent to this actor will be emitted to the stream if there is demand from downstream,
            otherwise they will be buffered until request for demand is received.
            
            Depending on the defined <see cref="T:Akka.Streams.OverflowStrategy"/> it might drop elements if
            there is no space available in the buffer.
            
            The strategy <see cref="F:Akka.Streams.OverflowStrategy.Backpressure"/> is not supported, and an
            IllegalArgument("Backpressure overflowStrategy not supported") will be thrown if it is passed as argument.
            
            The buffer can be disabled by using <paramref name="bufferSize"/> of 0 and then received messages are dropped
            if there is no demand from downstream. When <paramref name="bufferSize"/> is 0 the <paramref name="overflowStrategy"/> does
            not matter.
            
            The stream can be completed successfully by sending the actor reference an <see cref="T:Akka.Actor.Status.Success"/>
            message in which case already buffered elements will be signaled before signaling completion,
            or by sending a <see cref="T:Akka.Actor.PoisonPill"/> in which case completion will be signaled immediately.
            
            The stream can be completed with failure by sending <see cref="T:Akka.Actor.Status.Failure"/> to the
            actor reference. In case the Actor is still draining its internal buffer (after having received
            an <see cref="T:Akka.Actor.Status.Success"/>) before signaling completion and it receives a <see cref="T:Akka.Actor.Status.Failure"/>,
            the failure will be signaled downstream immediately (instead of the completion signal).
            
            The actor will be stopped when the stream is completed, failed or canceled from downstream,
            i.e. you can watch it to get notified when that happens.
            </summary>
            <param name="bufferSize">The size of the buffer in element count</param>
            <param name="overflowStrategy">Strategy that is used when incoming elements cannot fit inside the buffer</param>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Combine``2(Akka.Streams.Dsl.Source{``0,System.Reactive.Streams.Unit},Akka.Streams.Dsl.Source{``0,System.Reactive.Streams.Unit},System.Func{System.Int32,Akka.Streams.IGraph{Akka.Streams.UniformFanInShape{``0,``1},System.Reactive.Streams.Unit}},Akka.Streams.Dsl.Source{``0,System.Reactive.Streams.Unit}[])">
            <summary>
            Combines several sources with fun-in strategy like `Merge` or `Concat` and returns `Source`.
            </summary>
        </member>
        <member name="M:Akka.Streams.Dsl.Source.Queue``1(System.Int32,Akka.Streams.OverflowStrategy,System.Nullable{System.TimeSpan})">
            <summary>
            Creates a <see cref="T:Akka.Streams.Dsl.Source`2"/> that is materialized as an <see cref="T:Akka.Streams.ISourceQueue`1"/>.
            You can push elements to the queue and they will be emitted to the stream if there is demand from downstream,
            otherwise they will be buffered until request for demand is received.
            
            Depending on the defined <see cref="T:Akka.Streams.OverflowStrategy"/> it might drop elements if
            there is no space available in the buffer.
            
            Acknowledgement mechanism is available.
            <see cref="M:Akka.Streams.ISourceQueue`1.OfferAsync(`0)"/> returns <see cref="T:System.Threading.Tasks.Task"/> which completes with true
            if element was added to buffer or sent downstream. It completes
            with false if element was dropped.
            
            The strategy <see cref="F:Akka.Streams.OverflowStrategy.Backpressure"/> will not complete `offer():Future` until buffer is full.
            
            The buffer can be disabled by using <paramref name="bufferSize"/> of 0 and then received messages are dropped
            if there is no demand from downstream. When <paramref name="bufferSize"/> is 0 the <paramref name="overflowStrategy"/> does
            not matter.
            </summary>
            <param name="bufferSize">The size of the buffer in element count</param>
            <param name="overflowStrategy">Strategy that is used when incoming elements cannot fit inside the buffer</param>
            <param name="timeout">Timeout for ``SourceQueue.offer(T):Future[Boolean]``</param>
        </member>
        <member name="T:Akka.Streams.Extra.TimedSourceDsl">
            <summary>
            Provides time measurement utilities on Stream elements.
            
            See <see cref="T:Akka.Streams.Extra.Timed"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Extra.TimedSourceDsl.Timed``4(Akka.Streams.Dsl.Source{``0,``2},System.Func{Akka.Streams.Dsl.Source{``0,``2},Akka.Streams.Dsl.Source{``1,``3}},System.Action{System.TimeSpan})">
            <summary>
            Measures time from receiving the first element and completion events - one for each subscriber of this `Flow`.
            </summary>
        </member>
        <member name="M:Akka.Streams.Extra.TimedSourceDsl.TimedIntervalBetween``2(Akka.Streams.Dsl.Source{``0,``1},System.Func{``0,System.Boolean},System.Action{System.TimeSpan})">
            <summary>
            Measures rolling interval between immediately subsequent `matching(o: O)` elements.
            </summary>
        </member>
        <member name="T:Akka.Streams.Extra.TimedFlowDsl">
            <summary>
            Provides time measurement utilities on Stream elements.
            
            See <see cref="T:Akka.Streams.Extra.Timed"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Extra.TimedFlowDsl.Timed``5(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{Akka.Streams.Dsl.Flow{``0,``1,``3},Akka.Streams.Dsl.Flow{``0,``2,``4}},System.Action{System.TimeSpan})">
            <summary>
            Measures time from receiving the first element and completion events - one for each subscriber of this `Flow`.
            </summary>
        </member>
        <member name="M:Akka.Streams.Extra.TimedFlowDsl.TimedIntervalBetween``3(Akka.Streams.Dsl.Flow{``0,``1,``2},System.Func{``1,System.Boolean},System.Action{System.TimeSpan})">
            <summary>
            Measures rolling interval between immediately subsequent `matching(o: O)` elements.
            </summary>
        </member>
        <member name="T:Akka.Streams.Extra.TimedOps">
            <summary>
            INTERNAL API
            
            Provides operations needed to implement the `timed` DSL
            </summary>
        </member>
        <member name="M:Akka.Streams.Extra.TimedOps.Timed``4(Akka.Streams.Dsl.Source{``0,``2},System.Func{Akka.Streams.Dsl.Source{``0,``2},Akka.Streams.Dsl.Source{``1,``3}},System.Action{System.TimeSpan})">
            <summary>
            INTERNAL API
            
            Measures time from receiving the first element and completion events - one for each subscriber of this `Flow`.
            </summary>
        </member>
        <member name="M:Akka.Streams.Extra.TimedOps.Timed``5(Akka.Streams.Dsl.Flow{``0,``1,``3},System.Func{Akka.Streams.Dsl.Flow{``0,``1,``3},Akka.Streams.Dsl.Flow{``0,``2,``4}},System.Action{System.TimeSpan})">
            <summary>
            INTERNAL API
            
            Measures time from receiving the first element and completion events - one for each subscriber of this `Flow`.
            </summary>
        </member>
        <member name="T:Akka.Streams.Extra.TimedIntervalBetweenOps">
            <summary>
            INTERNAL API
            
            Provides operations needed to implement the `timedIntervalBetween` DSL
            </summary>
        </member>
        <member name="M:Akka.Streams.Extra.TimedIntervalBetweenOps.TimedIntervalBetween``2(Akka.Streams.Dsl.IFlow{``0,``1},System.Func{``0,System.Boolean},System.Action{System.TimeSpan})">
            <summary>
            INTERNAL API
            
            Measures rolling interval between immediately subsequent `matching(o: O)` elements.
            </summary>
        </member>
        <member name="T:Akka.Streams.Fusing">
            <summary>
             This class holds some graph transformation functions that can fuse together
             multiple operation stages into synchronous execution islands. The purpose is
             to reduce the number of Actors that are created in order to execute the stream
             and thereby improve start-up cost as well as reduce element traversal latency
             for large graphs. Fusing itself is a time-consuming operation, meaning that
             usually it is best to cache the result of this computation and reuse it instead
             of fusing the same graph many times.
            
             Fusing together all operations which allow this treatment will reduce the
             parallelism that is available in the stream graphâ€™s executionâ€”in the worst case
             it will become single-threaded and not benefit from multiple CPU cores at all.
             Where parallelism is required, the <see cref="T:Akka.Streams.Attributes.AsyncBoundary"/>
             attribute can be used to declare subgraph boundaries across which the graph
             shall not be fused.
            </summary>
        </member>
        <member name="M:Akka.Streams.Fusing.Aggressive``2(Akka.Streams.IGraph{``0,``1})">
            <summary>
            Fuse all operations where this is technically possible (i.e. all
            implementations based on <see cref="T:Akka.Streams.Stage.GraphStage`1"/>) and not forbidden
            via <see cref="T:Akka.Streams.Attributes.AsyncBoundary"/>
            </summary>
        </member>
        <member name="T:Akka.Streams.Fusing.FusedGraph`2">
            <summary>
            A fused graph of the right shape, containing a <see cref="T:Akka.Streams.Implementation.FusedModule"/> which holds more information 
            on the operation structure of the contained stream topology for convenient graph traversal.
            </summary>
        </member>
        <member name="T:Akka.Streams.Fusing.StructuralInfo">
             <summary>
             When fusing a <see cref="T:Akka.Streams.IGraph`1"/> a part of the internal stage wirings are hidden within
            <see cref="T:Akka.Streams.Implementation.Fusing.GraphAssembly"/> objects that are
             optimized for high-speed execution. This structural information bundle contains
             the wirings in a more accessible form, allowing traversal from port to upstream
             or downstream port and from there to the owning module (or graph vertex).
             </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.ActorRefBackpressureSinkStage`1">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IBuffer`1">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.FixedSizeBuffer.Create``1(System.Int32)">
             INTERNAL API
            
             Returns a fixed size buffer backed by an array. The buffer implementation DOES NOT check agains overflow or
             underflow, it is the responsibility of the user to track or check the capacity of the buffer before enqueueing
             dequeueing or dropping.
            
             Returns a specialized instance for power-of-two sized buffers.
        </member>
        <member name="T:Akka.Streams.Implementation.BoundedBuffer`1">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.EnumerableActorName">
            <summary>
            Generator of sequentially numbered actor names.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.OutputBunch`1.AllOfMarkedOutputs">
            <summary>
            Will only transfer an element when all marked outputs
            have demand, and will complete as soon as any of the marked
            outputs have canceled.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.OutputBunch`1.AnyOfMarkedOutputs">
            <summary>
            Will transfer an element when any of the  marked outputs
            have demand, and will complete when all of the marked
            outputs have canceled.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.FanOut">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.FanOut`1">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Unzip">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Unzip`1">
            <summary>
            INTERNAL API
            TODO Find out where this class will be used and check if the type parameter fit
            since we need to cast messages into a tuple and therefore maybe need aditional type parameters
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.GraphInterpreterShell._eventLimit">
            <summary>
            Limits the number of events processed by the interpreter before scheduling
            a self-message for fairness with other actors. The basic assumption here is
            to give each input buffer slot a chance to run through the whole pipeline
            and back (for the elements).
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreterShell.TryAbort(System.Exception)">
            Attempts to abort execution, by first propagating the reason given until either
             - the interpreter successfully finishes
             - the event limit is reached
             - a new error is encountered
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Fusing.Aggressive``2(Akka.Streams.IGraph{``0,``1})">
            <summary>
            Fuse everything that is not forbidden via AsyncBoundary attribute.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Fusing.Fuse(Akka.Streams.Implementation.Fusing.BuildStructuralInfo)">
            <summary>
            Take the fusable islands identified by <see cref="M:Akka.Streams.Implementation.Fusing.Fusing.Descend``1(Akka.Streams.Implementation.IModule,Akka.Streams.Attributes,Akka.Streams.Implementation.Fusing.BuildStructuralInfo,System.Collections.Generic.ISet{Akka.Streams.Implementation.IModule},System.Int32)"/> in the <see cref="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.Groups"/> list 
            and execute their fusion; only fusable islands will have multiple modules in their set.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Fusing.FuseGroup(Akka.Streams.Implementation.Fusing.BuildStructuralInfo,System.Collections.Generic.ISet{Akka.Streams.Implementation.IModule})">
            <summary>
            Transform a set of GraphStageModules into a single GraphModule. This is done
            by performing a traversal of all their Inlets, sorting them into those without
            internal connections(the exposed inlets) and those with internal connections
            (where the corresponding Outlet is recorded in a map so that it will be wired
            to the same slot number in the GraphAssembly). Then all Outlets are traversed,
            completing internal connections using the aforementioned maps and appending
            the others to the list of exposed Outlets.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Fusing.Descend``1(Akka.Streams.Implementation.IModule,Akka.Streams.Attributes,Akka.Streams.Implementation.Fusing.BuildStructuralInfo,System.Collections.Generic.ISet{Akka.Streams.Implementation.IModule},System.Int32)">
            <summary>
            This is a normalization step for the graph that also collects the needed
            information for later fusing. The goal is to transform an arbitrarily deep
            module tree into one that has exactly two levels: all direct submodules are
            CopiedModules where each contains exactly one atomic module. This way all
            modules have their own identity and all necessary port copies have been
            made. The upstreams/downstreams in the BuildStructuralInfo are rewritten
            to point to the shapes of the copied modules.
            
            The materialized value computation is rewritten as well in that all
            leaf nodes point to the copied modules and all nested computations are
            â€œinlinedâ€, resulting in only one big computation tree for the whole
            normalized overall module. The contained MaterializedValueSource stages
            are also rewritten to point to the copied MaterializedValueNodes. This
            correspondence is then used during materialization to trigger these sources
            when â€œtheirâ€ node has received its value.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Fusing.RewriteMaterializer(System.Collections.Generic.IDictionary{Akka.Streams.Implementation.IModule,Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode},Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode,System.Collections.Generic.Dictionary{Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode,Akka.Streams.Implementation.StreamLayout.IMaterializedValueNode})">
            <summary>
            Given a mapping from old modules to new MaterializedValueNode, rewrite the given
            computation while also populating a mapping from old computation nodes to new ones.
            That mapping is needed to rewrite the MaterializedValueSource stages later-on in
            descend().
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.Fusing.GetDispatcher(Akka.Streams.Implementation.IModule)">
            <summary>
            Figure out the dispatcher setting of a module.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.BuildStructuralInfo">
            <summary>
            Collect structural information about a module tree while descending into it and performing normalization.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.Modules">
            <summary>
            The set of all contained modules.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.Groups">
            <summary>
            The list of all groups of modules that are within each async boundary.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.OutGroups">
            <summary>
            A mapping from OutPort to its containing group, needed when determining whether an upstream connection is internal or not.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.NewInputs">
            <summary>
            A stack of mappings for a given non-copied InPort.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.NewOutputs">
            <summary>
            A stack of mappings for a given non-copied OutPort.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.Downstreams">
            <summary>
            The downstreams relationships of the original module rewritten in terms of the copied ports.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.Upstreams">
            <summary>
            The upstreams relationships of the original module rewritten in terms of the copied ports.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.InOwners">
            <summary>
            The owner mapping for the copied InPorts.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.OutOwners">
            <summary>
            The owner mapping for the copied OutPorts.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.InternalOuts">
            <summary>
            List of internal wirings of GraphModules that were incorporated.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.Fusing.BuildStructuralInfo._materializedSources">
            <summary>
            A stack of materialized value sources, grouped by materialized computation context.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.BreakUpGroupsByDispatcher">
            <summary>
            Fusable groups may contain modules with differing dispatchers, in which case the group needs to be broken up.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.RegisterInternal(Akka.Streams.Shape,System.Int32)">
            <summary>
            Register the outlets of the given Shape as sources for internal connections within imported 
            (and not dissolved) GraphModules. See also the comment in addModule where this is partially undone.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.RemoveInternalWires">
            <summary>
            Remove wirings that belong to the fused stages contained in GraphModules that were incorporated in this fusing run.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.CreateGroup(System.Int32)">
            <summary>
            Create and return a new grouping (i.e. an AsyncBoundary-delimited context)
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.AddModule(Akka.Streams.Implementation.IModule,System.Collections.Generic.ISet{Akka.Streams.Implementation.IModule},Akka.Streams.Attributes,System.Int32,Akka.Streams.Shape)">
            <summary>
            Add a module to the given group, performing normalization (i.e. giving it a unique port identity).
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.Wire(Akka.Streams.OutPort,Akka.Streams.InPort,System.Int32)">
            <summary>
            Record a wiring between two copied ports, using (and reducing) the port mappings.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.Rewire(Akka.Streams.Shape,Akka.Streams.Shape,System.Int32)">
            <summary>
            Replace all mappings for a given shape with its new (copied) form.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.NewInlets(System.Collections.Generic.IEnumerable{Akka.Streams.Inlet})">
            <summary>
            Transform original into copied Inlets.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.NewOutlets(System.Collections.Generic.IEnumerable{Akka.Streams.Outlet})">
            <summary>
            Transform original into copied Outlets.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.BuildStructuralInfo.GetRealModule(Akka.Streams.Implementation.IModule)">
            <summary>
            See through copied modules to the â€œrealâ€ module.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.GraphAssembly">
             INTERNAL API
            
             A GraphAssembly represents a small stream processing graph to be executed by the interpreter. Instances of this
             class **must not** be mutated after construction.
            
             The array ``originalAttributes`` may contain the attribute information of the original atomic module, otherwise
             it must contain a none (otherwise the enclosing module could not overwrite attributes defined in this array).
            
             The arrays [[ins]] and [[outs]] correspond to the notion of a *connection* in the [[GraphInterpreter]]. Each slot
             *i* contains the input and output port corresponding to connection *i*. Slots where the graph is not closed (i.e.
             ports are exposed to the external world) are marked with *null* values. For example if an input port *p* is
             exposed, then outs(p) will contain a *null*.
            
             The arrays [[inOwners]] and [[outOwners]] are lookup tables from a connection id (the index of the slot)
             to a slot in the [[stages]] array, indicating which stage is the owner of the given input or output port.
             Slots which would correspond to non-existent stages (where the corresponding port is null since it represents
             the currently unknown external context) contain the value [[GraphInterpreter#Boundary]].
            
             The current assumption by the infrastructure is that the layout of these arrays looks like this:
            
                        +---------------------------------------+-----------------+
             inOwners:  | index to stages array                 | Boundary (-1)   |
                        +----------------+----------------------+-----------------+
             ins:       | exposed inputs | internal connections | nulls           |
                        +----------------+----------------------+-----------------+
             outs:      | nulls          | internal connections | exposed outputs |
                        +----------------+----------------------+-----------------+
             outOwners: | Boundary (-1)  | index to stages array                  |
                        +----------------+----------------------------------------+
            
             In addition, it is also assumed by the infrastructure that the order of exposed inputs and outputs in the
             corresponding segments of these arrays matches the exact same order of the ports in the [[Shape]].
            
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphAssembly.Materialize(Akka.Streams.Attributes,Akka.Streams.Implementation.IModule[],System.Collections.Generic.IDictionary{Akka.Streams.Implementation.IModule,System.Object},System.Action{Akka.Streams.Implementation.Fusing.IMaterializedValueSource})">
             Takes an interpreter and returns three arrays required by the interpreter containing the input, output port
             handlers and the stage logic instances.
            
             Returns a tuple of
              - lookup table for InHandlers
              - lookup table for OutHandlers
              - array of the logics
              - materialized value
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.GraphInterpreter">
             INTERNAL API
            
             From an external viewpoint, the GraphInterpreter takes an assembly of graph processing stages encoded as a
             [[GraphInterpreter#GraphAssembly]] object and provides facilities to execute and interact with this assembly.
             The lifecycle of the Interpreter is roughly the following:
              - Boundary logics are attached via [[attachDownstreamBoundary()]] and [[attachUpstreamBoundary()]]
              - [[init()]] is called
              - [[execute()]] is called whenever there is need for execution, providing an upper limit on the processed events
              - [[finish()]] is called before the interpreter is disposed, preferably after [[isCompleted]] returned true, although
                in abort cases this is not strictly necessary
            
             The [[execute()]] method of the interpreter accepts an upper bound on the events it will process. After this limit
             is reached or there are no more pending events to be processed, the call returns. It is possible to inspect
             if there are unprocessed events left via the [[isSuspended]] method. [[isCompleted]] returns true once all stages
             reported completion inside the interpreter.
            
             The internal architecture of the interpreter is based on the usage of arrays and optimized for reducing allocations
             on the hot paths.
            
             One of the basic abstractions inside the interpreter is the notion of *connection*. In the abstract sense a
             connection represents an output-input port pair (an analogue for a connected RS Publisher-Subscriber pair),
             while in the practical sense a connection is a number which represents slots in certain arrays.
             In particular
              - portStates contains a bitfield that tracks the states of the ports (output-input) corresponding to this
                connection. This bitfield is used to decode the event that is in-flight.
              - connectionSlots is a mapping from a connection id to a potential element or exception that accompanies the
                event encoded in the portStates bitfield
              - inHandlers is a mapping from a connection id to the [[InHandler]] instance that handles the events corresponding
                to the input port of the connection
              - outHandlers is a mapping from a connection id to the [[OutHandler]] instance that handles the events corresponding
                to the output port of the connection
            
             On top of these lookup tables there is an eventQueue, represented as a circular buffer of integers. The integers
             it contains represents connections that have pending events to be processed. The pending event itself is encoded
             in the portStates bitfield. This implies that there can be only one event in flight for a given connection, which
             is true in almost all cases, except a complete-after-push or fail-after-push.
            
             The layout of the portStates bitfield is the following:
            
                         |- state machn.-| Only one bit is hot among these bits
              64  32  16 | 8   4   2   1 |
             +---+---+---|---+---+---+---|
               |   |   |   |   |   |   |
               |   |   |   |   |   |   |  From the following flags only one is active in any given time. These bits encode
               |   |   |   |   |   |   |  state machine states, and they are "moved" around using XOR masks to keep other bits
               |   |   |   |   |   |   |  intact.
               |   |   |   |   |   |   |
               |   |   |   |   |   |   +- InReady:  The input port is ready to be pulled
               |   |   |   |   |   +----- Pulling:  A pull is active, but have not arrived yet (queued)
               |   |   |   |   +--------- Pushing:  A push is active, but have not arrived yet (queued)
               |   |   |   +------------- OutReady: The output port is ready to be pushed
               |   |   |
               |   |   +----------------- InClosed:  The input port is closed and will not receive any events.
               |   |                                 A push might be still in flight which will be then processed first.
               |   +--------------------- OutClosed: The output port is closed and will not receive any events.
               +------------------------- InFailed:  Always set in conjunction with InClosed. Indicates that the close event
                                                     is a failure
            
             Sending an event is usually the following sequence:
              - An action is requested by a stage logic (push, pull, complete, etc.)
              - the state machine in portStates is transitioned from a ready state to a pending event
              - the id of the affected connection is enqueued
            
             Receiving an event is usually the following sequence:
              - id of connection to be processed is dequeued
              - the type of the event is determined from the bits set on portStates
              - the state machine in portStates is transitioned to a ready state
              - using the inHandlers/outHandlers table the corresponding callback is called on the stage logic.
            
             Because of the FIFO construction of the queue the interpreter is fair, i.e. a pending event is always executed
             after a bounded number of other events. This property, together with suspendability means that even infinite cycles can
             be modeled, or even dissolved (if preempted and a "stealing" external event is injected; for example the non-cycle
             edge of a balance is pulled, dissolving the original cycle).
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.GraphInterpreter.Empty">
            <summary>
            Marker object that indicates that a port holds no element since it was already grabbed. 
            The port is still pullable, but there is no more element to grab.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.AttachUpstreamBoundary(System.Int32,Akka.Streams.Implementation.Fusing.GraphInterpreter.UpstreamBoundaryStageLogic)">
            <summary>
            Assign the boundary logic to a given connection. This will serve as the interface to the external world
            (outside the interpreter) to process and inject events.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.AttachDownstreamBoundary(System.Int32,Akka.Streams.Implementation.Fusing.GraphInterpreter.DownstreamBoundaryStageLogic)">
            <summary>
            Assign the boundary logic to a given connection. This will serve as the interface to the external world
            (outside the interpreter) to process and inject events.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.SetHandler(System.Int32,Akka.Streams.Stage.IInHandler)">
            <summary>
            Dynamic handler changes are communicated from a GraphStageLogic by this method.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.SetHandler(System.Int32,Akka.Streams.Stage.IOutHandler)">
            <summary>
            Dynamic handler changes are communicated from a GraphStageLogic by this method.
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.IsSuspended">
            <summary>
            Returns true if there are pending unprocessed events in the event queue.
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.IsCompleted">
            <summary>
            Returns true if there are no more running stages and pending events.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.Init(Akka.Streams.IMaterializer)">
            <summary>
            Initializes the states of all the stage logics by calling <see cref="M:Akka.Streams.Stage.GraphStageLogic.PreStart"/>.
            The passed-in materializer is intended to be a <see cref="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.SubFusingMaterializer"/>
            that avoids creating new Actors when stages materialize sub-flows.If no
            such materializer is available, passing in null will reuse the normal
            materializer for the GraphInterpreterâ€”fusing is only an optimization.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.Finish">
            <summary>
            Finalizes the state of all stages by calling <see cref="M:Akka.Streams.Stage.GraphStageLogic.PostStop"/> (if necessary).
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.Execute(System.Int32)">
            <summary>
            Executes pending events until the given limit is met. If there were remaining events, <see cref="P:Akka.Streams.Implementation.Fusing.GraphInterpreter.IsSuspended"/> will return true.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.ProcessEvent(System.Int32)">
            <summary>
            Decodes and processes a single event for the given connection
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.IsStageCompleted(Akka.Streams.Stage.GraphStageLogic)">
            <summary>
            Returns true if the given stage is alredy completed
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.CompleteConnection(System.Int32)">
            <summary>
             Register that a connection in which the given stage participated has been completed and therefore the stage itself might stop, too.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphInterpreter.DumpWaits">
            <summary>
            Debug utility to dump the "waits-on" relationships in DOT format to the console for analysis of deadlocks.
            
            Only invoke this after the interpreter completely settled, otherwise the results might be off. This is a very
            simplistic tool, make sure you are understanding what you are doing and then it will serve you well.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.GraphStages.WithDetachedInputs``2(Akka.Streams.Stage.GraphStage{Akka.Streams.UniformFanInShape{``0,``0}})">
            <summary>
            Fusing graphs that have cycles involving FanIn stages might lead to deadlocks if
            demand is not carefully managed.
            
            This means that FanIn stages need to early pull every relevant input on startup.
            This can either be implemented inside the stage itself, or this method can be used,
            which adds a detacher stage to every input.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.PrefixAndTail`1">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Split">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.Split`1">
            <summary>
            INTERNAL API
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.SubSink">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.SubSink`1">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.SubSource">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.Fusing.SubSource.Kill``2(Akka.Streams.Dsl.Source{``0,``1})">
            <summary>
            INTERNAL API
            
            HERE ACTUALLY ARE DRAGONS, YOU HAVE BEEN WARNED!
            
            FIXME #19240 (jvm)
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Fusing.SubSource`1">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.FilePublisher">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.FileSubscriber">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.InputStreamPublisher">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.InputStreamSinkStage">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.InputStreamAdapter">
            <summary>
            INTERNAL API
            InputStreamAdapter that interacts with InputStreamSinkStage
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.FileSink">
            <summary>
            INTERNAL API
            Creates simple synchronous Sink which writes all incoming elements to the given file
            (creating it before hand if necessary).
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.OutputStreamSink">
            <summary>
            INTERNAL API
            Creates simple synchronous  Sink which writes all incoming elements to the given file
            (creating it before hand if necessary).
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.FileSource">
            <summary>
            INTERNAL API
            Creates simple synchronous Source backed by the given file.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.InputStreamSource">
            <summary>
            INTERNAL API
            Source backed by the given input stream.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.OutputStreamSourceStage">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.OutputStreamSubscriber">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.ConnectionSourceStage">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.IncomingConnectionStage">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.TcpConnectionStage">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IO.OutgoingConnectionStage">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.SubscriberSource`1">
            <summary>
            Holds a `Subscriber` representing the input side of the flow. The `Subscriber` can later be connected to an upstream `Publisher`.
            </summary>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="T:Akka.Streams.Implementation.PublisherSource`1">
            <summary>
            Construct a transformation starting with given publisher. The transformation steps are executed 
            by a series of <see cref="T:System.Reactive.Streams.IProcessor`2"/> instances that mediate the flow of elements 
            downstream and the propagation of back-pressure upstream.
            </summary>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="T:Akka.Streams.Implementation.ActorPublisherSource`1">
            <summary>
            Creates and wraps an actor into <see cref="T:System.Reactive.Streams.IPublisher`1"/> from the given <see cref="T:Akka.Actor.Props"/>, which should be props for an <see cref="T:Akka.Streams.Implementation.ActorPublisher`1"/>.
            </summary>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="T:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1">
            INTERNAL API
            A mutable RingBuffer that can grow in size and supports multiple readers.
            Contrary to many other ring buffer implementations this one does not automatically overwrite the oldest
            elements, rather, if full, the buffer tries to grow and rejects further writes if max capacity is reached.
        </member>
        <member name="P:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.Length">
            The number of elements currently in the buffer.
        </member>
        <member name="P:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.ImmediatellyAvailable">
            The number of elements the buffer can still take without having to be resized.
        </member>
        <member name="P:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.CapacityLeft">
            The maximum number of elements the buffer can still take.
        </member>
        <member name="M:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.Count(Akka.Streams.Implementation.ICursor)">
            Returns the number of elements that the buffer currently contains for the given cursor.
        </member>
        <member name="M:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.InitCursor(Akka.Streams.Implementation.ICursor)">
            Initializes the given Cursor to the oldest buffer entry that is still available.
        </member>
        <member name="M:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.Write(`0)">
            Tries to write the given value into the buffer thereby potentially growing the backing array.
            Returns `true` if the write was successful and false if the buffer is full and cannot grow anymore.
        </member>
        <member name="M:Akka.Streams.Implementation.ResizableMultiReaderRingBuffer`1.Read(Akka.Streams.Implementation.ICursor)">
            Tries to read from the buffer using the given Cursor.
            If there are no more data to be read (i.e. the cursor is already
            at writeIx) the method throws ResizableMultiReaderRingBuffer.NothingToReadException!
        </member>
        <member name="T:Akka.Streams.Implementation.SinkholeSubscriber`1">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.PublisherSink`1">
            <summary>
            INTERNAL API
            Holds the downstream-most <see cref="T:System.Reactive.Streams.IPublisher`1"/> interface of the materialized flow.
            The stream will not have any subscribers attached at this point, which means that after prefetching
            elements to fill the internal buffers it will assert back-pressure until
            a subscriber connects and creates demand for elements to be emitted.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.FanoutPublisherSink`1">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.SinkholeSink`1">
            <summary>
            INTERNAL API
            Attaches a subscriber to this stream which will just discard all received elements.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.SubscriberSink`1">
            <summary>
            INTERNAL API
            Attaches a subscriber to this stream.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.CancelSink`1">
            <summary>
            INTERNAL API
            A sink that immediately cancels its upstream upon materialization.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.ActorSubscriberSink`1">
            <summary>
            INTERNAL API
            Creates and wraps an actor into <see cref="T:System.Reactive.Streams.ISubscriber`1"/> from the given <see cref="T:Akka.Actor.Props"/>,
            which should be <see cref="T:Akka.Actor.Props"/> for an <see cref="T:Akka.Streams.Actors.ActorSubscriber"/>.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.ActorRefSink`1">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.MultiStreamOutputProcessor`1.HandleSubscriptionTimeout(System.Reactive.Streams.IPublisher,System.Exception)">
            <summary>
            Callback that should ensure that the target is canceled with the given cause.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubFlowImpl`4.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            Change the attributes of this <see cref="T:Akka.Streams.Dsl.Flow`3"/> to the given ones. Note that this
            operation has no effect on an empty Flow (because the attributes apply
            only to the contained processing stages).
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.Timers">
            <summary>
            INTERNAL API
            
            Various stages for controlling timeouts on IO related streams (although not necessarily).
            
            The common theme among the processing stages here that
             - they wait for certain event or events to happen
             - they have a timer that may fire before these events
             - if the timer fires before the event happens, these stages all fail the stream
             - otherwise, these streams do not interfere with the element flow, ordinary completion or failure
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.ActorProcessorImpl.Receive(System.Object)">
            Subclass may override [[#activeReceive]]
        </member>
        <member name="T:Akka.Streams.Implementation.ActorPublisher`1">
             INTERNAL API
            
             When you instantiate this class, or its subclasses, you MUST send an ExposedPublisher message to the wrapped
             ActorRef! If you don't need to subclass, prefer the apply() method on the companion object which takes care of this.
        </member>
        <member name="T:Akka.Streams.Implementation.Stages.SymbolicGraphStage`2">
            <summary>
            Stage that is backed by a GraphStage but can be symbolically introspected
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IModule.ReplaceShape(Akka.Streams.Shape)">
            <summary>
            Verify that the given Shape has the same ports and return a new module with that shape.
            Concrete implementations may throw UnsupportedOperationException where applicable.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IModule.Fuse(Akka.Streams.Implementation.IModule,Akka.Streams.OutPort,Akka.Streams.InPort)">
            <summary>
            Fuses this Module to <paramref name="that"/> Module by wiring together <paramref name="from"/> and <paramref name="to"/>,
            retaining the materialized value of `this` in the result
            </summary>
            <param name="that">A module to fuse with</param>
            <param name="from">The data source to wire</param>
            <param name="to">The data sink to wire</param>
            <returns>A module representing fusion of `this` and <paramref name="that"/></returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IModule.Fuse``3(Akka.Streams.Implementation.IModule,Akka.Streams.OutPort,Akka.Streams.InPort,System.Func{``0,``1,``2})">
            <summary>
            Fuses this Module to <paramref name="that"/> Module by wiring together <paramref name="from"/> and <paramref name="to"/>,
            retaining the materialized value of `this` in the result, using the provided function <paramref name="matFunc"/>.
            </summary>
            <param name="that">A module to fuse with</param>
            <param name="from">The data source to wire</param>
            <param name="to">The data sink to wire</param>
            <param name="matFunc">The function to apply to the materialized values</param>
            <returns>A module representing fusion of `this` and <paramref name="that"/></returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IModule.Wire(Akka.Streams.OutPort,Akka.Streams.InPort)">
            <summary>
            Creates a new Module based on the current Module but with the given OutPort wired to the given InPort.
            </summary>
            <param name="from">The OutPort to wire.</param>
            <param name="to">The InPort to wire.</param>
            <returns>A new Module with the ports wired</returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IModule.Compose(Akka.Streams.Implementation.IModule)">
            <summary>
            Creates a new Module which is `this` Module composed with <paramref name="that"/> Module.
            </summary>
            <param name="that">A Module to be composed with (cannot be itself)</param>
            <returns>A Module that represents the composition of `this` and <paramref name="that"/></returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IModule.Compose``3(Akka.Streams.Implementation.IModule,System.Func{``0,``1,``2})">
            <summary>
            Creates a new Module which is `this` Module composed with <paramref name="that"/> Module,
            using the given function <paramref name="matFunc"/> to compose the materialized value of `this` with
            the materialized value of <paramref name="that"/>.
            </summary>
            <param name="that">A Module to be composed with (cannot be itself)</param>
            <param name="matFunc">A function which combines the materialized values</param>
            <typeparam name="T1">The type of the materialized value of `this`</typeparam>
            <typeparam name="T2">The type of the materialized value of <paramref name="that"/></typeparam>
            <typeparam name="T3">The type of the materialized value of the returned Module</typeparam>
            <returns>A Module that represents the composition of `this` and <paramref name="that"/></returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IModule.ComposeNoMaterialized(Akka.Streams.Implementation.IModule)">
             <summary>
             Creates a new Module which is `this` Module composed with <paramref name="that"/> Module.
            
             The difference to compose(that) is that this version completely ignores the materialized value
             computation of <paramref name="that"/> while the normal version executes the computation and discards its result.
             This means that this version must not be used for user-provided <paramref name="that"/> modules because users may
             transform materialized values only to achieve some side-effect; it can only be
             used where we know that there is no meaningful computation to be done (like for
             MaterializedValueSource).
             </summary>
             <param name="that">a Module to be composed with (cannot be itself)</param>
             <returns>a Module that represents the composition of `this` and <paramref name="that"/></returns>
        </member>
        <member name="M:Akka.Streams.Implementation.IModule.Nest">
            <summary>
            Creates a new Module which contains `this` Module
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.AtomicModule">
            <summary>
            This is the only extension point for the sealed type hierarchy: composition
            (i.e. the module tree) is managed strictly within this file, only leaf nodes
            may be declared elsewhere.
            </summary>
        </member>
        <member name="F:Akka.Streams.Implementation.MaterializerSession._moduleStack">
             <summary>
             Please note that this stack keeps track of the scoped modules wrapped in CopiedModule but not the CopiedModule
             itself. The reason is that the CopiedModule itself is only needed for the enterScope and exitScope methods but
             not elsewhere. For this reason they are just simply passed as parameters to those methods.
            
             The reason why the encapsulated (copied) modules are stored as mutable state to save subclasses of this class
             from passing the current scope around or even knowing about it.
             </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.MaterializerSession.EnterScope(Akka.Streams.Implementation.CopiedModule)">
            <summary>
             Enters a copied module and establishes a scope that prevents internals to leak out and interfere with copies
             of the same module.
             We don't store the enclosing CopiedModule itself as state since we don't use it anywhere else than exit and enter
             </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.MaterializerSession.ExitScope(Akka.Streams.Implementation.CopiedModule)">
            <summary>
            Exits the scope of the copied module and propagates Publishers/Subscribers to the enclosing scope assigning
            them to the copied ports instead of the original ones (since there might be multiple copies of the same module
            leading to port identity collisions)
            We don't store the enclosing CopiedModule itself as state since we don't use it anywhere else than exit and enter
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.CancelingSubscriber`1">
            <summary>
            A subscriber who calls <see cref="M:System.Reactive.Streams.ISubscription.Cancel"/> directly from <see cref="M:Akka.Streams.Implementation.CancelingSubscriber`1.OnSubscribe(System.Reactive.Streams.ISubscription)"/> and ignores all other callbacks.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.NoopSubscriptionTimeout">
            <summary>
            INTERNAL API
            
            Subscription timeout which does not start any scheduled events and always returns `true`.
            This specialized implementation is to be used for "noop" timeout mode.
            </summary>
        </member>
        <member name="T:Akka.Streams.Implementation.IStreamSubscriptionTimeoutSupport">
            <summary>
            INTERNAL API
            Provides support methods to create Publishers and Subscribers which time-out gracefully,
            and are cancelled subscribing an <see cref="T:Akka.Streams.Implementation.CancellingSubscriber`1"/> to the publisher, or by calling `onError` on the timed-out subscriber.
            
            See `akka.stream.materializer.subscription-timeout` for configuration options.
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.IStreamSubscriptionTimeoutSupport.SubscriptionTimeoutSettings">
            <summary>
            Default settings for subscription timeouts.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IStreamSubscriptionTimeoutSupport.ScheduleSubscriptionTimeout(Akka.Actor.IActorRef,System.Object)">
            <summary>
            Schedules a Subscription timeout.
            The actor will receive the message created by the provided block if the timeout triggers.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IStreamSubscriptionTimeoutSupport.SubscriptionTimedOut(System.Reactive.Streams.IPublisher)">
            <summary>
            Called by the actor when a subscription has timed out. Expects the actual <see cref="T:System.Reactive.Streams.IPublisher"/> or <see cref="T:System.Reactive.Streams.IProcessor`2"/> target.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.IStreamSubscriptionTimeoutSupport.HandleSubscriptionTimeout(System.Reactive.Streams.IPublisher,System.Exception)">
            <summary>
            Callback that should ensure that the target is canceled with the given cause.
            </summary>
        </member>
        <member name="P:Akka.Streams.Implementation.ISubscriptionWithCursor`1.TotalDemand">
            <summary>
             Do not increment directly, use <see cref="M:Akka.Streams.Implementation.SubscriberManagement`1.MoreRequested(Akka.Streams.Implementation.ISubscriptionWithCursor{`0},System.Int64)"/> instead (it provides overflow protection)!
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.RequestFromUpstream(System.Int64)">
            <summary>
            Called when we are ready to consume more elements from our upstream.
            MUST NOT call <see cref="M:Akka.Streams.Implementation.SubscriberManagement`1.PushToDownstream(`0)"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.CancelUpstream">
            <summary>
            Called before <see cref="M:Akka.Streams.Implementation.SubscriberManagement`1.Shutdown(System.Boolean)"/> if the stream is *not* being regularly completed
            but shut-down due to the last subscriber having cancelled its subscription
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.Shutdown(System.Boolean)">
            <summary>
            Called when the spi.Publisher/Processor is ready to be shut down.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.CreateSubscription(System.Reactive.Streams.ISubscriber{`0})">
            <summary>
            Use to register a subscriber
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.MoreRequested(Akka.Streams.Implementation.ISubscriptionWithCursor{`0},System.Int64)">
            <summary>
            More demand was signaled from a given subscriber.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.PushToDownstream(`0)">
            <summary>
            This method must be called by the implementing class whenever a new value is available to be pushed downstream.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.CompleteDownstream">
            <summary>
            This method must be called by the implementing class whenever
            it has been determined that no more elements will be produced
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.AbortDownstream(System.Exception)">
            <summary>
            This method must be called by the implementing class to push an error downstream.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.RegisterSubscriber(System.Reactive.Streams.ISubscriber)">
            <summary>
            Register a new subscriber.
            </summary>
        </member>
        <member name="M:Akka.Streams.Implementation.SubscriberManagement`1.UnregisterSubscription(Akka.Streams.Implementation.ISubscriptionWithCursor{`0})">
            <summary>
            Called from <see cref="M:System.Reactive.Streams.ISubscription.Cancel"/>, i.e. from another thread,
            override to add synchronization with itself, <see cref="T:Akka.Streams.Actors.Subscribe`1"/> and <see cref="M:Akka.Streams.Implementation.SubscriberManagement`1.MoreRequested(Akka.Streams.Implementation.ISubscriptionWithCursor{`0},System.Int64)"/>
            </summary>
        </member>
        <member name="T:Akka.Streams.IO.IOResult">
            <summary>
            Holds a result of an IO operation.
            </summary>
        </member>
        <member name="M:Akka.Streams.IO.IOResult.#ctor(System.Int64,Akka.Util.Result{System.Reactive.Streams.Unit})">
            <summary>
            Creates a new IOResult.
            </summary>
            <param name="count">Numeric value depending on context, for example IO operations performed or bytes processed.</param>
            <param name="status">Status of the result. Can be either <see cref="T:System.Reactive.Streams.Unit"/> or an exception.</param>
        </member>
        <member name="F:Akka.Streams.IO.IOResult.Count">
            <summary>
            Numeric value depending on context, for example IO operations performed or bytes processed.
            </summary>
        </member>
        <member name="P:Akka.Streams.IO.IOResult.WasSuccessful">
            <summary>
            Indicates whether IO operation completed successfully or not.
            </summary>
        </member>
        <member name="P:Akka.Streams.IO.IOResult.Error">
            <summary>
            If the IO operation resulted in an error, returns the corresponding <see cref="T:System.Exception"/>
            or throws <see cref="T:System.NotSupportedException"/> otherwise.
            </summary>
        </member>
        <member name="T:Akka.Streams.ISourceQueue`1">
            <summary>
            This interface allows to have the queue as a data source for some stream.
            </summary>
        </member>
        <member name="M:Akka.Streams.ISourceQueue`1.OfferAsync(`0)">
            <summary>
            Method offers next element to a stream and returns task that:
            <para>- competes with <see cref="T:Akka.Streams.QueueOfferResult.Enqueued"/> if element
            is consumed by a stream</para>
            <para>- competes with <see cref="T:Akka.Streams.QueueOfferResult.Dropped"/> when stream
            dropped offered element</para>
            <para>- competes with <see cref="T:Akka.Streams.QueueOfferResult.QueueClosed"/> when
            stream is completed while task is active</para>
            <para>- competes with <see cref="T:Akka.Streams.QueueOfferResult.Failure"/> when failure
            to enqueue element from upstream</para>
            <para>- fails if stream is completed or you cannot call offer in this moment
            because of implementation rules (like for backpressure mode and full buffer
            you need to wait for last offer call task completion.</para>
            </summary>
            <param name="element">element to send to a stream</param>
        </member>
        <member name="M:Akka.Streams.ISourceQueue`1.WatchCompletionAsync">
            <summary>
            Method returns task that completes when stream is completed and fails
            when stream failed.
            </summary>
        </member>
        <member name="T:Akka.Streams.ISinkQueue`1">
            <summary>
            Trait allows to have the queue as a sink for some stream.
            "SinkQueue" pulls data from stream with backpressure mechanism.
            </summary>
        </member>
        <member name="M:Akka.Streams.ISinkQueue`1.PullAsync">
            <summary>
            Method pulls elements from stream and returns task that:
            <para>- fails if stream is finished</para>
            <para>- completes with None in case if stream is completed after we got task</para>
            <para>- completes with `Some(element)` in case next element is available from stream.</para>
            </summary>
        </member>
        <member name="M:Akka.Streams.IMaterializer.WithNamePrefix(System.String)">
            <summary>
            The <paramref name="namePrefix"/> shall be used for deriving the names of processing
            entities that are created during materialization. This is meant to aid
            logging and failure reporting both during materialization and while the
            stream is running.
            </summary>
        </member>
        <member name="M:Akka.Streams.IMaterializer.Materialize``1(Akka.Streams.IGraph{Akka.Streams.ClosedShape,``0})">
            <summary>
            This method interprets the given Flow description and creates the running
            stream. The result can be highly implementation specific, ranging from
            local actor chains to remote-deployed processing networks.
            </summary>
        </member>
        <member name="M:Akka.Streams.IMaterializer.ScheduleOnce(System.TimeSpan,System.Action)">
            <summary>
            Interface for stages that need timer services for their functionality. Schedules a
            single task with the given delay.
            </summary>
            <returns>
            A <see cref="T:Akka.Actor.ICancelable"/> that allows cancelling the timer. Cancelling is best effort, 
            if the event has been already enqueued it will not have an effect.
            </returns>
        </member>
        <member name="M:Akka.Streams.IMaterializer.ScheduleRepeatedly(System.TimeSpan,System.TimeSpan,System.Action)">
            <summary>
            Interface for stages that need timer services for their functionality. Schedules a
            repeated task with the given interval between invocations.
            </summary>
            <returns>
            A <see cref="T:Akka.Actor.ICancelable"/> that allows cancelling the timer. Cancelling is best effort, 
            if the event has been already enqueued it will not have an effect.
            </returns>
        </member>
        <member name="P:Akka.Streams.IMaterializer.ExecutionContext">
            <summary>
            Running a flow graph will require execution resources, as will computations
            within Sources, Sinks, etc. This <see cref="T:Akka.Dispatch.MessageDispatcher"/>
            can be used by parts of the flow to submit processing jobs for execution,
            run Future callbacks, etc.
            </summary>
        </member>
        <member name="T:Akka.Streams.MaterializationContext">
            <summary>
            Context parameter to the create methods of sources and sinks.
            </summary>
        </member>
        <member name="T:Akka.Streams.IGraph`1">
            <summary>
            </summary>
            <typeparam name="TShape">Type-level accessor for the shape parameter of this graph.</typeparam>
        </member>
        <member name="P:Akka.Streams.IGraph`1.Shape">
            <summary>
            The shape of a graph is all that is externally visible: its inlets and outlets.
            </summary>
        </member>
        <member name="P:Akka.Streams.IGraph`1.Module">
            <summary>
            INTERNAL API: Every materializable element must be backed by a stream layout module
            </summary>
        </member>
        <member name="T:Akka.Streams.IGraph`2">
            <summary>
            </summary>
            <typeparam name="TShape">Type-level accessor for the shape parameter of this graph.</typeparam>
            <typeparam name="TMaterialized"></typeparam>
        </member>
        <member name="M:Akka.Streams.IGraph`2.WithAttributes(Akka.Streams.Attributes)">
            <summary>
            Change the attributes of this <see cref="T:Akka.Streams.IGraph`1"/> to the given ones
            and seal the list of attributes. This means that further calls will not be able
            to remove these attributes, but instead add new ones. Note that this
            operation has no effect on an empty Flow (because the attributes apply
            only to the contained processing stages).
            </summary>
        </member>
        <member name="M:Akka.Streams.IGraph`2.AddAttributes(Akka.Streams.Attributes)">
            <summary>
            Add the given attributes to this <see cref="T:Akka.Streams.IGraph`1"/>.
            Further calls to <see cref="M:Akka.Streams.IGraph`2.WithAttributes(Akka.Streams.Attributes)"/>
            will not remove these attributes. Note that this
            operation has no effect on an empty Flow (because the attributes apply
            only to the contained processing stages).
            </summary>
        </member>
        <member name="M:Akka.Streams.IGraph`2.Named(System.String)">
            <summary>
            Add a 'name' attribute to this Flow.
            </summary>
        </member>
        <member name="M:Akka.Streams.IGraph`2.Async">
            <summary>
            Put an asynchronous boundary around this Source.
            </summary>
        </member>
        <member name="T:Akka.Streams.Attributes">
            <summary>
            Holds attributes which can be used to alter <see cref="T:Akka.Streams.Dsl.Flow`3"/>
            or <see cref="T:Akka.Streams.Dsl.GraphDsl"/> materialization.
            
            Note that more attributes for the <see cref="T:Akka.Streams.ActorMaterializer"/> are defined in <see cref="T:Akka.Streams.ActorAttributes"/>.
            </summary>
        </member>
        <member name="F:Akka.Streams.Attributes.LogLevels.Off">
            <summary>
            Use to disable logging on certain operations when configuring <see cref="T:Akka.Streams.Attributes.LogLevels"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Attributes.GetAttributeList``1">
            <summary>
            Get all attributes of a given type or subtype thereof
            </summary>
        </member>
        <member name="M:Akka.Streams.Attributes.GetAttribute``1(``0)">
            <summary>
            Get the last (most specific) attribute of a given type or subtype thereof.
            If no such attribute exists the default value is returned.
            </summary>
        </member>
        <member name="M:Akka.Streams.Attributes.GetFirstAttribute``1(``0)">
            <summary>
            Get the first (least specific) attribute of a given type or subtype thereof.
            If no such attribute exists the default value is returned.
            </summary>
        </member>
        <member name="M:Akka.Streams.Attributes.GetAttribute``1">
            <summary>
            Get the last (most specific) attribute of a given type or subtype thereof.
            </summary>
        </member>
        <member name="M:Akka.Streams.Attributes.GetFirstAttribute``1">
            <summary>
            Get the first (least specific) attribute of a given type or subtype thereof.
            </summary>
        </member>
        <member name="M:Akka.Streams.Attributes.And(Akka.Streams.Attributes)">
            <summary>
            Adds given attributes to the end of these attributes.
            </summary>
        </member>
        <member name="M:Akka.Streams.Attributes.And(Akka.Streams.Attributes.IAttribute)">
            <summary>
            Adds given attribute to the end of these attributes.
            </summary>
        </member>
        <member name="M:Akka.Streams.Attributes.GetNameLifted">
            <summary>
            Extracts Name attributes and concatenates them.
            </summary>
        </member>
        <member name="M:Akka.Streams.Attributes.Contains``1(``0)">
            <summary>
            Test whether the given attribute is contained within this attributes list.
            </summary>
        </member>
        <member name="M:Akka.Streams.Attributes.CreateName(System.String)">
            <summary>
            Specifies the name of the operation.
            If the name is null or empty the name is ignored, i.e. <see cref="F:Akka.Streams.Attributes.None"/> is returned.
            </summary>
        </member>
        <member name="M:Akka.Streams.Attributes.CreateInputBuffer(System.Int32,System.Int32)">
            <summary>
            Specifies the initial and maximum size of the input buffer.
            </summary>
        </member>
        <member name="M:Akka.Streams.Attributes.CreateLogLevels(Akka.Event.LogLevel,Akka.Event.LogLevel,Akka.Event.LogLevel)">
            <summary>
             Configures `log()` stage log-levels to be used when logging.
             Logging a certain operation can be completely disabled by using <see cref="F:Akka.Streams.Attributes.LogLevels.Off"/>
            
             Passing in null as any of the arguments sets the level to its default value, which is:
             <see cref="!:LogLevel.DebugLevel"/> for <paramref name="onElement"/> and <paramref name="onFinish"/>, and <see cref="!:LogLevel.ErrorLevel"/> for <paramref name="onError"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Attributes.ExtractName(Akka.Streams.Implementation.IModule,System.String)">
            <summary>
            Compute a name by concatenating all Name attributes that the given module
            has, returning the given default value if none are found.
            </summary>
        </member>
        <member name="T:Akka.Streams.ActorAttributes">
            <summary>
            Attributes for the <see cref="T:Akka.Streams.ActorMaterializer"/>. Note that more attributes defined in <see cref="T:Akka.Streams.ActorAttributes"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.ActorAttributes.CreateDispatcher(System.String)">
            <summary>
            Specifies the name of the dispatcher.
            </summary>
        </member>
        <member name="M:Akka.Streams.ActorAttributes.CreateSupervisionStrategy(Akka.Streams.Supervision.Decider)">
            <summary>
            Specifies the SupervisionStrategy.
            Decides how exceptions from user are to be handled
            </summary>
        </member>
        <member name="T:Akka.Streams.OverflowStrategy">
            <summary>
            Represents a strategy that decides how to deal with a buffer that is full but is about to receive a new element.
            </summary>
        </member>
        <member name="F:Akka.Streams.OverflowStrategy.DropHead">
            <summary>
            If the buffer is full when a new element arrives, drops the oldest element from the buffer to make space for the new element.
            </summary>
        </member>
        <member name="F:Akka.Streams.OverflowStrategy.DropTail">
            <summary>
            If the buffer is full when a new element arrives, drops the youngest element from the buffer to make space for the new element.
            </summary>
        </member>
        <member name="F:Akka.Streams.OverflowStrategy.DropBuffer">
            <summary>
            If the buffer is full when a new element arrives, drops all the buffered elements to make space for the new element.
            </summary>
        </member>
        <member name="F:Akka.Streams.OverflowStrategy.DropNew">
            <summary>
            If the buffer is full when a new element arrives, drops the new element.
            </summary>
        </member>
        <member name="F:Akka.Streams.OverflowStrategy.Backpressure">
            <summary>
            If the buffer is full when a new element is available this strategy backpressures the upstream publisher until space becomes available in the buffer.
            </summary>
        </member>
        <member name="F:Akka.Streams.OverflowStrategy.Fail">
            <summary>
            If the buffer is full when a new element is available this strategy completes the stream with failure.
            </summary>
        </member>
        <member name="F:Akka.Streams.DelayOverflowStrategy.EmitEarly">
            <summary>
            If the buffer is full when a new element is available this strategy send next element downstream without waiting
            </summary>
        </member>
        <member name="F:Akka.Streams.DelayOverflowStrategy.DropHead">
            <summary>
            If the buffer is full when a new element arrives, drops the oldest element from the buffer to make space for the new element.
            </summary>
        </member>
        <member name="F:Akka.Streams.DelayOverflowStrategy.DropTail">
            <summary>
            If the buffer is full when a new element arrives, drops the youngest element from the buffer to make space for the new element.
            </summary>
        </member>
        <member name="F:Akka.Streams.DelayOverflowStrategy.DropBuffer">
            <summary>
            If the buffer is full when a new element arrives, drops all the buffered elements to make space for the new element.
            </summary>
        </member>
        <member name="F:Akka.Streams.DelayOverflowStrategy.DropNew">
            <summary>
            If the buffer is full when a new element arrives, drops the new element.
            </summary>
        </member>
        <member name="F:Akka.Streams.DelayOverflowStrategy.Backpressure">
            <summary>
            If the buffer is full when a new element is available this strategy backpressures the upstream publisher until space becomes available in the buffer.
            </summary>
        </member>
        <member name="F:Akka.Streams.DelayOverflowStrategy.Fail">
            <summary>
            If the buffer is full when a new element is available this strategy completes the stream with failure.
            </summary>
        </member>
        <member name="T:Akka.Streams.IQueueOfferResult">
            <summary>
            Used as return type for async callbacks to streams
            </summary>
        </member>
        <member name="T:Akka.Streams.InPort">
            <summary>
            An input port of a <see cref="T:Akka.Streams.Implementation.IModule"/>. This type logically belongs
            into the impl package but must live here due to how `sealed` works.
            It is also used in the Java DSL for â€œuntyped Inletsâ€ as a work-around
            for otherwise unreasonable existential types.
            </summary>
        </member>
        <member name="T:Akka.Streams.OutPort">
            <summary>
            An output port of a StreamLayout.Module. This type logically belongs
            into the impl package but must live here due to how `sealed` works.
            It is also used in the Java DSL for â€œuntyped Outletsâ€ as a work-around
            for otherwise unreasonable existential types.
            </summary>
        </member>
        <member name="T:Akka.Streams.Inlet">
            <summary>
            An Inlet is a typed input to a Shape. Its partner in the Module view 
            is the InPort(which does not bear an element type because Modules only 
            express the internal structural hierarchy of stream topologies).
            </summary>
        </member>
        <member name="T:Akka.Streams.Outlet">
            <summary>
            An Outlet is a typed output to a Shape. Its partner in the Module view
            is the OutPort(which does not bear an element type because Modules only
            express the internal structural hierarchy of stream topologies).
            </summary>
        </member>
        <member name="T:Akka.Streams.Shape">
            <summary>
            A Shape describes the inlets and outlets of a [[Graph]]. In keeping with the
            philosophy that a Graph is a freely reusable blueprint, everything that
            matters from the outside are the connections that can be made with it,
            otherwise it is just a black box.
            </summary>
        </member>
        <member name="P:Akka.Streams.Shape.Inlets">
            <summary>
            Gets list of all input ports.
            </summary>
        </member>
        <member name="P:Akka.Streams.Shape.Outlets">
            <summary>
            Gets list of all output ports.
            </summary>
        </member>
        <member name="M:Akka.Streams.Shape.DeepCopy">
            <summary>
            Create a copy of this Shape object, returning the same type as the
            original; this constraint can unfortunately not be expressed in the
            type system.
            </summary>
        </member>
        <member name="M:Akka.Streams.Shape.CopyFromPorts(System.Collections.Immutable.ImmutableArray{Akka.Streams.Inlet},System.Collections.Immutable.ImmutableArray{Akka.Streams.Outlet})">
            <summary>
            Create a copy of this Shape object, returning the same type as the
            original but containing the ports given within the passed-in Shape.
            </summary>
        </member>
        <member name="M:Akka.Streams.Shape.HasSamePortsAs(Akka.Streams.Shape)">
            <summary>
            Compare this to another shape and determine whether the set of ports is the same (ignoring their ordering).
            </summary>
        </member>
        <member name="M:Akka.Streams.Shape.HasSamePortsAndShapeAs(Akka.Streams.Shape)">
            <summary>
            Compare this to another shape and determine whether the arrangement of ports is the same (including their ordering).
            </summary>
        </member>
        <member name="T:Akka.Streams.ClosedShape">
            <summary>
            This <see cref="T:Akka.Streams.Shape"/> is used for graphs that have neither open inputs nor open
            outputs. Only such a <see cref="T:Akka.Streams.IGraph`2"/> can be materialized by a <see cref="T:Akka.Streams.IMaterializer"/>.
            </summary>
        </member>
        <member name="T:Akka.Streams.AmorphousShape">
            <summary>
            This type of <see cref="T:Akka.Streams.Shape"/> can express any number of inputs and outputs at the
            expense of forgetting about their specific types. It is used mainly in the
            implementation of the <see cref="T:Akka.Streams.IGraph`2"/> builders and typically replaced by a more
            meaningful type of Shape when the building is finished.
            </summary>
        </member>
        <member name="T:Akka.Streams.SourceShape`1">
            <summary>
            A Source <see cref="T:Akka.Streams.Shape"/> has exactly one output and no inputs, it models a source of data.
            </summary>
        </member>
        <member name="T:Akka.Streams.FlowShape`2">
            <summary>
            A Flow <see cref="T:Akka.Streams.Shape"/> has exactly one input and one output, it looks from the
            outside like a pipe (but it can be a complex topology of streams within of course).
            </summary>
        </member>
        <member name="T:Akka.Streams.SinkShape`1">
            <summary>
            A Sink <see cref="T:Akka.Streams.Shape"/> has exactly one input and no outputs, it models a data sink.
            </summary>
        </member>
        <member name="T:Akka.Streams.BidiShape`4">
            <summary>
            A bidirectional flow of elements that consequently has two inputs and two outputs.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`2.PreStart(Akka.Streams.Stage.ILifecycleContext)">
            <summary>
            User overridable callback.
            <para>
            It is called before any other method defined on the <see cref="T:Akka.Streams.Stage.IStage`2"/>.
            Empty default implementation.
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`2.OnPush(`0,Akka.Streams.Stage.IContext)">
            <summary>
            <para>
            This method is called when an element from upstream is available and there is demand from downstream, i.e.
            in <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPush(`0,Akka.Streams.Stage.IContext)"/> you are allowed to call <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/> to emit one element downstreams,
            or you can absorb the element by calling <see cref="M:Akka.Streams.Stage.IContext.Pull"/>. Note that you can only
            emit zero or one element downstream from <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/>.
            </para>
            <para>
            To emit more than one element you have to push the remaining elements from <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/>, one-by-one.
            <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPush(`0,Akka.Streams.Stage.IContext)"/> is not called again until <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/> has requested more elements with
            <see cref="M:Akka.Streams.Stage.IContext.Pull"/>.
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)">
            <summary>
            This method is called when there is demand from downstream, i.e. you are allowed to push one element
            downstreams with <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/>, or request elements from upstreams with <see cref="M:Akka.Streams.Stage.IContext.Pull"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`2.OnUpstreamFinish(Akka.Streams.Stage.IContext)">
            <summary>
            <para>
            This method is called when upstream has signaled that the stream is successfully completed. 
            Here you cannot call <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/>, because there might not be any demand from downstream. 
            To emit additional elements before terminating you can use <see cref="M:Akka.Streams.Stage.IContext.AbsorbTermination"/> and push final elements
            from <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/>. The stage will then be in finishing state, which can be checked
            with <see cref="P:Akka.Streams.Stage.IContext.IsFinishing"/>.
            </para>
            <para>
            By default the finish signal is immediately propagated with <see cref="M:Akka.Streams.Stage.IContext.Finish"/>.
            </para>
            <para>
            IMPORTANT NOTICE: this signal is not back-pressured, it might arrive from upstream even though
            the last action by this stage was a â€œpushâ€.
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`2.OnDownstreamFinish(Akka.Streams.Stage.IContext)">
            <summary>
            This method is called when downstream has cancelled. 
            By default the cancel signal is immediately propagated with <see cref="M:Akka.Streams.Stage.IContext.Finish"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`2.OnUpstreamFailure(System.Exception,Akka.Streams.Stage.IContext)">
            <summary>
            <para>
            <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnUpstreamFailure(System.Exception,Akka.Streams.Stage.IContext)"/> is called when upstream has signaled that the stream is completed
            with failure. It is not called if <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/> or <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPush(`0,Akka.Streams.Stage.IContext)"/> of the stage itself
            throws an exception.
            </para>
            <para>
            Note that elements that were emitted by upstream before the failure happened might
            not have been received by this stage when <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnUpstreamFailure(System.Exception,Akka.Streams.Stage.IContext)"/> is called, i.e.
            failures are not backpressured and might be propagated as soon as possible.
            </para>
            <para>
            Here you cannot call <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/>, because there might not
            be any demand from  downstream. To emit additional elements before terminating you
            can use <see cref="M:Akka.Streams.Stage.IContext.AbsorbTermination"/> and push final elements
            from <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/>. The stage will then be in finishing state, which can be checked
            with <see cref="P:Akka.Streams.Stage.IContext.IsFinishing"/>.
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`2.PostStop">
            <summary>
            User overridable callback.
            Is called after the Stages final action is performed.  
            Empty default implementation.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`2.Decide(System.Exception)">
            <summary>
            If an exception is thrown from <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPush(`0,Akka.Streams.Stage.IContext)"/> this method is invoked to decide how
            to handle the exception. By default this method returns <see cref="F:Akka.Streams.Supervision.Directive.Stop"/>.
            <para>
            If an exception is thrown from <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/> the stream will always be completed with
            failure, because it is not always possible to recover from that state.
            In concrete stages it is of course possible to use ordinary try-catch-recover inside
            <see cref="M:Akka.Streams.Stage.AbstractStage`2.OnPull(Akka.Streams.Stage.IContext)"/> when it is know how to recover from such exceptions.
            </para>
            </summary> 
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`2.Restart">
            <summary>
            Used to create a fresh instance of the stage after an error resulting in a <see cref="F:Akka.Streams.Supervision.Directive.Restart"/>
            directive. By default it will return the same instance untouched, so you must override it
            if there are any state that should be cleared before restarting, e.g. by returning a new instance.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`6.OnPush(`0,`4)">
            <summary>
            <para>
            This method is called when an element from upstream is available and there is demand from downstream, i.e.
            in <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnPush(`0,`4)"/> you are allowed to call <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/> to emit one element downstreams,
            or you can absorb the element by calling <see cref="M:Akka.Streams.Stage.IContext.Pull"/>. Note that you can only
            emit zero or one element downstream from <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnPull(`4)"/>.
            </para>
            <para>
            To emit more than one element you have to push the remaining elements from <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnPull(`4)"/>, one-by-one.
            <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnPush(`0,`4)"/> is not called again until <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnPull(`4)"/> has requested more elements with
            <see cref="M:Akka.Streams.Stage.IContext.Pull"/>.
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`6.OnPush(`0,Akka.Streams.Stage.IContext)">
            <summary>
            <para>
            This method is called when an element from upstream is available and there is demand from downstream, i.e.
            in <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnPush(`0,`4)"/> you are allowed to call <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/> to emit one element downstreams,
            or you can absorb the element by calling <see cref="M:Akka.Streams.Stage.IContext.Pull"/>. Note that you can only
            emit zero or one element downstream from <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnPull(`4)"/>.
            </para>
            <para>
            To emit more than one element you have to push the remaining elements from <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnPull(`4)"/>, one-by-one.
            <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnPush(`0,`4)"/> is not called again until <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnPull(`4)"/> has requested more elements with
            <see cref="M:Akka.Streams.Stage.IContext.Pull"/>.
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`6.OnPull(`4)">
            <summary>
            This method is called when there is demand from downstream, i.e. you are allowed to push one element
            downstreams with <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/>, or request elements from upstreams with <see cref="M:Akka.Streams.Stage.IContext.Pull"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`6.OnPull(Akka.Streams.Stage.IContext)">
            <summary>
            This method is called when there is demand from downstream, i.e. you are allowed to push one element
            downstreams with <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/>, or request elements from upstreams with <see cref="M:Akka.Streams.Stage.IContext.Pull"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`6.OnUpstreamFinish(Akka.Streams.Stage.IContext)">
            <summary>
            <para>
            This method is called when upstream has signaled that the stream is successfully completed. 
            Here you cannot call <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/>, because there might not be any demand from downstream. 
            To emit additional elements before terminating you can use <see cref="M:Akka.Streams.Stage.IContext.AbsorbTermination"/> and push final elements
            from <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnPull(`4)"/>. The stage will then be in finishing state, which can be checked
            with <see cref="P:Akka.Streams.Stage.IContext.IsFinishing"/>.
            </para>
            <para>
            By default the finish signal is immediately propagated with <see cref="M:Akka.Streams.Stage.IContext.Finish"/>.
            </para>
            <para>
            IMPORTANT NOTICE: this signal is not back-pressured, it might arrive from upstream even though
            the last action by this stage was a â€œpushâ€.
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`6.OnUpstreamFinish(`4)">
            <summary>
            <para>
            This method is called when upstream has signaled that the stream is successfully completed. 
            Here you cannot call <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/>, because there might not be any demand from downstream. 
            To emit additional elements before terminating you can use <see cref="M:Akka.Streams.Stage.IContext.AbsorbTermination"/> and push final elements
            from <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnPull(`4)"/>. The stage will then be in finishing state, which can be checked
            with <see cref="P:Akka.Streams.Stage.IContext.IsFinishing"/>.
            </para>
            <para>
            By default the finish signal is immediately propagated with <see cref="M:Akka.Streams.Stage.IContext.Finish"/>.
            </para>
            <para>
            IMPORTANT NOTICE: this signal is not back-pressured, it might arrive from upstream even though
            the last action by this stage was a â€œpushâ€.
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`6.OnDownstreamFinish(Akka.Streams.Stage.IContext)">
            <summary>
            This method is called when downstream has cancelled. 
            By default the cancel signal is immediately propagated with <see cref="M:Akka.Streams.Stage.IContext.Finish"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`6.OnDownstreamFinish(`4)">
            <summary>
            This method is called when downstream has cancelled. 
            By default the cancel signal is immediately propagated with <see cref="M:Akka.Streams.Stage.IContext.Finish"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`6.OnUpstreamFailure(System.Exception,Akka.Streams.Stage.IContext)">
            <summary>
            <para>
            <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnUpstreamFailure(System.Exception,Akka.Streams.Stage.IContext)"/> is called when upstream has signaled that the stream is completed
            with failure. It is not called if <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnPull(`4)"/> or <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnPush(`0,`4)"/> of the stage itself
            throws an exception.
            </para>
            <para>
            Note that elements that were emitted by upstream before the failure happened might
            not have been received by this stage when <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnUpstreamFailure(System.Exception,Akka.Streams.Stage.IContext)"/> is called, i.e.
            failures are not backpressured and might be propagated as soon as possible.
            </para>
            <para>
            Here you cannot call <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/>, because there might not
            be any demand from  downstream. To emit additional elements before terminating you
            can use <see cref="M:Akka.Streams.Stage.IContext.AbsorbTermination"/> and push final elements
            from <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnPull(`4)"/>. The stage will then be in finishing state, which can be checked
            with <see cref="P:Akka.Streams.Stage.IContext.IsFinishing"/>.
            </para>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.AbstractStage`6.OnUpstreamFailure(System.Exception,`4)">
            <summary>
            <para>
            <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnUpstreamFailure(System.Exception,Akka.Streams.Stage.IContext)"/> is called when upstream has signaled that the stream is completed
            with failure. It is not called if <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnPull(`4)"/> or <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnPush(`0,`4)"/> of the stage itself
            throws an exception.
            </para>
            <para>
            Note that elements that were emitted by upstream before the failure happened might
            not have been received by this stage when <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnUpstreamFailure(System.Exception,Akka.Streams.Stage.IContext)"/> is called, i.e.
            failures are not backpressured and might be propagated as soon as possible.
            </para>
            <para>
            Here you cannot call <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/>, because there might not
            be any demand from  downstream. To emit additional elements before terminating you
            can use <see cref="M:Akka.Streams.Stage.IContext.AbsorbTermination"/> and push final elements
            from <see cref="M:Akka.Streams.Stage.AbstractStage`6.OnPull(`4)"/>. The stage will then be in finishing state, which can be checked
            with <see cref="P:Akka.Streams.Stage.IContext.IsFinishing"/>.
            </para>
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.ILifecycleContext.Materializer">
            Returns the Materializer that was used to materialize this [[Stage]].
            It can be used to materialize sub-flows.
        </member>
        <member name="P:Akka.Streams.Stage.ILifecycleContext.Attributes">
            Returns operation attributes associated with the this Stage 
        </member>
        <member name="T:Akka.Streams.Stage.IContext">
            Passed to the callback methods of [[PushPullStage]] and [[StatefulStage]].
        </member>
        <member name="P:Akka.Streams.Stage.IContext.IsFinishing">
            This returns `true` after [[#absorbTermination]] has been used.
        </member>
        <member name="M:Akka.Streams.Stage.IContext.PushAndFinish(System.Object)">
            Push one element to downstream immediately followed by
            cancel of upstreams and complete of downstreams.
        </member>
        <member name="M:Akka.Streams.Stage.IContext.Push(System.Object)">
            Push one element to downstreams.
        </member>
        <member name="M:Akka.Streams.Stage.IContext.Pull">
            Request for more elements from upstreams.
        </member>
        <member name="M:Akka.Streams.Stage.IContext.Finish">
            Cancel upstreams and complete downstreams successfully.
        </member>
        <member name="M:Akka.Streams.Stage.IContext.Fail(System.Exception)">
            Cancel upstreams and complete downstreams with failure.
        </member>
        <member name="M:Akka.Streams.Stage.IContext.AbsorbTermination">
            Puts the stage in a finishing state so that
            final elements can be pushed from `onPull`.
        </member>
        <member name="M:Akka.Streams.Stage.IContext`1.PushAndFinish(`0)">
            Push one element to downstream immediately followed by
            cancel of upstreams and complete of downstreams.
        </member>
        <member name="M:Akka.Streams.Stage.IContext`1.Push(`0)">
            Push one element to downstreams.
        </member>
        <member name="T:Akka.Streams.Stage.IDetachedContext">
             Passed to the callback methods of [[DetachedStage]].
            
             [[#hold]] stops execution and at the same time putting the stage in a holding state.
             If the stage is in a holding state it contains one absorbed signal, therefore in
             this state the only possible command to call is [[#pushAndPull]] which results in two
             events making the balance right again: 1 hold + 1 external event = 2 external event
        </member>
        <member name="P:Akka.Streams.Stage.IDetachedContext.IsHoldingBoth">
            This returns `true` when [[#hold]] has been used
            and it is reset to `false` after [[#pushAndPull]].
        </member>
        <member name="T:Akka.Streams.Stage.AsyncCallback`1">
            An asynchronous callback holder that is attached to an [[AsyncContext]].
            Invoking [[AsyncCallback#invoke]] will eventually lead to [[AsyncStage#onAsyncInput]]
            being called.
            
            Dispatch an asynchronous notification. This method is thread-safe and
            may be invoked from external execution contexts.
        </member>
        <member name="T:Akka.Streams.Stage.IAsyncContext">
            This kind of context is available to [[AsyncStage]]. It implements the same
            interface as for [[DetachedStage]] with the addition of being able to obtain
            [[AsyncCallback]] objects that allow the registration of asynchronous
            notifications.
        </member>
        <member name="M:Akka.Streams.Stage.IAsyncContext.GetAsyncCallback">
             Obtain a callback object that can be used asynchronously to re-enter the
             current [[AsyncStage]] with an asynchronous notification. After the
             notification has been invoked, eventually [[AsyncStage#onAsyncInput]]
             will be called with the given data item.
            
             This object can be cached and reused within the same [[AsyncStage]].
        </member>
        <member name="M:Akka.Streams.Stage.IAsyncContext.Ignore">
            In response to an asynchronous notification an [[AsyncStage]] may choose
            to neither push nor pull nor terminate, which is represented as this
            directive.
        </member>
        <member name="M:Akka.Streams.Stage.IAsyncContext`2.GetAsyncCallback">
             Obtain a callback object that can be used asynchronously to re-enter the
             current [[AsyncStage]] with an asynchronous notification. After the
             notification has been invoked, eventually [[AsyncStage#onAsyncInput]]
             will be called with the given data item.
            
             This object can be cached and reused within the same [[AsyncStage]].
        </member>
        <member name="T:Akka.Streams.Stage.GraphStage`1">
            <summary>
            A GraphStage represents a reusable graph stream processing stage. A GraphStage consists of a [[Shape]] which describes
            its input and output ports and a factory function that creates a [[GraphStageLogic]] which implements the processing
            logic that ties the ports together.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.TimerGraphStageLogic.OnTimer(System.Object)">
            <summary>
            Will be called when the scheduled timer is triggered.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.TimerGraphStageLogic.ScheduleRepeatedly(System.Object,System.TimeSpan,System.TimeSpan)">
            <summary>
            Schedule timer to call <see cref="M:Akka.Streams.Stage.TimerGraphStageLogic.OnTimer(System.Object)"/> periodically with the given interval after the specified
            initial delay.
            Any existing timer with the same key will automatically be canceled before
            adding the new timer.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.TimerGraphStageLogic.ScheduleRepeatedly(System.Object,System.TimeSpan)">
            <summary>
            Schedule timer to call <see cref="M:Akka.Streams.Stage.TimerGraphStageLogic.OnTimer(System.Object)"/> periodically with the given interval after the specified
            initial delay.
            Any existing timer with the same key will automatically be canceled before
            adding the new timer.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.TimerGraphStageLogic.ScheduleOnce(System.Object,System.TimeSpan)">
            <summary>
            Schedule timer to call [[#onTimer]] after given delay.
            Any existing timer with the same key will automatically be canceled before
            adding the new timer.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.TimerGraphStageLogic.CancelTimer(System.Object)">
            <summary>
            Cancel timer, ensuring that the <see cref="M:Akka.Streams.Stage.TimerGraphStageLogic.OnTimer(System.Object)"/> is not subsequently called.
            </summary>
            <param name="timerKey">key of the timer to cancel</param>
        </member>
        <member name="M:Akka.Streams.Stage.TimerGraphStageLogic.IsTimerActive(System.Object)">
            <summary>
            Inquire whether the timer is still active. Returns true unless the
            timer does not exist, has previously been canceled or if it was a
            single-shot timer that was already triggered.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.GraphStageLogic">
            <summary>
            Represents the processing logic behind a <see cref="T:Akka.Streams.Stage.GraphStage`1"/>. Roughly speaking, a subclass of <see cref="T:Akka.Streams.Stage.GraphStageLogic"/> is a
            collection of the following parts:
             <para>* A set of <see cref="T:Akka.Streams.Stage.InHandler"/> and <see cref="T:Akka.Streams.Stage.OutHandler"/> instances and their assignments to the <see cref="T:Akka.Streams.Inlet"/>s and <see cref="T:Akka.Streams.Outlet"/>s
               of the enclosing <see cref="T:Akka.Streams.Stage.GraphStage`1"/></para>
             <para>* Possible mutable state, accessible from the <see cref="T:Akka.Streams.Stage.InHandler"/> and <see cref="T:Akka.Streams.Stage.OutHandler"/> callbacks, but not from anywhere
               else (as such access would not be thread-safe)</para>
             <para>* The lifecycle hooks <see cref="M:Akka.Streams.Stage.GraphStageLogic.PreStart"/> and <see cref="M:Akka.Streams.Stage.GraphStageLogic.PostStop"/></para>
             <para>* Methods for performing stream processing actions, like pulling or pushing elements</para> 
             The stage logic is always stopped once all its input and output ports have been closed, i.e. it is not possible to
             keep the stage alive for further processing once it does not have any open ports.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Emitting.Dequeue">
            <summary>
            Dequeue `this` from the head of the queue, meaning that this object will
            not be retained (setHandler will install the followUp). For this reason
            the followUpsTail knowledge needs to be passed on to the next runner.
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.GraphStageLogic.EagerTerminateInput">
            <summary>
            Input handler that terminates the stage upon receiving completion. The stage fails upon receiving a failure.
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.GraphStageLogic.IgnoreTerminateInput">
            <summary>
            Input handler that does not terminate the stage upon receiving completion.
            The stage fails upon receiving a failure.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.ConditionalTerminateInput(System.Func{System.Boolean})">
            <summary>
            Input handler that terminates the state upon receiving completion if the
            given condition holds at that time. The stage fails upon receiving a failure.
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.GraphStageLogic.TotallyIgnorantInput">
            <summary>
            Input handler that does not terminate the stage upon receiving completion
            nor failure.
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.GraphStageLogic.EagerTerminateOutput">
            <summary>
            Output handler that terminates the stage upon cancellation.
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.GraphStageLogic.IgnoreTerminateOutput">
            <summary>
            Output handler that does not terminate the stage upon cancellation.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.ConditionalTerminateOutput(System.Func{System.Boolean})">
            <summary>
            Output handler that terminates the state upon receiving completion if the
            given condition holds at that time. The stage fails upon receiving a failure.
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageLogic.Materializer">
            <summary>
            The <see cref="T:Akka.Streams.IMaterializer"/> that has set this GraphStage in motion.
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageLogic.SubFusingMaterializer">
            <summary>
            An <see cref="T:Akka.Streams.IMaterializer"/> that may run fusable parts of the graphs that it materializes 
            within the same actor as the current GraphStage(if fusing is available). This materializer 
            must not be shared outside of the GraphStage.
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageLogic.KeepGoingAfterAllPortsClosed">
            <summary>
            If this method returns true when all ports had been closed then the stage is not stopped 
            until <see cref="M:Akka.Streams.Stage.GraphStageLogic.CompleteStage"/> or <see cref="M:Akka.Streams.Stage.GraphStageLogic.FailStage(System.Exception)"/> are explicitly called
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SetHandler(Akka.Streams.Inlet,Akka.Streams.Stage.IInHandler)">
            <summary>
            Assigns callbacks for the events for an <see cref="T:Akka.Streams.Inlet`1"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SetHandler(Akka.Streams.Inlet,System.Action,System.Action,System.Action{System.Exception})">
            <summary>
            Assigns callbacks for the events for an <see cref="T:Akka.Streams.Outlet`1"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.GetHandler(Akka.Streams.Inlet)">
            <summary>
            Retrieves the current callback for the events on the given <see cref="T:Akka.Streams.Inlet`1"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SetHandler(Akka.Streams.Outlet,Akka.Streams.Stage.IOutHandler)">
            <summary>
            Assigns callbacks for the events for an <see cref="T:Akka.Streams.Outlet`1"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SetHandler(Akka.Streams.Outlet,System.Action,System.Action)">
            <summary>
            Assigns callbacks for the events for an <see cref="T:Akka.Streams.Outlet`1"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.GetHandler(Akka.Streams.Outlet)">
            <summary>
            Retrieves the current callback for the events on the given <see cref="T:Akka.Streams.Outlet`1"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Pull``1(Akka.Streams.Inlet)">
            <summary>
            Requests an element on the given port. Calling this method twice before an element arrived will fail.
            There can only be one outstanding request at any given time.The method <see cref="!:HasBeenPulled&lt;T&gt;"/> can be used
            query whether pull is allowed to be called or not.This method will also fail if the port is already closed.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Pull``1(Akka.Streams.Inlet{``0})">
            <summary>
            Requests an element on the given port. Calling this method twice before an element arrived will fail.
            There can only be one outstanding request at any given time.The method <see cref="!:HasBeenPulled&lt;T&gt;"/> can be used
            query whether pull is allowed to be called or not.This method will also fail if the port is already closed.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.TryPull``1(Akka.Streams.Inlet)">
            <summary>
            Requests an element on the given port unless the port is already closed.
            Calling this method twice before an element arrived will fail.
            There can only be one outstanding request at any given time.The method <see cref="!:HasBeenPulled&lt;T&gt;"/> can be used
            query whether pull is allowed to be called or not.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.TryPull``1(Akka.Streams.Inlet{``0})">
            <summary>
            Requests an element on the given port unless the port is already closed.
            Calling this method twice before an element arrived will fail.
            There can only be one outstanding request at any given time.The method <see cref="!:HasBeenPulled&lt;T&gt;"/> can be used
            query whether pull is allowed to be called or not.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Cancel(Akka.Streams.Inlet)">
            <summary>
            Requests to stop receiving events from a given input port. Cancelling clears any ungrabbed elements from the port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet)">
            <summary>
            Once the callback <see cref="M:Akka.Streams.Stage.InHandler.OnPush"/> for an input port has been invoked, the element that has been pushed
            can be retrieved via this method. After <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet)"/> has been called the port is considered to be empty, and further
            calls to <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet)"/> will fail until the port is pulled again and a new element is pushed as a response.
            
            The method <see cref="!:IsAvailable&lt;T&gt;"/> can be used to query if the port has an element that can be grabbed or not.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet{``0})">
            <summary>
            Once the callback <see cref="M:Akka.Streams.Stage.InHandler.OnPush"/> for an input port has been invoked, the element that has been pushed
            can be retrieved via this method. After <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet)"/> has been called the port is considered to be empty, and further
            calls to <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet)"/> will fail until the port is pulled again and a new element is pushed as a response.
            
            The method <see cref="!:IsAvailable&lt;T&gt;"/> can be used to query if the port has an element that can be grabbed or not.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.HasBeenPulled(Akka.Streams.Inlet)">
            <summary>
            Indicates whether there is already a pending pull for the given input port. If this method returns true 
            then <see cref="!:IsAvailable&lt;T&gt;"/> must return false for that same port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.IsAvailable(Akka.Streams.Inlet)">
            <summary>
            Indicates whether there is an element waiting at the given input port. <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet)"/> can be used to retrieve the
            element. After calling <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet)"/> this method will return false.
            
            If this method returns true then <see cref="!:HasBeenPulled&lt;T&gt;"/> will return false for that same port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.IsClosed(Akka.Streams.Inlet)">
            <summary>
            Indicates whether the port has been closed. A closed port cannot be pulled.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Push``1(Akka.Streams.Outlet,``0)">
            <summary>
            Emits an element through the given output port. Calling this method twice before a <see cref="M:Akka.Streams.Stage.GraphStageLogic.Pull``1(Akka.Streams.Inlet)"/> has been arrived
            will fail. There can be only one outstanding push request at any given time. The method <see cref="!:IsAvailable&lt;T&gt;"/> can be
            used to check if the port is ready to be pushed or not.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SetKeepGoing(System.Boolean)">
            <summary>
            Controls whether this stage shall shut down when all its ports are closed, which
            is the default. In order to have it keep going past that point this method needs
            to be called with a `true` argument before all ports are closed, and afterwards
            it will not be closed until this method is called with a `false` argument or the
            stage is terminated via `completeStage()` or `failStage()`.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Complete(Akka.Streams.Outlet)">
            <summary>
            Signals that there will be no more elements emitted on the given port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Fail(Akka.Streams.Outlet,System.Exception)">
            <summary>
            Signals failure through the given port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.CompleteStage">
            <summary>
            Automatically invokes <see cref="!:Cancel&lt;T&gt;"/> or <see cref="!:Complete&lt;T&gt;"/> on all the input or output ports that have been called,
            then stops the stage, then <see cref="M:Akka.Streams.Stage.GraphStageLogic.PostStop"/> is called.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.FailStage(System.Exception)">
            <summary>
            Automatically invokes [[cancel()]] or [[fail()]] on all the input or output ports that have been called,
            then stops the stage, then [[postStop()]] is called.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.IsAvailable(Akka.Streams.Outlet)">
            <summary>
            Return true if the given output port is ready to be pushed.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.IsClosed(Akka.Streams.Outlet)">
            <summary>
            Indicates whether the port has been closed. A closed port cannot be pushed.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.ReadMany``1(Akka.Streams.Inlet{``0},System.Int32,System.Action{System.Collections.Generic.IEnumerable{``0}},System.Action{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Read a number of elements from the given inlet and continue with the given function,
            suspending execution if necessary. This action replaces the <see cref="T:Akka.Streams.Stage.InHandler"/>
            for the given inlet if suspension is needed and reinstalls the current
            handler upon receiving the last <see cref="M:Akka.Streams.Stage.InHandler.OnPush"/> signal (before invoking the <paramref name="andThen"/> function).
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Read``1(Akka.Streams.Inlet{``0},System.Action{``0},System.Action)">
            <summary>
            Read an element from the given inlet and continue with the given function,
            suspending execution if necessary. This action replaces the <see cref="T:Akka.Streams.Stage.InHandler"/>
            for the given inlet if suspension is needed and reinstalls the current
            handler upon receiving the <see cref="M:Akka.Streams.Stage.InHandler.OnPush"/> signal (before invoking the <paramref name="andThen"/> function).
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.AbortReading``1(Akka.Streams.Inlet{``0})">
            <summary>
            Abort outstanding (suspended) reading for the given inlet, if there is any.
            This will reinstall the replaced handler that was in effect before the `read`
            call.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.EmitMultiple``1(Akka.Streams.Outlet{``0},System.Collections.Generic.IEnumerable{``0},System.Action)">
            <summary>
            Emit a sequence of elements through the given outlet and continue with the given thunk
            afterwards, suspending execution if necessary.
            This action replaces the <see cref="T:Akka.Streams.Stage.OutHandler"/> for the given outlet if suspension
            is needed and reinstalls the current handler upon receiving an <see cref="M:Akka.Streams.Stage.OutHandler.OnPull"/>
            signal (before invoking the <paramref name="andThen"/> function).
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.EmitMultiple``1(Akka.Streams.Outlet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Emit a sequence of elements through the given outlet, suspending execution if necessary.
            This action replaces the <see cref="T:Akka.Streams.Stage.OutHandler"/> for the given outlet if suspension
            is needed and reinstalls the current handler upon receiving an <see cref="M:Akka.Streams.Stage.OutHandler.OnPull"/>
            signal.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.EmitMultiple``1(Akka.Streams.Outlet{``0},System.Collections.Generic.IEnumerator{``0},System.Action)">
            <summary>
            Emit a sequence of elements through the given outlet and continue with the given thunk
            afterwards, suspending execution if necessary.
            This action replaces the <see cref="T:Akka.Streams.Stage.OutHandler"/> for the given outlet if suspension
            is needed and reinstalls the current handler upon receiving an <see cref="M:Akka.Streams.Stage.OutHandler.OnPull"/>
            signal (before invoking the <paramref name="andThen"/> function).
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.EmitMultiple``1(Akka.Streams.Outlet{``0},System.Collections.Generic.IEnumerator{``0})">
            <summary>
            Emit a sequence of elements through the given outlet, suspending execution if necessary.
            This action replaces the <see cref="T:Akka.Streams.Stage.OutHandler"/> for the given outlet if suspension
            is needed and reinstalls the current handler upon receiving an <see cref="M:Akka.Streams.Stage.OutHandler.OnPull"/>
            signal.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Emit``1(Akka.Streams.Outlet{``0},``0,System.Action)">
            <summary>
            Emit an element through the given outlet and continue with the given thunk
            afterwards, suspending execution if necessary.
            This action replaces the <see cref="T:Akka.Streams.Stage.OutHandler"/> for the given outlet if suspension
            is needed and reinstalls the current handler upon receiving an <see cref="M:Akka.Streams.Stage.OutHandler.OnPull"/>
            signal (before invoking the <paramref name="andThen"/> function).
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.Emit``1(Akka.Streams.Outlet{``0},``0)">
            <summary>
            Emit an element through the given outlet and continue with the given thunk
            afterwards, suspending execution if necessary.
            This action replaces the <see cref="T:Akka.Streams.Stage.OutHandler"/> for the given outlet if suspension
            is needed and reinstalls the current handler upon receiving an <see cref="M:Akka.Streams.Stage.OutHandler.OnPull"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.AbortEmitting``1(Akka.Streams.Outlet{``0})">
            <summary>
            Abort outstanding (suspended) emissions for the given outlet, if there are any.
            This will reinstall the replaced handler that was in effect before the <see cref="M:Akka.Streams.Stage.GraphStageLogic.Emit``1(Akka.Streams.Outlet{``0},``0,System.Action)"/>
            call.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.PassAlong``2(Akka.Streams.Inlet{``1},Akka.Streams.Outlet{``0},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Install a handler on the given inlet that emits received elements on the
            given outlet before pulling for more data. <paramref name="doFinish"/> and <paramref name="doFail"/> control whether
            completion or failure of the given inlet shall lead to stage termination or not.
            <paramref name="doPull"/> instructs to perform one initial pull on the <paramref name="from"/> port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.GetAsyncCallback``1(System.Action{``0})">
            <summary>
            Obtain a callback object that can be used asynchronously to re-enter the
            current <see cref="T:Akka.Streams.Stage.GraphStage`1"/> with an asynchronous notification. The delegate returned 
            is safe to be called from other threads and it will in the background thread-safely
            delegate to the passed callback function. I.e. it will be called by the external world and
            the passed handler will be invoked eventually in a thread-safe way by the execution environment.
            
            This object can be cached and reused within the same <see cref="T:Akka.Streams.Stage.GraphStageLogic"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.GetAsyncCallback(System.Action)">
            <summary>
            Obtain a callback object that can be used asynchronously to re-enter the
            current <see cref="T:Akka.Streams.Stage.GraphStage`1"/> with an asynchronous notification. The delegate returned 
            is safe to be called from other threads and it will in the background thread-safely
            delegate to the passed callback function. I.e. it will be called by the external world and
            the passed handler will be invoked eventually in a thread-safe way by the execution environment.
            
            This object can be cached and reused within the same <see cref="T:Akka.Streams.Stage.GraphStageLogic"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.GetStageActorRef(Akka.Streams.Stage.StageActorRef.Receive)">
            <summary>
            Initialize a <see cref="P:Akka.Streams.Stage.GraphStageLogic.StageActorRef"/> which can be used to interact with from the outside world "as-if" an actor.
            The messages are looped through the <see cref="M:Akka.Streams.Stage.GraphStageLogic.GetAsyncCallback``1(System.Action{``0})"/> mechanism of <see cref="T:Akka.Streams.Stage.GraphStage`1"/> so they are safe to modify
            internal state of this stage.
            
            This method must not (the earliest) be called after the <see cref="T:Akka.Streams.Stage.GraphStageLogic"/> constructor has finished running,
            for example from the <see cref="M:Akka.Streams.Stage.GraphStageLogic.PreStart"/> callback the graph stage logic provides.
            
            Created <see cref="P:Akka.Streams.Stage.GraphStageLogic.StageActorRef"/> to get messages and watch other actors in synchronous way.
            
            The <see cref="P:Akka.Streams.Stage.GraphStageLogic.StageActorRef"/>'s lifecycle is bound to the Stage, in other words when the Stage is finished,
            the Actor will be terminated as well. The entity backing the <see cref="P:Akka.Streams.Stage.GraphStageLogic.StageActorRef"/> is not a real Actor,
            but the <see cref="T:Akka.Streams.Stage.GraphStageLogic"/> itself, therefore it does not react to <see cref="T:Akka.Actor.PoisonPill"/>.
            </summary>
            <param name="receive">Callback that will be called upon receiving of a message by this special Actor</param>
            <returns>Minimal actor with watch method</returns>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.PreStart">
            <summary>
            Invoked before any external events are processed, at the startup of the stage.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.PostStop">
            <summary>
            Invoked after processing of external events stopped because the stage is about to stop or fail.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.GraphStageLogic.SubSinkInlet`1">
            <summary>
            INTERNAL API
            
            This allows the dynamic creation of an Inlet for a GraphStage which is
            connected to a Sink that is available for materialization (e.g. using
            the `subFusingMaterializer`). Care needs to be taken to cancel this Inlet
            when the stage shuts down lest the corresponding Sink be left hanging.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1">
            <summary>
            INTERNAL API
            
            This allows the dynamic creation of an Outlet for a GraphStage which is
            connected to a Source that is available for materialization (e.g. using
            the `subFusingMaterializer`). Care needs to be taken to complete this
            Outlet when the stage shuts down lest the corresponding Sink be left
            hanging. It is good practice to use the `timeout` method to cancel this
            Outlet in case the corresponding Source is not materialized within a
            given time limit, see e.g. ActorMaterializerSettings.
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.Source">
            <summary>
            Get the Source for this dynamic output port.
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.IsAvailable">
            <summary>
            Returns true if this output port can be pushed.
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.IsClosed">
            <summary>
            Returns true if this output port is closed, but caution
            THIS WORKS DIFFERENTLY THAN THE NORMAL isClosed(out).
            Due to possibly asynchronous shutdown it may not return
            `true` immediately after `complete()` or `fail()` have returned.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.Timeout(System.TimeSpan)">
            <summary>
            Set the source into timed-out mode if it has not yet been materialized.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.SetHandler(Akka.Streams.Stage.IOutHandler)">
            <summary>
            Set OutHandler for this dynamic output port; this needs to be done before
            the first substream callback can arrive.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.Push(`0)">
            <summary>
            Push to this output port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.Complete">
            <summary>
            Complete this output port. 
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.GraphStageLogic.SubSourceOutlet`1.Fail(System.Exception)">
            <summary>
            Fail this output port.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.IInHandler">
            <summary>
            Collection of callbacks for an input port of a <see cref="T:Akka.Streams.Stage.GraphStage`1"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.IInHandler.OnPush">
            <summary>
            Called when the input port has a new element available. The actual element can be retrieved via the <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet)"/> method.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.IInHandler.OnUpstreamFinish">
            <summary>
            Called when the input port is finished. After this callback no other callbacks will be called for this port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.IInHandler.OnUpstreamFailure(System.Exception)">
            <summary>
            Called when the input port has failed. After this callback no other callbacks will be called for this port.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.InHandler">
            <summary>
            Collection of callbacks for an input port of a <see cref="T:Akka.Streams.Stage.GraphStage`1"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InHandler.OnPush">
            <summary>
            Called when the input port has a new element available. The actual element can be retrieved via the <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet)"/> method.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InHandler.OnUpstreamFinish">
            <summary>
            Called when the input port is finished. After this callback no other callbacks will be called for this port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InHandler.OnUpstreamFailure(System.Exception)">
            <summary>
            Called when the input port has failed. After this callback no other callbacks will be called for this port.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.IOutHandler">
            <summary>
            Collection of callbacks for an output port of a <see cref="T:Akka.Streams.Stage.GraphStage`1"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.IOutHandler.OnPull">
            <summary>
            Called when the output port has received a pull, and therefore ready to emit an element, 
            i.e. <see cref="M:Akka.Streams.Stage.GraphStageLogic.Push``1(Akka.Streams.Outlet,``0)"/> is now allowed to be called on this port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.IOutHandler.OnDownstreamFinish">
            <summary>
            Called when the output port will no longer accept any new elements. After this callback no other callbacks will be called for this port.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.OutHandler">
            <summary>
            Collection of callbacks for an output port of a <see cref="T:Akka.Streams.Stage.GraphStage`1"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.OutHandler.OnPull">
            <summary>
            Called when the output port has received a pull, and therefore ready to emit an element, 
            i.e. <see cref="M:Akka.Streams.Stage.GraphStageLogic.Push``1(Akka.Streams.Outlet,``0)"/> is now allowed to be called on this port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.OutHandler.OnDownstreamFinish">
            <summary>
            Called when the output port will no longer accept any new elements. After this callback no other callbacks will be called for this port.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.InAndOutHandler">
            <summary>
            Collection of callbacks for an output port of a <see cref="T:Akka.Streams.Stage.GraphStage`1"/> and
            for an input port of a <see cref="T:Akka.Streams.Stage.GraphStage`1"/>
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InAndOutHandler.OnPush">
            <summary>
            Called when the input port has a new element available. The actual element can be retrieved via the <see cref="M:Akka.Streams.Stage.GraphStageLogic.Grab``1(Akka.Streams.Inlet)"/> method.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InAndOutHandler.OnUpstreamFinish">
            <summary>
            Called when the input port is finished. After this callback no other callbacks will be called for this port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InAndOutHandler.OnUpstreamFailure(System.Exception)">
            <summary>
            Called when the input port has failed. After this callback no other callbacks will be called for this port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InAndOutHandler.OnPull">
            <summary>
            Called when the output port has received a pull, and therefore ready to emit an element, 
            i.e. <see cref="M:Akka.Streams.Stage.GraphStageLogic.Push``1(Akka.Streams.Outlet,``0)"/> is now allowed to be called on this port.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.InAndOutHandler.OnDownstreamFinish">
            <summary>
            Called when the output port will no longer accept any new elements. After this callback no other callbacks will be called for this port.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.EagerTerminateInput">
            <summary>
            Input handler that terminates the stage upon receiving completion. The stage fails upon receiving a failure.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.IgnoreTerminateInput">
            <summary>
            Input handler that does not terminate the stage upon receiving completion. The stage fails upon receiving a failure.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.ConditionalTerminateInput">
            <summary>
            Input handler that terminates the state upon receiving completion 
            if the given condition holds at that time.The stage fails upon receiving a failure.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.TotallyIgnorantInput">
            <summary>
            Input handler that does not terminate the stage upon receiving completion nor failure.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.EagerTerminateOutput">
            <summary>
            Output handler that terminates the stage upon cancellation.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.IgnoreTerminateOutput">
            <summary>
            Output handler that does not terminate the stage upon cancellation.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.ConditionalTerminateOutput">
            <summary>
            Output handler that terminates the state upon receiving completion if the
            given condition holds at that time.The stage fails upon receiving a failure.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.StageActorRef">
            <summary>
            Minimal actor to work with other actors and watch them in a synchronous ways.
            </summary>
        </member>
        <member name="F:Akka.Streams.Stage.StageActorRef.Name">
            <summary>
            Globally sequential, one should not depend on these names in any case.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.GraphStageLogicWithCallbackWrapper`1">
            <summary>
            <para>
            This class wraps callback for <see cref="T:Akka.Streams.Stage.GraphStage`1"/> instances and gracefully handles
            cases when stage is not yet initialized or already finished.
            </para>
            <para>
            While <see cref="T:Akka.Streams.Stage.GraphStage`1"/> is not initialized it adds all requests to list.
            As soon as <see cref="T:Akka.Streams.Stage.GraphStage`1"/> is started it stops collecting requests (pointing
            to real callback function) and runs all callbacks from the list.
            </para>
            <para>
            Intended to be used by <see cref="T:Akka.Streams.Stage.GraphStage`1"/> that share callback with outer world.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Akka.Streams.Stage.IStage`2">
            <summary>
            General interface for stream transformation.
            
            Custom <see cref="T:Akka.Streams.Stage.IStage`2"/> implementations are intended to be used with
            [[akka.stream.scaladsl.FlowOps#transform]] or
            [[akka.stream.javadsl.Flow#transform]] to extend the `Flow` API when there
            is no specialized operator that performs the transformation.
            
            Custom implementations are subclasses of <see cref="T:Akka.Streams.Stage.PushPullStage`2"/> or
            <see cref="T:Akka.Streams.Stage.DetachedStage`2"/>. Sometimes it is convenient to extend
            <see cref="T:Akka.Streams.Stage.StatefulStage`2"/> for support of become like behavior.
            
            It is possible to keep state in the concrete <see cref="T:Akka.Streams.Stage.IStage`2"/> instance with
            ordinary instance variables. The <see cref="T:Akka.Streams.ITransformerLike`2"/> is executed by an actor and
            therefore you do not have to add any additional thread safety or memory
            visibility constructs to access the state from the callback methods.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.PushPullStage`2">
            <summary>
            <para>
            <see cref="T:Akka.Streams.Stage.PushPullStage`2"/> implementations participate in 1-bounded regions. For every external non-completion signal these
            stages produce *exactly one* push or pull signal.
            </para>
            <para>
            <see cref="!:OnPush"/> is called when an element from upstream is available and there is demand from downstream, i.e.
            in <see cref="!:OnPush"/> you are allowed to call <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/> to emit one element downstreams, or you can absorb the
            element by calling <see cref="M:Akka.Streams.Stage.IContext.Pull"/>. Note that you can only emit zero or one element downstream from <see cref="!:OnPull"/>.
            To emit more than one element you have to push the remaining elements from <see cref="!:OnPush"/>, one-by-one.
            <see cref="!:OnPush"/> is not called again until <see cref="!:OnPull"/> has requested more elements with <see cref="M:Akka.Streams.Stage.IContext.Pull"/>.
            </para>
            <para>
            <see cref="T:Akka.Streams.Stage.StatefulStage`2"/> has support for making it easy to emit more than one element from <see cref="!:OnPush"/>.
            </para>
            <para>
            <see cref="!:OnPull"/> is called when there is demand from downstream, i.e. you are allowed to push one element
            downstreams with <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/>, or request elements from upstreams with <see cref="M:Akka.Streams.Stage.IContext.Pull"/>. If you
            always perform transitive pull by calling <see cref="M:Akka.Streams.Stage.IContext.Pull"/> from <see cref="!:OnPull"/> you can use 
            <see cref="T:Akka.Streams.Stage.PushStage`2"/> instead of <see cref="T:Akka.Streams.Stage.PushPullStage`2"/>.
            </para>
            <para>
            Stages are allowed to do early completion of downstream and cancel of upstream. This is done with <see cref="M:Akka.Streams.Stage.IContext.Finish"/>,
            which is a combination of cancel/complete.
            </para>
            <para>
            Since OnComplete is not a backpressured signal it is sometimes preferable to push a final element and then
            immediately finish. This combination is exposed as <see cref="M:Akka.Streams.Stage.IContext.PushAndFinish(System.Object)"/> which enables stages to
            propagate completion events without waiting for an extra round of pull.
            </para>
            <para>
            Another peculiarity is how to convert termination events (complete/failure) into elements. The problem
            here is that the termination events are not backpressured while elements are. This means that simply calling
            <see cref="M:Akka.Streams.Stage.IContext.Push(System.Object)"/> as a response to <see cref="!:OnUpstreamFinish"/> or <see cref="!:OnUpstreamFailure"/> will very likely break boundedness
            and result in a buffer overflow somewhere. Therefore the only allowed command in this case is
            <see cref="M:Akka.Streams.Stage.IContext.AbsorbTermination"/> which stops the propagation of the termination signal, and puts the stage in a
            <see cref="P:Akka.Streams.Stage.IContext.IsFinishing"/> state. Depending on whether the stage has a pending pull signal it
            has not yet "consumed" by a push its <see cref="!:OnPull"/> handler might be called immediately or later. From
            <see cref="!:OnPull"/> final elements can be pushed before completing downstream with <see cref="M:Akka.Streams.Stage.IContext.Finish"/> or
            <see cref="M:Akka.Streams.Stage.IContext.PushAndFinish(System.Object)"/>.
            </para>
            <para>
            <see cref="T:Akka.Streams.Stage.StatefulStage`2"/> has support for making it easy to emit final elements.
            </para>
            <para>
            All these rules are enforced by types and runtime checks where needed. Always return the <see cref="T:Akka.Streams.Supervision.Directive"/>
            from the call to the <see cref="T:Akka.Streams.Stage.IContext"/> method, and do only call <see cref="T:Akka.Streams.Stage.IContext"/> commands once per callback.
            </para>
            </summary>
            <seealso cref="T:Akka.Streams.Stage.DetachedStage`2"/>
            <seealso cref="T:Akka.Streams.Stage.StatefulStage`2"/>
            <seealso cref="T:Akka.Streams.Stage.PushStage`2"/>
        </member>
        <member name="T:Akka.Streams.Stage.PushStage`2">
            <summary>
            <see cref="T:Akka.Streams.Stage.PushStage`2"/> is a <see cref="T:Akka.Streams.Stage.PushPullStage`2"/> that always perform transitive pull by calling <see cref="M:Akka.Streams.Stage.IContext.Pull"/> from <see cref="M:Akka.Streams.Stage.PushStage`2.OnPull(Akka.Streams.Stage.IContext{`1})"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.PushStage`2.OnPull(Akka.Streams.Stage.IContext{`1})">
            <summary>
            Always pulls from upstream.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.DetachedStage`2">
            <summary>
            `DetachedStage` can be used to implement operations similar to [[akka.stream.scaladsl.FlowOps#buffer buffer]],
            [[akka.stream.scaladsl.FlowOps#expand expand]] and [[akka.stream.scaladsl.FlowOps#conflate conflate]].
            
            `DetachedStage` implementations are boundaries between 1-bounded regions. This means that they need to enforce the
            "exactly one" property both on their upstream and downstream regions. As a consequence a `DetachedStage` can never
            answer an [[#onPull]] with a [[Context#pull]] or answer an [[#onPush]] with a [[Context#push]] since such an action
            would "steal" the event from one region (resulting in zero signals) and would inject it to the other region
            (resulting in two signals).
            
            However, DetachedStages have the ability to call [[akka.stream.stage.DetachedContext#hold]] as a response to
            [[#onPush]] and [[#onPull]] which temporarily takes the signal off and
            stops execution, at the same time putting the stage in an [[akka.stream.stage.DetachedContext#isHolding]] state.
            If the stage is in a holding state it contains one absorbed signal, therefore in this state the only possible
            command to call is [[akka.stream.stage.DetachedContext#pushAndPull]] which results in two events making the
            balance right again: 1 hold + 1 external event = 2 external event
            
            This mechanism allows synchronization between the upstream and downstream regions which otherwise can progress
            independently.
            
            @see [[PushPullStage]]
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.DetachedStage`2.Decide(System.Exception)">
             If an exception is thrown from [[#onPush]] this method is invoked to decide how
             to handle the exception. By default this method returns [[Supervision.Stop]].
            
             If an exception is thrown from [[#onPull]] or if the stage is holding state the stream
             will always be completed with failure, because it is not always possible to recover from
             that state.
             In concrete stages it is of course possible to use ordinary try-catch-recover inside
             `onPull` when it is know how to recover from such exceptions.
        </member>
        <member name="T:Akka.Streams.Stage.StageState`2">
            <summary>
            The behavior of <see cref="T:Akka.Streams.Stage.StatefulStage`2"/> is defined by these two methods, which
            has the same semantics as corresponding methods in <see cref="T:Akka.Streams.Stage.PushPullStage`2"/>.
            </summary>
        </member>
        <member name="T:Akka.Streams.Stage.StatefulStage`2">
            <summary>
            <see cref="T:Akka.Streams.Stage.StatefulStage`2"/> is a <see cref="T:Akka.Streams.Stage.PushPullStage`2"/> that provides convenience to make some things easier.
            
            The behavior is defined in <see cref="T:Akka.Streams.Stage.StageState`2"/> instances. The initial behavior is specified
            by subclass implementing the <see cref="P:Akka.Streams.Stage.StatefulStage`2.Initial"/> method. The behavior can be changed by using <see cref="M:Akka.Streams.Stage.StatefulStage`2.Become(Akka.Streams.Stage.StageState{`0,`1})"/>.
            
            Use <see cref="M:Akka.Streams.Stage.StatefulStage`2.Emit(System.Collections.Generic.IEnumerator{`1},Akka.Streams.Stage.IContext{`1})"/> or <see cref="M:Akka.Streams.Stage.StatefulStage`2.EmitAndFinish(System.Collections.Generic.IEnumerator{`1},Akka.Streams.Stage.IContext{`1})"/> to push more than one element from <see cref="M:Akka.Streams.Stage.StageState`2.OnPush(`0,Akka.Streams.Stage.IContext{`1})"/> or
            <see cref="M:Akka.Streams.Stage.StageState`2.OnPull(Akka.Streams.Stage.IContext{`1})"/>.
            
            Use <see cref="M:Akka.Streams.Stage.StatefulStage`2.TerminationEmit(System.Collections.Generic.IEnumerator{`1},Akka.Streams.Stage.IContext{`1})"/> to push final elements from <see cref="M:Akka.Streams.Stage.StatefulStage`2.OnUpstreamFinish(Akka.Streams.Stage.IContext{`1})"/> or <see cref="!:OnUpstreamFailure"/>.
            </summary>
        </member>
        <member name="P:Akka.Streams.Stage.StatefulStage`2.Initial">
             Concrete subclass must return the initial behavior from this method.
            
             **Warning:** This method must not be implemented as `val`.
        </member>
        <member name="P:Akka.Streams.Stage.StatefulStage`2.Current">
            <summary>
            Current state.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.StatefulStage`2.Become(Akka.Streams.Stage.StageState{`0,`1})">
            <summary>
            Change the behavior to another <see cref="T:Akka.Streams.Stage.StageState`2"/>.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.StatefulStage`2.OnPush(`0,Akka.Streams.Stage.IContext{`1})">
            <summary>
            Invokes current state.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.StatefulStage`2.OnPull(Akka.Streams.Stage.IContext{`1})">
            <summary>
            Invokes current state.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.StatefulStage`2.Emit(System.Collections.Generic.IEnumerator{`1},Akka.Streams.Stage.IContext{`1})">
            <summary>
            Can be used from <see cref="M:Akka.Streams.Stage.StageState`2.OnPush(`0,Akka.Streams.Stage.IContext{`1})"/> or <see cref="M:Akka.Streams.Stage.StageState`2.OnPull(Akka.Streams.Stage.IContext{`1})"/> to push more than one
            element downstreams.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.StatefulStage`2.Emit(System.Collections.Generic.IEnumerator{`1},Akka.Streams.Stage.IContext{`1},Akka.Streams.Stage.StageState{`0,`1})">
            <summary>
            Can be used from <see cref="M:Akka.Streams.Stage.StageState`2.OnPush(`0,Akka.Streams.Stage.IContext{`1})"/> or <see cref="M:Akka.Streams.Stage.StageState`2.OnPull(Akka.Streams.Stage.IContext{`1})"/> to push more than one
            element downstreams and after that change behavior.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.StatefulStage`2.TerminationEmit(System.Collections.Generic.IEnumerator{`1},Akka.Streams.Stage.IContext{`1})">
            <summary>
            Can be used from <see cref="M:Akka.Streams.Stage.StatefulStage`2.OnUpstreamFinish(Akka.Streams.Stage.IContext{`1})"/> to push final elements downstreams
            before completing the stream successfully. Note that if this is used from
            <see cref="!:OnUpstreamFailure"/> the failure will be absorbed and the stream will be completed
            successfully.
            </summary>
        </member>
        <member name="M:Akka.Streams.Stage.StatefulStage`2.EmitAndFinish(System.Collections.Generic.IEnumerator{`1},Akka.Streams.Stage.IContext{`1})">
            <summary>
            Can be used from <see cref="M:Akka.Streams.Stage.StageState`2.OnPush(`0,Akka.Streams.Stage.IContext{`1})"/> or <see cref="M:Akka.Streams.Stage.StageState`2.OnPull(Akka.Streams.Stage.IContext{`1})"/> to push more than one
            element downstreams and after that finish (complete downstreams, cancel upstreams).
            </summary>
        </member>
        <member name="T:Akka.Streams.SubstreamCancelStrategy">
            <summary>
            Represents a strategy that decides how to deal with substream events.
            </summary>
        </member>
        <member name="F:Akka.Streams.SubstreamCancelStrategy.Propagate">
            <summary>
            Cancel the stream of streams if any substream is cancelled.
            </summary>
        </member>
        <member name="F:Akka.Streams.SubstreamCancelStrategy.Drain">
            <summary>
            Drain substream on cancellation in order to prevent stalling of the stream of streams.
            </summary>
        </member>
        <member name="F:Akka.Streams.Supervision.Directive.Stop">
            <summary>
            The stream will be completed with failure if application code for processing an element throws an exception..
            </summary>
        </member>
        <member name="F:Akka.Streams.Supervision.Directive.Resume">
            <summary>
            The element is dropped and the stream continues if application code for processing an element throws an exception.
            </summary>
        </member>
        <member name="F:Akka.Streams.Supervision.Directive.Restart">
            <summary>
            The element is dropped and the stream continues after restarting the stage if application code for processing 
            an element throws an exception. Restarting a stage means that any accumulated state is cleared. 
            This is typically performed by creating a new instance of the stage.
            </summary>
        </member>
        <member name="T:Akka.Streams.ThrottleMode">
            <summary>
            Represents a mode that decides how to deal exceed rate for Throttle combinator.
            </summary>
        </member>
        <member name="F:Akka.Streams.ThrottleMode.Shaping">
            <summary>
            Tells throttle to make pauses before emitting messages to meet throttle rate
            </summary>
        </member>
        <member name="F:Akka.Streams.ThrottleMode.Enforcing">
            <summary>
            Makes throttle fail with exception when upstream is faster than throttle rate
            </summary>
        </member>
        <member name="P:Akka.Streams.ITransformerLike`2.IsComplete">
            Invoked after handing off the elements produced from one input element to the
            downstream subscribers to determine whether to end stream processing at this point;
            in that case the upstream subscription is canceled.
        </member>
        <member name="M:Akka.Streams.ITransformerLike`2.OnNext(`0)">
            Invoked for each element to produce a (possibly empty) sequence of
            output elements.
        </member>
        <member name="M:Akka.Streams.ITransformerLike`2.OnTermination(System.Exception)">
             Invoked before the Transformer terminates (either normal completion or after an onError)
             to produce a (possibly empty) sequence of elements in response to the
             end-of-stream event.
            
             This method is only called if [[#onError]] does not throw an exception. The default implementation
             of [[#onError]] throws the received cause forcing the failure to propagate downstream immediately.
            
             @param e Contains a non-empty option with the error causing the termination or an empty option
                      if the Transformer was completed normally
        </member>
        <member name="M:Akka.Streams.ITransformerLike`2.OnError(System.Exception)">
            Invoked when failure is signaled from upstream. If this method throws an exception, then onError is immediately
            propagated downstream. If this method completes normally then [[#onTermination]] is invoked as a final
            step, passing the original cause.
        </member>
        <member name="M:Akka.Streams.ITransformerLike`2.Cleanup">
            Invoked after normal completion or failure.
        </member>
        <member name="M:Akka.Streams.TransformerLikeBase`2.OnNext(`0)">
            Invoked for each element to produce a (possibly empty) sequence of
            output elements.
        </member>
        <member name="P:Akka.Streams.TransformerLikeBase`2.IsComplete">
            Invoked after handing off the elements produced from one input element to the
            downstream subscribers to determine whether to end stream processing at this point;
            in that case the upstream subscription is canceled.
        </member>
        <member name="M:Akka.Streams.TransformerLikeBase`2.OnTermination(System.Exception)">
             Invoked before the Transformer terminates (either normal completion or after an onError)
             to produce a (possibly empty) sequence of elements in response to the
             end-of-stream event.
            
             This method is only called if [[#onError]] does not throw an exception. The default implementation
             of [[#onError]] throws the received cause forcing the failure to propagate downstream immediately.
            
             @param e Contains a non-empty option with the error causing the termination or an empty option
                      if the Transformer was completed normally
        </member>
        <member name="M:Akka.Streams.TransformerLikeBase`2.OnError(System.Exception)">
            Invoked when failure is signaled from upstream. If this method throws an exception, then onError is immediately
            propagated downstream. If this method completes normally then [[#onTermination]] is invoked as a final
            step, passing the original cause.
        </member>
        <member name="M:Akka.Streams.TransformerLikeBase`2.Cleanup">
            Invoked after normal completion or failure.
        </member>
        <member name="T:Akka.Streams.Util.Option`1">
            <summary>
            Allows tracking of whether a value has be initialized (even with the default value) for both
            reference and value types.
            Useful where distinguishing between null (or zero, or false) and unitialized is significant.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Akka.Streams.Util.IIterator`1">
            <summary>
            Interface matching Java's iterator semantics.
            Should only be needed in rare circumstances, where knowing whether there are
            more elements without consuming them makes the code easier to write.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
    </members>
</doc>
